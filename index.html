<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EO - Enhanced Database</title>
    <link id="dynamicFavicon" rel="icon" type="image/svg+xml" href="assets/eo-icons/eo-bracket-light.svg">
    <link id="dynamicAppleIcon" rel="apple-touch-icon" href="assets/eo-icons/eo-bracket-light.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="eo_lean_context.js"></script>
    <script src="eo_provenance_extractor.js"></script>
    <script src="demo/eo_rollup_engine.js"></script>
    <script src="demo/eo_linked_fields_modal.js"></script>
    <link rel="stylesheet" href="demo/eo_linked_fields_modal.css">
    <style>
        :root {
            --primary: #111827;
            --primary-dark: #0f172a;
            --surface: #ffffff;
            --muted-surface: #f4f5f7;
            --border: #e5e7eb;
            --border-strong: #0f172a;
            --text: #0b1324;
            --text-secondary: #4b5563;
            --sidebar-width: 260px;
            --sidebar-collapsed-width: 64px;
            --mobile-padding: 16px;
            --mobile-bottom-bar-height: 72px;
        }

        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            background: var(--muted-surface);
            color: var(--text);
        }

        .mobile-topbar {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 12px var(--mobile-padding);
            position: sticky;
            top: 0;
            z-index: 50;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .mobile-topbar-title {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: -0.01em;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mobile-icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text);
        }

        .mobile-bottom-bar {
            display: none;
            position: fixed;
            inset: auto 0 0;
            height: var(--mobile-bottom-bar-height);
            background: var(--surface);
            border-top: 1px solid var(--border);
            z-index: 40;
            padding: 10px var(--mobile-padding);
            grid-template-columns: repeat(4, 1fr) 64px;
            gap: 10px;
            box-shadow: 0 -6px 24px rgba(15, 23, 42, 0.08);
        }

        .mobile-bottom-action {
            display: inline-flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--muted-surface);
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-bottom-action.active {
            border-color: var(--primary);
            background: #e0e7ff;
            color: var(--primary);
        }

        .mobile-fab {
            position: fixed;
            right: var(--mobile-padding);
            bottom: calc(var(--mobile-bottom-bar-height) + 12px);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: 0 10px 30px rgba(37, 99, 235, 0.35);
            z-index: 45;
            cursor: pointer;
        }

        i.ph {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        /* LAYOUT */
        .app-container {
            display: grid;
            grid-template-areas: "sidebar header" "sidebar main";
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            transition: grid-template-columns 0.3s ease;
            background: var(--muted-surface);
        }
        .app-container.sidebar-collapsed { grid-template-columns: var(--sidebar-collapsed-width) 1fr; }
        .app-sidebar {
            grid-area: sidebar;
            background: #0f172a;
            color: white;
            border-right: 1px solid #111827;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .sidebar-actions {
            flex-shrink: 0;
            border-top: 1px solid #1e293b;
        }

        /* Sidebar Collapse Button */
        .sidebar-header-row {
            border-bottom: 1px solid #1e293b;
            transition: padding 0.3s ease, justify-content 0.3s ease;
        }
        .sidebar-collapse-btn {
            background: transparent;
            border: 1px solid #334155;
            color: #94a3b8;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .sidebar-collapse-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border-color: #475569;
        }
        .sidebar-collapse-btn i {
            font-size: 14px;
            transition: transform 0.3s ease;
        }
        .sidebar-collapsed .sidebar-header-row {
            justify-content: center;
            padding: 1rem 0.5rem;
        }
        .sidebar-collapsed .sidebar-brand {
            display: none;
        }
        .sidebar-collapsed .sidebar-collapse-btn i {
            transform: rotate(180deg);
        }
        .sidebar-collapsed .sidebar-content {
            display: none;
        }
        .sidebar-collapsed .sidebar-actions {
            display: none;
        }

        .app-header {
            grid-area: header;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .world-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 18px;
            border-bottom: 1px solid var(--border);
        }

        .world-toolbar-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .world-pill {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--muted-surface);
            color: var(--text);
            font-weight: 600;
        }

        .world-pill i {
            color: #2563eb;
        }

        .world-toolbar-hint {
            margin: 0;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .world-toolbar-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-toolbar-actions .btn-sm {
            min-width: auto;
        }

        .view-toolbar-note {
            padding: 10px 18px;
            color: var(--text-secondary);
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            background: #f9fafb;
        }
        .app-main {
            grid-area: main;
            overflow: auto;
            background: var(--muted-surface);
            padding: 16px 20px 24px;
        }

        .view-workspace { display: flex; flex-direction: column; gap: 4px; min-height: calc(100vh - 140px); }
        .view-tabs-rail { padding: 0 6px 0 6px; }
        
        /* SIDEBAR */
        .sidebar-header {
            padding: 18px 16px 18px 20px;
            border-bottom: 1px solid #2a2e38;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .sidebar-collapsed .sidebar-header { padding: 18px 10px; justify-content: center; }
        .sidebar-brand-logo {
            width: 52px;
            height: 52px;
            padding: 10px;
            border-radius: 14px;
            background: #0b1020;
            border: 1px solid #1f2937;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 26px rgba(0, 0, 0, 0.2);
            transition: opacity 0.2s, width 0.2s, padding 0.2s, margin 0.2s;
        }
        .sidebar-brand-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 10px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(255,255,255,0));
        }
        .sidebar-collapsed .sidebar-brand-logo { opacity: 0; width: 0; padding: 0; margin: 0; overflow: hidden; }
        .sidebar-toggle {
            background: transparent;
            border: 1px solid #2f343d;
            color: #e5e7eb;
            padding: 8px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sidebar-toggle:hover { background: rgba(255,255,255,0.05); color: #fff; border-color: #fff; }
        .sidebar-section { padding: 16px 12px 12px 12px; display: flex; flex-direction: column; gap: 8px; }
        .sidebar-section.grow { flex: 1; overflow-y: auto; }
        .sidebar-section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            padding: 8px 12px 6px;
            margin-bottom: 6px;
            transition: opacity 0.2s;
        }
        .sidebar-collapsed .sidebar-section-title { opacity: 0; height: 0; overflow: hidden; margin: 0; }

        .world-switcher {
            padding: 12px 12px 0 12px;
            border-bottom: 1px solid #111827;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .world-switcher-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.04);
            border: 1px solid #1f2937;
            border-radius: 10px;
            color: #e5e7eb;
            flex: 1;
        }

        .world-badge small {
            display: block;
            color: #9ca3af;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .world-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .world-select {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #334155;
            background: #1e293b;
            color: #e5e7eb;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            outline: none;
            transition: border-color 0.15s ease, background-color 0.15s ease;
        }

        .world-select:hover {
            background: #263549;
            border-color: #475569;
        }

        .world-select:focus {
            border-color: #6ee7b7;
            box-shadow: 0 0 0 2px rgba(110, 231, 183, 0.15);
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid #1f2937;
            color: #e5e7eb;
        }

        .sidebar-collapsed .world-switcher {
            padding: 12px 8px;
            align-items: center;
        }

        .sidebar-collapsed .world-badge {
            justify-content: center;
            padding: 10px;
        }

        .sidebar-collapsed .world-badge div { display: none; }

        .sidebar-collapsed .world-actions {
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .sidebar-collapsed .world-actions .world-select { display: none; }

        .sidebar-collapsed #addWorldBtn {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .btn-ghost:hover {
            border-color: #fff;
            color: #fff;
        }
        
        .set-item {
            margin-bottom: 4px;
        }
        
        .set-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
            color: #cbd5e1;
            border: 1px solid transparent;
        }
        .set-header:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); color: #fff; }
        .set-header.active { background: #111827; color: #ffffff; border-color: #111827; box-shadow: none; }
        .set-icon, .view-item-icon {
            font-size: 18px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .set-icon i, .view-item-icon i { font-size: 18px; }
        .set-header.active .set-icon { background: rgba(255, 255, 255, 0.12); border-color: rgba(255, 255, 255, 0.18); }
        .world-badge .set-icon { background: rgba(255, 255, 255, 0.08); border-color: rgba(255, 255, 255, 0.12); }
        .set-name { flex: 1; transition: opacity 0.2s; font-weight: 600; letter-spacing: -0.01em; }
        .set-expand-icon {
            font-size: 12px;
            transition: transform 0.2s;
            opacity: 0.7;
        }
        .set-item.expanded .set-expand-icon { transform: rotate(90deg); }
        .sidebar-collapsed .set-name { opacity: 0; width: 0; overflow: hidden; }
        .sidebar-collapsed .set-expand-icon { display: none; }
        .sidebar-collapsed .set-header { justify-content: center; padding: 10px; }
        
        .views-list {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            margin-left: 32px;
            margin-top: 6px;
        }
        .set-item.expanded .views-list {
            max-height: 500px;
            opacity: 1;
        }
        .sidebar-collapsed .views-list { display: none; }
        
        .view-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #9ca3af;
            position: relative;
        }
        .view-item:hover { background: #252931; color: #e5e7eb; }
        .view-item.active { background: #2f343d; color: #ffffff; font-weight: 600; }
        .view-item-icon { font-size: 16px; opacity: 0.9; color: #cbd5e1; }
        
        .add-view-btn {
            padding: 6px 12px;
            font-size: 13px;
            color: #6b7280;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s;
            margin-top: 6px;
        }
        .add-view-btn:hover { background: #252931; color: #e5e7eb; }

        .new-set-btn {
            margin-top: auto;
            padding: 14px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #6b7280;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: color 0.15s ease;
        }
        .new-set-btn:hover { color: #9ca3af; }

        .knowledge-nav { display: flex; flex-direction: column; gap: 8px; margin-bottom: 6px; }
        .knowledge-nav-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .knowledge-nav-btn:hover { background: var(--muted-surface); }
        .knowledge-nav-btn.active { border-color: #3b82f6; color: #1d4ed8; background: #e0e7ff; }
        .knowledge-nav-btn i { color: inherit; }

        .sidebar-section-title.collapsible {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }
        .sidebar-section-title.collapsible:hover { color: #9ca3af; }
        .sidebar-section-title .collapse-icon {
            transition: transform 0.2s ease;
            font-size: 14px;
        }
        .sidebar-section-title.collapsed .collapse-icon { transform: rotate(-90deg); }
        .sidebar-section .knowledge-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
            max-height: 500px;
            opacity: 1;
        }
        .sidebar-section .knowledge-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* TOOLBAR */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            padding: 16px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
            flex-wrap: wrap;
        }

        .toolbar-inline-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .primary-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .toolbar-menu { position: relative; }
        .toolbar-menu.open .toolbar-menu-panel { display: flex; }

        .toolbar-menu-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-menu-panel {
            display: none;
            position: absolute;
            right: 0;
            top: calc(100% + 10px);
            min-width: 240px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--surface);
            box-shadow: 0 12px 40px rgba(15, 23, 42, 0.15);
            flex-direction: column;
            gap: 6px;
            z-index: 15;
        }

        .toolbar-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 2px 0;
        }

        .toolbar-menu-item {
            width: 100%;
            justify-content: flex-start;
            gap: 10px;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            background: var(--muted-surface);
        }

        .toolbar-menu-item:hover {
            background: var(--surface);
            color: var(--text);
            border-color: var(--text);
        }

        .toolbar .sort-sequence-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 8px;
            background: #f3f4f6;
            color: #4b5563;
            font-size: 13px;
        }

        .view-type-switcher {
            display: flex;
            gap: 8px;
        }

        .view-type-btn {
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: none;
        }

        .view-type-btn:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .view-type-btn.active { background: var(--primary); color: #ffffff; border-color: var(--primary); }
        
        /* CELLS */
        .cell-editable {
            min-height: 36px;
            padding: 12px 16px;
            cursor: text;
            border-right: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            position: relative;
        }
        .cell-editable:hover:not(.cell-editing):not(.cell-selected) {
            background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.03), transparent);
            cursor: pointer;
            border-left: 2px solid rgba(59, 130, 246, 0.15);
        }
        .cell-static {
            min-height: 36px;
            padding: 12px 16px;
            border-right: 1px solid #f0f0f0;
            background: #f9fafb;
            color: #4b5563;
            font-weight: 600;
            letter-spacing: -0.01em;
        }
        .cell-selected {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: #eff6ff !important;
            position: relative;
            z-index: 1;
        }
        .cell-editing {
            outline: 2px solid #3b82f6 !important;
            outline-offset: -2px;
            background: white !important;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12) !important;
            z-index: 2;
        }
        .cell-recently-changed { animation: none; }
        @keyframes flash-yellow { 0% { background-color: #fef3c7; } 100% { background-color: transparent; } }
        .cell-keyboard-focus {
            outline: 2px dashed #3b82f6;
            outline-offset: -2px;
        }
        .cell-loading {
            position: relative;
            pointer-events: none;
        }
        .cell-loading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* ROLLUP/SUPERPOSITION CELL BADGES */
        .sup-chip-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .sup-value-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            color: #1e40af;
            font-size: 13px;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid #bfdbfe;
            box-shadow: 0 1px 2px rgba(59, 130, 246, 0.08);
            white-space: nowrap;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sup-count-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: #4b5563;
            font-size: 12px;
            font-weight: 600;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            box-shadow: 0 1px 2px rgba(107, 114, 128, 0.08);
            white-space: nowrap;
        }

        .sup-value-badge:hover,
        .sup-count-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.15);
        }

        /* ROLLUP MODAL CARDS */
        .sup-modal-card {
            background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .sup-modal-card:hover {
            border-color: #bfdbfe;
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.1);
            transform: translateY(-1px);
        }

        .sup-modal-card-index {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            font-size: 13px;
            font-weight: 700;
            border-radius: 6px;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        .sup-modal-card-value {
            font-size: 15px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 6px;
            line-height: 1.4;
        }

        .sup-modal-card-source {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
        }

        /* TABLE HEADERS */
        .column-header {
            background: var(--surface);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 11px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #666;
            border-bottom: 1px solid var(--border);
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s;
            user-select: none;
            position: relative;
        }
        .column-header.column-grab-ready {
            cursor: grabbing;
            background: var(--muted-surface);
            box-shadow: inset 0 0 0 1px var(--border);
        }
        .column-resizer {
            position: absolute;
            top: 0;
            right: -4px;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 5;
        }
        body.resizing {
            cursor: col-resize;
        }
        .column-header:hover { background: var(--muted-surface); }

        body.column-grab-ready { cursor: grab; }
        body.column-dragging { cursor: grabbing; }
        .column-being-dragged { opacity: 0.5; }

        .column-drag-ghost {
            position: fixed;
            pointer-events: none;
            background: white;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            padding: 10px 14px;
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
            opacity: 0.95;
            z-index: 1200;
            transform: translate3d(0, 0, 0);
        }

        .column-drop-before::before,
        .column-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .column-drop-before::before { left: -2px; }
        .column-drop-after::after { right: -2px; }

        table { width: auto; border-collapse: collapse; table-layout: fixed; }
        thead { background: #f9fafb; border-bottom: 1px solid #e5e7eb; }
        th {
            padding: 12px 16px;
            text-align: left;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            color: #6b7280;
            letter-spacing: 0.05em;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        th .sort-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 12px;
        }

        th .sort-indicator .order-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 6px;
            border-radius: 999px;
            background: #e5e7eb;
            color: #111827;
            font-size: 11px;
            font-weight: 700;
        }

        th .column-title {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        th .column-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 999px;
            background: #eef2ff;
            color: #3730a3;
            font-weight: 700;
            text-transform: none;
            font-size: 11px;
        }

        th .sort-indicator .direction-icon { font-size: 10px; }

        th .sort-indicator.muted { opacity: 0.5; }
        tbody tr {
            border-bottom: 1px solid #f3f4f6;
            transition: all 0.1s ease;
        }
        tbody tr:hover { background: #fafafa; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02); }
        tbody tr:hover td:first-child { color: #3b82f6; font-weight: 700; }
        tbody tr:last-child { border-bottom: none; }
        td {
            padding: 16px;
            font-size: 14px;
            color: #1f2937;
            vertical-align: middle;
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        td:first-child {
            color: #9ca3af;
            font-weight: 600;
            font-size: 13px;
            min-width: 60px;
        }
        tr:hover { background-color: #fafafa; }

        #dataTable thead th,
        #dataTable tbody td { background-clip: padding-box; transition: background-color 0.2s ease; }
        #dataTable thead th:nth-child(odd),
        #dataTable tbody td:nth-child(odd) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.012); }
        #dataTable thead th:nth-child(even),
        #dataTable tbody td:nth-child(even) { box-shadow: inset 0 0 0 9999px rgba(15, 23, 42, 0.024); }
        #dataTable tbody tr:nth-child(odd) { background-color: rgba(15, 23, 42, 0.02); }
        #dataTable tbody tr:nth-child(even) { background-color: rgba(15, 23, 42, 0.03); }
        #dataTable tbody tr:hover td { background: #f4f6fb; }
        #dataTable th:not(:last-child), #dataTable td:not(:last-child) { border-right: 1px solid #eef2f7; }
        .table-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            color: #4b5563;
            font-size: 13px;
        }
        .record-counter {
            font-weight: 700;
            color: #111827;
        }

        /* Enhanced select dropdown */
        .custom-select-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 250px;
            max-width: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .custom-select-search {
            padding: 8px 12px;
            border: none;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            outline: none;
        }

        .custom-select-search:focus { border-bottom-color: #3b82f6; }

        .custom-select-options { overflow-y: auto; flex: 1; }

        .custom-select-option {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-select-option:hover { background: #f3f4f6; }
        .custom-select-option.highlighted { background: #eff6ff; color: #1e40af; }
        .custom-select-option.selected { background: #3b82f6; color: white; font-weight: 600; }

        .custom-select-option-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .custom-select-option-text { flex: 1; }

        .custom-select-option-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f3f4f6;
            color: #6b7280;
        }

        .custom-select-empty {
            padding: 40px 20px;
            text-align: center;
            color: #9ca3af;
        }

        .custom-select-empty-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .custom-select-footer {
            border-top: 1px solid #e5e7eb;
            padding: 8px;
            display: flex;
            gap: 4px;
        }

        .custom-select-footer button {
            flex: 1;
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
        }

        .custom-select-footer button:hover { background: #f3f4f6; border-color: #d1d5db; }

        .search-match {
            background: #fef3c7;
            font-weight: 600;
            padding: 0 2px;
            border-radius: 2px;
        }

        /* SEARCH FOCUS PANEL */
        .search-shell {
            display: flex;
            gap: 16px;
            height: calc(90vh - 100px);
        }

        .search-surface {
            flex: 2;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .search-input-row {
            padding: 12px 20px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .search-input-row input {
            flex: 1;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            padding: 8px 14px;
            font-size: 14px;
        }

        .search-input-row input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
        }

        .search-input-row .scope-pill {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            color: #4b5563;
            white-space: nowrap;
        }

        .search-results-container {
            padding: 8px 0 12px;
            overflow: auto;
            flex: 1;
        }

        .results-section {
            padding: 8px 20px 4px;
        }

        .results-section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #9ca3af;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .result-item {
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            cursor: pointer;
            transition: background 0.12s ease;
            margin-bottom: 4px;
        }

        .result-item:hover {
            background: #f3f4ff;
        }

        .result-item.focused {
            background: #eff6ff;
            border: 1px solid #2563eb;
        }

        .result-main {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .result-label {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-meta {
            font-size: 12px;
            color: #6b7280;
        }

        .focus-btn {
            border-radius: 999px;
            border: 1px solid #2563eb;
            background: #eff6ff;
            color: #1d4ed8;
            font-size: 12px;
            padding: 6px 10px;
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .focus-btn:hover {
            background: #dbeafe;
        }

        /* FOCUS PANEL */
        .focus-panel {
            flex: 1.2;
            min-width: 320px;
            max-width: 420px;
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border);
            background: #f9fafb;
        }

        .focus-panel.hidden {
            display: none;
        }

        .focus-header {
            padding: 16px 18px 10px;
            border-bottom: 1px solid var(--border);
            background: white;
        }

        .focus-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #9ca3af;
            margin-bottom: 4px;
        }

        .focus-title-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .focus-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
        }

        .focus-tag {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 999px;
            background: #eef2ff;
            color: #3730a3;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .focus-subtitle {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .focus-clear {
            margin-top: 8px;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #f9fafb;
            color: #6b7280;
            cursor: pointer;
        }

        .focus-clear:hover {
            background: #e5e7eb;
        }

        .focus-body {
            padding: 12px 18px 16px;
            overflow: auto;
            flex: 1;
            background: white;
        }

        .focus-section {
            margin-bottom: 16px;
        }

        .focus-section h4 {
            margin: 0 0 8px;
            font-size: 12px;
            font-weight: 600;
            color: #4b5563;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .focus-kv {
            font-size: 13px;
            margin-bottom: 6px;
            line-height: 1.5;
        }

        .focus-kv-label {
            color: #6b7280;
            font-weight: 500;
        }

        .focus-kv-value {
            color: var(--text);
        }

        .focus-badge-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .focus-badge {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #f9fafb;
            color: #4b5563;
        }

        .focus-actions {
            padding: 10px 18px 14px;
            border-top: 1px solid var(--border);
            background: #f9fafb;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .focus-action-btn {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #d1d5db;
            background: white;
            cursor: pointer;
            white-space: nowrap;
        }

        .focus-action-btn:hover {
            background: #eff6ff;
            border-color: #2563eb;
            color: #1d4ed8;
        }

        /* ZERO-INPUT SEARCH */
        .zero-input-section {
            padding: 8px 20px 12px;
        }

        .zero-input-section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #9ca3af;
            margin: 16px 0 6px;
            font-weight: 600;
        }

        .zero-input-section-title:first-child {
            margin-top: 0;
        }

        .zero-input-item {
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            cursor: pointer;
            transition: background 0.12s ease;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .zero-input-item:hover {
            background: #f3f4ff;
        }

        .zero-input-item-label {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .zero-input-type-label {
            font-size: 11px;
            background: #eef2ff;
            padding: 2px 8px;
            border-radius: 6px;
            color: #3730a3;
            white-space: nowrap;
        }

        .browse-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 6px;
        }

        .browse-item {
            padding: 10px 12px;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #4b5563;
            transition: all 0.12s ease;
        }

        .browse-item:hover {
            background: #f3f4ff;
            border-color: #c7d2fe;
            color: #3730a3;
        }

        @media (max-width: 900px) {
            .search-shell {
                flex-direction: column;
            }
            .focus-panel {
                max-width: 100%;
                border-left: none;
                border-top: 1px solid var(--border);
            }
        }

        .table-scroll {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        /* CARD VIEW */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
        }
        
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: none;
        }

        .card:hover {
            transform: translateY(-2px);
            border-color: var(--border-strong);
        }
        
        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 12px;
        }
        
        .card-field {
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .card-field-label {
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .card-field-value {
            color: #111827;
        }
        
        /* KANBAN VIEW */
        .kanban-board {
            display: flex;
            gap: 16px;
            padding: 8px;
            overflow-x: auto;
            min-height: calc(100vh - 200px);
        }
        
        .kanban-column {
            min-width: 300px;
            background: var(--muted-surface);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }
        
        .kanban-column-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 12px;
            border-radius: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
        }
        
        .kanban-column-title {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
        }
        
        .kanban-column-count {
            font-size: 12px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        .kanban-cards {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 100px;
        }
        
        .kanban-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            cursor: move;
            transition: all 0.15s ease;
        }

        .kanban-card:hover {
            border-color: var(--border-strong);
        }
        
        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }
        
        .kanban-column.drag-over {
            background: #e0f2fe;
        }
        
        .kanban-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
            font-size: 14px;
        }

        /* GRAPH VIEW */
        .graph-container {
            width: 100%;
            height: 600px;
            background: #fafbfc;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border);
        }

        .graph-node:hover circle {
            fill: #2563eb;
            stroke: #1e3a8a;
        }

        /* vis-network navigation buttons styling */
        .graph-container .vis-button {
            background: var(--surface) !important;
            border: 1px solid var(--border) !important;
            border-radius: 6px !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        .graph-container .vis-button:hover {
            background: var(--muted-surface) !important;
            border-color: var(--border-strong) !important;
        }

        /* Custom graph navigation buttons */
        .graph-nav-btn {
            transition: all 0.2s ease;
        }

        .graph-nav-btn:hover {
            background: #f3f4f6 !important;
            border-color: #d1d5db !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.15) !important;
        }

        .graph-nav-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        /* Tooltip styling */
        .vis-tooltip {
            background: white !important;
            border: 1px solid var(--border) !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
            padding: 0 !important;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto !important;
        }

        /* CONTEXT MENU */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            overflow: hidden;
        }
        .context-menu-item {
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-menu-item:hover { background: #f3f4f6; }
        .context-menu-item.danger:hover { background: #fee2e2; color: #dc2626; }
        .context-menu-separator { height: 1px; background: #e5e7eb; margin: 4px 0; }
        
        /* MODALS */
        .modal-overlay { backdrop-filter: blur(2px); animation: fadeIn 0.2s ease; }
        .modal-container { border-radius: 8px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2); animation: slideUp 0.25s cubic-bezier(0.16, 1, 0.3, 1); }
        #expandedRecordModal .modal-container { height: 90vh; }
        #addFieldModal .modal-container { max-width: 540px; width: 100%; border-radius: 10px; }
        #addFieldModal .modal-container, #addFieldModal .modal-body { overflow: visible; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { padding: 24px 24px 16px 24px; border-bottom: 1px solid #f0f0f0; }
        .modal-body { padding: 24px; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid #f0f0f0; background: #fafafa; }
        #addFieldModal .modal-header { padding: 16px 18px 10px 18px; }
        #addFieldModal .modal-body { padding: 16px 18px 18px 18px; }
        #addFieldModal .modal-footer { padding: 14px 18px; background: #f8fafc; }
        .icon-picker-shell { max-height: 90vh; display: flex; flex-direction: column; }
        .icon-picker-body { display: flex; flex-direction: column; gap: 12px; flex: 1; }
        .icon-picker-controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .icon-picker-search { flex: 1 1 260px; }
        .icon-picker-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(44px, 1fr)); gap: 8px; max-height: 60vh; overflow: auto; padding-right: 4px; }
        .icon-pagination { display: flex; align-items: center; gap: 12px; margin-left: auto; font-size: 13px; color: #475569; }
        .icon-pagination-count { font-weight: 700; }
        .icon-pagination-buttons { display: inline-flex; align-items: center; gap: 6px; }
        .icon-page-btn { padding: 6px 10px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; font-weight: 600; color: #0f172a; cursor: pointer; transition: all 0.15s ease; }
        .icon-page-btn:hover { background: #f8fafc; border-color: #cbd5e1; }
        .icon-page-btn:disabled { opacity: 0.55; cursor: not-allowed; background: #f8fafc; }
        .icon-option { display: flex; align-items: center; justify-content: center; padding: 6px; border-radius: 12px; border: 1px solid #e2e8f0; background: #ffffff; cursor: pointer; transition: all 0.12s ease; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.04); }
        .icon-option:hover { border-color: #cbd5e1; background: #f8fafc; transform: translateY(-1px); }
        .icon-option.active { border-color: #2563eb; background: #eff6ff; color: #1d4ed8; box-shadow: 0 0 0 2px rgba(37,99,235,0.15); }
        .icon-option .icon-chip { width: 36px; height: 36px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; background: #f8fafc; color: #0f172a; border: 1px solid #e2e8f0; font-size: 18px; }
        .icon-option.active .icon-chip { background: #e0ecff; border-color: #bfdbfe; color: #1d4ed8; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

        .icon-selector { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc; cursor: pointer; transition: all 0.15s ease; }
        .icon-selector:hover { border-color: #cbd5e1; background: #f1f5f9; box-shadow: inset 0 0 0 1px #e2e8f0; }
        .icon-selector-icon { width: 40px; height: 40px; border-radius: 10px; background: #ffffff; border: 1px solid #e2e8f0; display: inline-flex; align-items: center; justify-content: center; font-size: 22px; color: #0f172a; }
        .icon-selector-text { flex: 1; min-width: 0; }
        .icon-selector-label { font-size: 13px; color: #475569; }
        .icon-selector-token { display: none; }
        .icon-selector-chevron { color: #94a3b8; font-size: 12px; }
        .config-section { max-height: 0; overflow: hidden; opacity: 0; transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease; margin-top: 0; }
        .config-section.visible { max-height: 500px; opacity: 1; margin-top: 16px; }

        /* POPUP CONFIGURATOR */
        .popup-config-shell { max-width: 1200px; width: 100%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; padding: 20px 24px; }
        .popup-config-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; padding: 0 0 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tabs { display: flex; gap: 4px; padding: 12px 0; border-bottom: 1px solid #e2e8f0; background: transparent; }
        .popup-config-tab { padding: 10px 14px; border: none; background: transparent; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 2px solid transparent; display: inline-flex; gap: 8px; align-items: center; border-radius: 8px 8px 0 0; transition: all 0.2s ease; }
        .popup-config-tab:hover { color: #0f172a; background: #f8fafc; }
        .popup-config-tab.active { color: #1d4ed8; border-bottom-color: #1d4ed8; background: #eff6ff; }
        .popup-config-body { display: grid; grid-template-columns: 1fr 320px; gap: 20px; padding: 16px 0 0 0; background: #fff; flex: 1; overflow: hidden; }
        .popup-tab-panel { display: none; height: 100%; overflow: hidden; }
        .popup-tab-panel.active { display: block; }
        .popup-panel-scroll { height: 100%; overflow: auto; padding-right: 6px; }
        .popup-quick-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 14px; }
        .popup-filter { padding: 8px 12px; border-radius: 8px; border: 1px solid #e2e8f0; background: #fff; cursor: pointer; color: #475569; font-weight: 600; transition: all 0.15s ease; }
        .popup-filter:hover { border-color: #cbd5e1; background: #f8fafc; }
        .popup-filter.active { background: #eef2ff; border-color: #1d4ed8; color: #1d4ed8; }
        .popup-info { display: flex; gap: 10px; padding: 12px; background: #eef2ff; border: 1px solid #c7d2fe; border-radius: 8px; color: #1e3a8a; margin-bottom: 14px; font-size: 14px; }
        .popup-field-card { border: 1px solid #e2e8f0; border-radius: 6px; padding: 16px; display: flex; align-items: center; gap: 12px; margin-bottom: 12px; background: #fff; transition: all 0.2s ease; }
        .popup-field-card:hover { border-color: #cbd5e1; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04); }
        .popup-field-card.dragging { opacity: 0.6; }
        .popup-field-card.drag-over { border-color: #1d4ed8; background: #eef2ff; }
        .popup-field-card .drag-handle { cursor: grab; color: #94a3b8; font-size: 18px; }
        .popup-field-icon { width: 38px; height: 38px; border-radius: 10px; border: 1px solid #e2e8f0; background: #f8fafc; display: inline-flex; align-items: center; justify-content: center; font-size: 18px; color: #0f172a; }
        .popup-field-meta { flex: 1; min-width: 0; }
        .popup-field-name { font-weight: 700; color: #0f172a; display: flex; gap: 6px; align-items: center; }
        .popup-field-type { font-size: 13px; color: #64748b; }
        .field-type { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 500; }
        .popup-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 999px; background: #f8fafc; border: 1px solid #e2e8f0; font-size: 12px; color: #475569; font-weight: 600; }
        .popup-badge.warn { background: #fef3c7; border-color: #fde68a; color: #b45309; }
        .popup-toggle { width: 46px; height: 26px; border-radius: 999px; background: #e5e7eb; position: relative; cursor: pointer; transition: all 0.2s ease; }
        .popup-toggle::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; background: #fff; top: 3px; left: 3px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); transition: all 0.2s ease; }
        .popup-toggle.active { background: #1d4ed8; }
        .popup-toggle.active::after { transform: translateX(20px); }
        .popup-side { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .popup-card { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; }
        .popup-card h4 { margin: 0 0 8px 0; font-size: 14px; color: #0f172a; font-weight: 700; }
        .popup-stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .popup-stat { background: #fff; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; }
        .popup-stat .value { font-size: 24px; font-weight: 800; color: #0f172a; }
        .popup-stat .label { font-size: 12px; color: #6b7280; }
        .popup-preview { border: 1px solid #e2e8f0; border-radius: 8px; background: #fafafa; padding: 14px; }
        .popup-preview-header { font-weight: 700; margin-bottom: 10px; color: #0f172a; display: flex; justify-content: space-between; align-items: center; }
        .popup-preview-fields { display: grid; gap: 10px; }
        .popup-preview-fields.cols-1 { grid-template-columns: 1fr; }
        .popup-preview-fields.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .popup-preview-fields.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .popup-preview-fields.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .popup-preview-field { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 10px; }
        .popup-preview-field .label { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
        .popup-preview-field .value { font-size: 13px; color: #0f172a; }
        .popup-layout-options { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .popup-layout-option { border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; cursor: pointer; text-align: center; transition: all 0.15s ease; background: #fff; }
        .popup-layout-option.active { border-color: #1d4ed8; background: #eef2ff; color: #1d4ed8; }
        .popup-event-stream { display: flex; flex-direction: column; gap: 10px; }
        .popup-event { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; color: #0f172a; font-weight: 700; font-size: 14px; }
        .popup-event-time { color: #94a3b8; font-size: 12px; font-weight: 600; }
        .popup-conditions { display: grid; gap: 10px; }
        .popup-condition-card { border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; background: #fff; }
        .popup-condition-title { font-weight: 700; color: #0f172a; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .popup-condition-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 10px; }
        .popup-pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #f3f4f6; color: #475569; font-weight: 600; font-size: 12px; }
        .popup-template-buttons { display: flex; flex-direction: column; gap: 8px; }
        @media (max-width: 1100px) { .popup-config-body { grid-template-columns: 1fr; } .popup-side { order: -1; flex-direction: row; overflow-x: auto; } .popup-side .popup-card { min-width: 240px; } }

        /* FIELD MANAGER */
        .field-manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #fff;
            transition: all 0.2s ease;
            cursor: move;
        }
        .field-manager-item:hover {
            border-color: #cbd5e1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        .field-manager-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .field-manager-item.drag-over {
            border-color: #1d4ed8;
            background: #eff6ff;
        }
        .field-drag-handle {
            cursor: grab;
            color: #94a3b8;
            font-size: 18px;
            padding: 4px;
        }
        .field-drag-handle:active {
            cursor: grabbing;
        }
        .field-manager-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #475569;
            flex-shrink: 0;
        }
        .field-manager-info {
            flex: 1;
            min-width: 0;
        }
        .field-manager-name {
            font-weight: 600;
            color: #0f172a;
            font-size: 14px;
            margin-bottom: 2px;
        }
        .field-manager-name input {
            font-weight: 600;
            color: #0f172a;
            font-size: 14px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            padding: 2px 6px;
            width: 100%;
        }
        .field-manager-type-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
        }
        .field-manager-type-select {
            font-size: 12px;
            padding: 2px 4px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            background: #fff;
            color: #475569;
        }
        .field-manager-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }
        .field-manager-action-btn {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            background: #fff;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
            color: #64748b;
        }
        .field-manager-action-btn:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            color: #0f172a;
        }
        .field-manager-action-btn.danger:hover {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #dc2626;
        }

        /* BUTTONS */
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            border: 1px solid var(--border);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: none;
        }
        .btn-primary:hover { background: transparent; color: var(--text); border-color: var(--text); box-shadow: none; }
        .btn-secondary { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); box-shadow: none; }
        .btn-secondary:hover { background: var(--muted-surface); border-color: var(--text); color: var(--text); }
        .btn-danger { background: transparent; border: 1px solid var(--border); color: var(--text-secondary); box-shadow: none; }
        .btn-danger:hover { background: #fef2f2; border-color: #ef4444; color: #ef4444; }
        .btn-sm { padding: 5px 10px; font-size: 13px; }
        
        /* BADGES */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        .badge-green { background-color: #d1fae5; color: #065f46; }
        .badge-yellow { background-color: #fef3c7; color: #92400e; }
        .badge-red { background-color: #fee2e2; color: #991b1b; }
        .badge-blue { background-color: #dbeafe; color: #1e40af; }
        .badge-purple { background-color: #e9d5ff; color: #6b21a8; }
        .badge-gray { background-color: #f3f4f6; color: #374151; }
        .badge-cyan { background-color: #cffafe; color: #155e75; }
        .badge-pink { background-color: #fce7f3; color: #9f1239; }
        
        /* FIELD TYPE DROPDOWN */
        .field-type-select { position: relative; }
        .field-type-trigger {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 64px;
        }
        .field-type-trigger:hover { border-color: #94a3b8; box-shadow: 0 6px 18px rgba(15, 23, 42, 0.05); }
        .field-type-trigger.active { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12), 0 10px 30px rgba(15, 23, 42, 0.12); }
        .field-type-trigger-content { display: flex; align-items: center; gap: 12px; }
        .field-type-trigger-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-trigger-text { display: flex; flex-direction: column; gap: 3px; text-align: left; }
        .field-type-trigger-arrow { color: #64748b; font-size: 13px; }
        .field-type-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            width: min(760px, calc(100vw - 48px));
            padding: 12px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.16);
            max-height: 520px;
            overflow-y: auto;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            gap: 10px;
        }
        .field-type-dropdown.hidden { display: none; }
        .field-type-option {
            padding: 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            background: white;
        }
        .field-type-option:hover { background: #f8fafc; box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08); }
        .field-type-option.selected { background: #eff6ff; border: 1px solid #3b82f6; box-shadow: 0 14px 32px rgba(59, 130, 246, 0.18); }
        .field-type-icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 10px; font-size: 20px; }
        .field-type-option.selected .field-type-icon { background: #3b82f6; color: white; }
        .field-type-info { display: flex; flex-direction: column; gap: 3px; min-width: 0; }
        .field-type-name { font-size: 14px; font-weight: 700; color: #0f172a; }
        .field-type-description { font-size: 12px; color: #64748b; line-height: 1.5; }
        .field-type-check { margin-left: auto; color: #3b82f6; font-weight: 700; font-size: 14px; }
        
        /* FILTER BUILDER */
        .filter-group { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 12px; }
        .filter-group-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .filter-operator-toggle { display: flex; background: white; border: 1px solid #e5e7eb; border-radius: 6px; overflow: hidden; }
        .filter-operator-toggle button {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-operator-toggle button.active { background: #3b82f6; color: white; }
        .filter-rule { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; align-items: center; padding: 8px; background: white; border-radius: 6px; margin-bottom: 8px; }
        
        /* UTILITIES */
          .form-label { display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px; }
          .form-hint { font-size: 12px; color: #6b7280; margin-top: 6px; }
          .form-error { font-size: 12px; color: #b91c1c; margin-top: 6px; }
          input[type="text"], input[type="number"], input[type="date"], input[type="email"], input[type="url"], select, textarea {
              width: 100%;
              padding: 8px 12px;
              border: 1px solid #cbd5e1;
              border-radius: 6px;
            font-size: 13px;
            transition: all 0.15s ease;
            background: white;
          }
          input:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
          .input-error { border-color: #ef4444; box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.15); }

          .view-type-option { position: relative; cursor: pointer; }
          .view-type-option input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
          .view-type-option-content {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 8px;
              padding: 16px;
              border: 2px solid #e5e7eb;
              border-radius: 8px;
              background: white;
              transition: all 0.15s ease;
          }
          .view-type-option-content i { font-size: 24px; color: #6b7280; }
          .view-type-option-content span { font-size: 13px; font-weight: 500; color: #374151; }
          .view-type-option:hover .view-type-option-content { border-color: #3b82f6; background: #f0f9ff; }
          .view-type-option input[type="radio"]:checked + .view-type-option-content {
              border-color: #3b82f6;
              background: #eff6ff;
          }
          .view-type-option input[type="radio"]:checked + .view-type-option-content i { color: #3b82f6; }

          ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f3f4f6; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            z-index: 2000;
            animation: slideInToast 0.3s ease;
        }
        @keyframes slideInToast { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .side-panel {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 420px;
            background: white;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.12);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        .side-panel.open { transform: translateX(0); }

        .csv-helper-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 12px;
        }

        .csv-helper-card {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            background: white;
        }

        #csvPreviewContainer {
            overflow: auto;
            max-height: 340px;
        }

        .csv-preview-table {
            width: 100%;
            min-width: max-content;
            border-collapse: collapse;
            font-size: 12px;
            border: 1px solid #e5e7eb;
        }

        .csv-preview-table th, .csv-preview-table td {
            border: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
            background: white;
        }

        .csv-preview-table th { background: #f9fafb; font-weight: 700; }

        .csv-match-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 9999px;
            background: #eef2ff;
            color: #4338ca;
            font-weight: 600;
            font-size: 12px;
        }

        .fuzzy-match-row {
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            background: #fff;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .fuzzy-match-row strong { display: block; font-size: 14px; }

        .fuzzy-score {
            font-weight: 700;
            color: #16a34a;
        }

        .panel-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .option-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .option-row input { flex: 1; }
        .color-picker { display: flex; gap: 4px; flex-wrap: wrap; }
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
        }
        .color-option:hover { transform: scale(1.1); }
        .color-option.selected { border-color: #1e293b; }
        
        .field-editor { border: 1px solid #e5e7eb; border-radius: 6px; padding: 12px; transition: all 0.15s; }
        .field-editor:hover { border-color: #d1d5db; background: #fafafa; }
        .field-editor:focus-within { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .field-editor input, .field-editor textarea, .field-editor select { width: 100%; padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 4px; font-size: 14px; }
        
        .record-tabs { display: flex; border-bottom: 1px solid #e5e7eb; padding: 0 24px; background: #fafafa; }
        .record-tab {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: all 0.15s ease;
        }
        .record-tab:hover { color: #374151; }
        .record-tab.active { color: #2563eb; border-bottom-color: #2563eb; }

        .view-tabs {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 0 10px;
            background: transparent;
            overflow-x: auto;
            position: relative;
            border-bottom: 1px solid #e5e7eb;
        }

        .view-tab {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border: 1px solid transparent;
            border-bottom: 2px solid transparent;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s ease;
            color: #9ca3af;
            font-weight: 500;
            white-space: nowrap;
            flex-shrink: 0;
            user-select: none;
            border-radius: 8px 8px 0 0;
            margin-bottom: -1px;
        }

        .view-tab:hover {
            background: #fafafa;
            color: #374151;
        }

        .view-tab.active {
            background: linear-gradient(to bottom, #f0f9ff 0%, white 100%);
            border-top: 1px solid #bfdbfe;
            border-left: 1px solid #bfdbfe;
            border-right: 1px solid #bfdbfe;
            border-bottom: 3px solid #2563eb;
            color: #1e40af;
            font-weight: 600;
            box-shadow: 0 -2px 8px rgba(37, 99, 235, 0.12);
        }

        .view-tab.tab-being-dragged {
            opacity: 0.6;
        }

        .view-tab.tab-drop-before::before,
        .view-tab.tab-drop-after::after {
            content: '';
            position: absolute;
            top: 6px;
            bottom: 6px;
            width: 3px;
            background: #cbd5e1;
            border-radius: 999px;
        }
        .view-tab.tab-drop-before::before { left: -4px; }
        .view-tab.tab-drop-after::after { right: -4px; }

        .view-tab-icon {
            color: inherit;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .view-tab.active .view-tab-icon {
            opacity: 1;
        }

        .view-tab-text { display: flex; align-items: center; gap: 4px; min-width: 0; }
        .view-tab-name { font-weight: 600; font-size: 12px; color: inherit; white-space: nowrap; }
        .view-tab-meta {
            font-size: 10px;
            color: #9ca3af;
            padding: 1px 7px;
            border-radius: 6px;
            background: #f3f4f6;
            letter-spacing: 0.01em;
        }

        .view-tab-actions {
            display: inline-flex;
            gap: 4px;
            margin-left: auto;
            padding-left: 8px;
            color: #6b7280;
            opacity: 0;
            transform: translateX(6px);
            transition: all 0.12s ease;
        }

        .view-tab:hover .view-tab-actions,
        .view-tab.active .view-tab-actions {
            opacity: 1;
            transform: translateX(0);
        }

        .view-tab-btn {
            border: 1px solid transparent;
            background: transparent;
            color: inherit;
            border-radius: 10px;
            padding: 6px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .view-tab-btn:hover { color: #111827; background: #ffffff; border-color: #d1d5db; }
        .view-tab-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .view-surface {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 8px 8px;
            overflow: hidden;
            min-height: 420px;
            display: flex;
            flex-direction: column;
        }

        .view-stage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            flex-wrap: wrap;
        }

        .view-stage-title {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .view-stage-pill {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            color: #475569;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .view-stage-name { font-weight: 800; font-size: 16px; letter-spacing: -0.01em; color: #0f172a; }
        .view-stage-sub { color: #64748b; font-size: 13px; font-weight: 600; }

        .view-stage-actions { display: flex; flex-direction: column; gap: 10px; width: 100%; margin-top: 20px; }
        .view-stage-actions .primary-actions { flex-wrap: wrap; }
        .view-stage-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
        .view-stage-inline-actions { display: inline-flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        .toolbar-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: space-between; width: 100%; }
        .toolbar-row.scrollable { overflow-x: auto; padding-bottom: 4px; }
        .toolbar-group { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
        .selection-group { display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .selection-indicator { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #eef2ff; color: #3730a3; font-weight: 700; font-size: 12px; }
        .selection-indicator.hidden { display: none; }
        .selection-indicator i { font-size: 14px; }

        .view-stage-body { padding: 14px 16px 18px; background: #ffffff; flex: 1; }

        .view-table-shell {
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            background: #ffffff;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.7);
        }

        .selection-header { width: 46px; text-align: center; }
        .row-select-cell { width: 46px; text-align: center; }
        .row-select-cell input { width: 16px; height: 16px; }
        .row-number-header { width: 50px; text-align: right; padding-right: 12px; color: #9ca3af; font-size: 12px; font-weight: 500; user-select: none; }
        .row-number-cell { width: 50px; text-align: right; padding-right: 12px; color: #9ca3af; font-size: 12px; user-select: none; }
        .row-selected td { background: #eef2ff; }
        .row-selected:hover td { background: #e0e7ff; }

        .json-tab {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            background: transparent;
            border: none;
            transition: all 0.15s ease;
        }
        .json-tab:hover { color: #374151; background: #f9fafb; }
        .json-tab.active { color: #3b82f6; border-bottom-color: #3b82f6; }
        
        .json-key { color: #b45309; font-weight: 600; }
        .json-string { color: #15803d; }
        .json-number { color: #1e40af; }
        .json-boolean { color: #7c2d12; }
        .json-null { color: #991b1b; font-style: italic; }
        
        #jsonContent {
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .profile-selector { display: flex; gap: 8px; padding: 12px 0; overflow-x: auto; }
        .profile-tab {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid #e5e7eb;
            background: white;
            white-space: nowrap;
        }
        .profile-tab:hover { background: #f3f4f6; }
        .profile-tab.active { background: #8b5cf6; color: white; border-color: #8b5cf6; }
        
        .history-entry {
            border-left: 3px solid #e5e7eb;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.15s ease;
            cursor: pointer;
            border-radius: 4px;
        }
        .history-entry:hover { border-left-color: #3b82f6; background-color: #f9fafb; }

        .provenance-section {
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        .provenance-section h4 {
            margin-bottom: 8px;
            color: #374151;
        }

        .mobile-sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            z-index: 30;
        }

        @media (min-width: 1100px) {
            .view-stage-actions { flex-direction: column; }
            .toolbar-row { flex: 1; }
            .toolbar-row.secondary { justify-content: flex-end; }
        }

        @media (max-width: 640px) {
            .toolbar-row { flex-direction: column; align-items: stretch; }
            .toolbar-row.secondary { gap: 12px; }
            .toolbar-row .toolbar-group, .selection-group { width: 100%; justify-content: space-between; }
        }

        @media (max-width: 1024px) {
            body { padding-bottom: var(--mobile-bottom-bar-height); }
            .mobile-topbar { display: flex; }
            .mobile-bottom-bar { display: grid; }
            .mobile-fab { display: inline-flex; }
            .app-header { display: none; }
            .app-main { padding: 12px var(--mobile-padding); }
        }

        @media (max-width: 768px) {
            .toolbar-actions button,
            .toolbar-menu-toggle { min-height: 44px; }
            .grid-table-wrapper { overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 0 -16px; padding: 0 16px; }
            .grid-table { min-width: 720px; }
            .view-type-btn { padding: 10px 12px; }
        }

        @media (max-width: 1024px) {
            :root { --sidebar-width: 240px; }
            .app-container { grid-template-areas: "header" "main"; grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            .app-sidebar {
                position: fixed;
                inset: 0 auto 0 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 40;
            }
            .mobile-sidebar-overlay { display: none; }
            .mobile-layout.sidebar-open-mobile .app-sidebar { transform: translateX(0); box-shadow: 8px 0 24px rgba(0,0,0,0.18); }
            .mobile-layout.sidebar-open-mobile .mobile-sidebar-overlay { display: block; }
            .app-header { position: sticky; top: 0; z-index: 20; }
            .toolbar { flex-direction: column; align-items: stretch; gap: 12px; }
            .toolbar .view-type-switcher { width: 100%; overflow-x: auto; padding-bottom: 4px; }
            .toolbar-left { width: 100%; flex-direction: column; align-items: flex-start; }
            .toolbar-inline-actions { width: 100%; }
            .toolbar-actions { width: 100%; justify-content: space-between; }
            .primary-actions { flex: 1; }
            .toolbar-actions, .primary-actions { flex-wrap: wrap; }
            .toolbar-actions button { flex: 1 1 calc(50% - 8px); min-width: 140px; }
            .toolbar-menu { width: 100%; display: flex; justify-content: flex-end; }
            .toolbar-menu-panel { width: min(100%, 360px); }
            .cards-grid { grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
            .kanban-board { min-height: auto; }
        }

        @media (max-width: 640px) {
            .toolbar-actions button { flex: 1 1 100%; }
            .toolbar-menu-toggle { width: 100%; justify-content: center; }
            .cards-grid { grid-template-columns: 1fr; }
            .kanban-column { min-width: 260px; }
        }

        /* NEW NAVIGATION STYLES */
        .nav-item {
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            transition: all 0.15s ease;
            color: #d1d5db;
        }
        .nav-item:hover {
            background-color: #1C253D;
            color: white;
        }
        .nav-item.active {
            background-color: #1C253D;
            color: white;
            font-weight: 500;
        }

        .nav-section-title {
            padding: 0.75rem 1rem 0.5rem 1rem;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            color: #9ca3af;
            font-weight: 600;
        }

        .world-nav-parent {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            margin: 0 0.5rem;
            transition: background-color 0.15s ease;
            font-weight: 500;
        }
        .world-nav-parent:hover {
            background-color: transparent;
        }

        .world-nav-children {
            margin-left: 1rem;
            margin-top: 0.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* DASHBOARD/LANDING PAGE STYLES */
        .card {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            padding: 1rem;
        }

        .summary-card {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .summary-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        .summary-card-count {
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 2rem;
            color: var(--text);
        }
        .summary-card-title {
            color: #6b7280;
            margin-top: 0.5rem;
            font-size: 0.875rem;
        }

        .entity-type-card {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        .entity-type-card:hover {
            background-color: #f3f4f6;
        }
        .entity-type-card-label {
            font-size: 1.125rem;
            font-weight: 500;
            line-height: 1.75rem;
        }
        .entity-type-card-count {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2.5rem;
        }
        .dashboard-header h1 {
            font-size: 1.875rem;
            font-weight: 600;
            line-height: 2.25rem;
            margin: 0;
        }
        .dashboard-actions {
            display: flex;
            gap: 0.75rem;
        }

        .dashboard-section {
            margin-bottom: 2.5rem;
        }
        .dashboard-section h2 {
            font-size: 1.125rem;
            font-weight: 500;
            line-height: 1.75rem;
            margin: 0 0 0.75rem 0;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
        }

        .entity-type-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .discovery-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .discovery-card {
            padding: 1rem;
            background-color: white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .discovery-card-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        .discovery-card-description {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.75rem;
        }

        .recent-changes-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .recent-changes-list li {
            font-size: 0.875rem;
            color: #4b5563;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f3f4f6;
        }
        .recent-changes-list li:last-child {
            border-bottom: none;
        }

        @media (max-width: 1024px) {
            .summary-grid { grid-template-columns: repeat(2, 1fr); }
            .entity-type-grid { grid-template-columns: repeat(2, 1fr); }
            .discovery-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 640px) {
            .summary-grid { grid-template-columns: 1fr; }
            .entity-type-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="mobile-topbar" id="mobileTopbar">
        <button class="mobile-icon-btn" onclick="toggleSidebar()" aria-label="Toggle navigation">
            <i class="ph ph-list"></i>
        </button>
        <div class="mobile-topbar-title" id="mobileTopbarTitle">EO</div>
        <button class="mobile-icon-btn" onclick="triggerPrimaryAction()" aria-label="Add record">
            <i class="ph ph-plus"></i>
        </button>
    </div>

        <div class="app-container" id="appContainer">
        <!-- Sidebar -->
        <div class="app-sidebar">
            <!-- Brand Logo and Collapse Toggle -->
            <div class="sidebar-header-row" style="display: flex; align-items: center; justify-content: space-between; padding: 1rem;">
                <div class="sidebar-brand" style="font-weight: 700; letter-spacing: 0.05em; font-size: 1.125rem;">[EO]</div>
                <button class="sidebar-collapse-btn" onclick="toggleSidebar()" aria-label="Collapse sidebar" title="Collapse sidebar">
                    <i id="sidebarCollapseIcon" class="ph ph-caret-left"></i>
                </button>
            </div>

            <!-- Scrollable Content Area -->
            <div class="sidebar-content">
                <!-- WORLD Section -->
                <div class="nav-section-title" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('world')">
                    <span>World</span>
                    <i id="worldSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="worldNavContent">
                    <div class="world-nav-parent" id="worldNavParent">
                        <select id="worldSelect" class="world-select" onchange="switchWorld(this.value)">
                            <!-- Options populated by renderWorldSelector() -->
                        </select>
                    </div>
                    <div class="world-nav-children" style="padding: 0 1rem;">
                        <div class="nav-item" id="navDashboard" onclick="navigateTo('dashboard')">Dashboard</div>
                        <div class="nav-item" id="navEntities" onclick="navigateTo('entities')">Entities</div>
                        <div class="nav-item" id="navRelations" onclick="navigateTo('relations')">Relations</div>
                        <div class="nav-item" id="navDefinitions" onclick="navigateTo('definitions')">Definitions</div>
                        <div class="nav-item" id="navViews" onclick="navigateTo('views')">Views</div>
                    </div>
                </div>

                <!-- EXPLORE Section -->
                <div class="nav-section-title" style="margin-top: 1rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('explore')">
                    <span>Explore</span>
                    <i id="exploreSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="exploreNavContent">
                    <div class="world-nav-children" style="padding: 0 1rem;">
                        <div class="nav-item" id="navSearch" onclick="navigateTo('search')">Search & Discover</div>
                    </div>
                </div>

                <!-- RECENT IMPORTS Section -->
                <div class="nav-section-title" style="margin-top: 1rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('recentImports')">
                    <span>Recent Imports</span>
                    <i id="recentImportsSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="recentImportsNavContent">
                    <div id="navRecentImportsContainer" style="padding: 0 1rem; margin-bottom: 0.5rem;">
                        <!-- Recent imports will be populated here dynamically -->
                    </div>
                </div>

                <!-- SETS Section (dynamically populated) -->
                <div class="nav-section-title" style="margin-top: 1.5rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('sets')">
                    <span style="display: flex; align-items: center; gap: 8px;">
                        Sets
                        <i class="ph ph-plus" style="font-size: 14px; opacity: 0.7; cursor: pointer; padding: 2px; border-radius: 4px;" onclick="event.stopPropagation(); openAddSetModal();" onmouseover="this.style.opacity='1'; this.style.background='rgba(255,255,255,0.1)';" onmouseout="this.style.opacity='0.7'; this.style.background='transparent';" title="Add Set"></i>
                    </span>
                    <i id="setsSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="setsNavContent">
                    <div class="world-nav-children" style="padding: 0 1rem; margin-bottom: 0.5rem;">
                        <div style="position: relative; margin-bottom: 0.75rem;">
                            <input type="text" id="setsSearchInput" placeholder="Search sets and views..." style="width: 100%; padding: 6px 8px 6px 28px; background: #1e293b; border: 1px solid #334155; border-radius: 6px; color: white; font-size: 0.875rem; outline: none;" oninput="filterSets(this.value)">
                            <i class="ph ph-magnifying-glass" style="position: absolute; left: 8px; top: 50%; transform: translateY(-50%); font-size: 14px; opacity: 0.5;"></i>
                        </div>
                    </div>
                    <div id="navSetsContainer" style="padding: 0 1rem; margin-bottom: 0.5rem;"></div>
                    <div class="world-nav-children" style="padding: 0 1rem; margin-bottom: 1rem;">
                        <div class="nav-item" style="color: #6ee7b7;" onclick="handleAddViewClick()">+ Add View</div>
                    </div>
                </div>
            </div>

            <!-- Fixed Actions Section at Bottom -->
            <div class="sidebar-actions">
                <div class="nav-section-title" style="padding-top: 1rem; display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleNavSection('actions')">
                    <span>Actions</span>
                    <i id="actionsSectionChevron" class="ph ph-caret-down" style="font-size: 12px; opacity: 0.7;"></i>
                </div>
                <div id="actionsNavContent">
                    <div class="world-nav-children" style="padding: 0 1rem; margin-bottom: 1.5rem;">
                        <div class="nav-item" onclick="openCsvImportModal()">Import CSV</div>
                        <div class="nav-item" onclick="openAddRecordModal()">+ Add Record</div>
                        <div class="nav-item" onclick="openAddSetModal()">+ Add Set</div>
                        <div class="nav-item" onclick="openAddWorldModal()">+ Add World</div>
                        <div class="nav-item" onclick="importWorld()">Import World</div>
                        <div class="nav-item" onclick="exportWorld()">Export World</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mobile-sidebar-overlay" id="mobileSidebarOverlay" onclick="closeMobileSidebar()"></div>

        <!-- Header -->
        <div class="app-header">
            <div class="world-toolbar">
                <div class="world-toolbar-info">
                    <div class="world-pill">
                        <i class="ph ph-globe-hemisphere-west"></i>
                        <span id="currentWorldHeaderLabel">Loading world...</span>
                    </div>
                </div>
                <div class="world-toolbar-actions">
                    <button id="globalHistoryBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-clock-counter-clockwise"></i>
                        Global changes
                    </button>
                    <button id="viewWorldJsonBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-code"></i>
                        View JSON
                    </button>
                    <button id="importWorldBtn" class="btn btn-secondary btn-sm">
                        <i class="ph ph-upload-simple"></i>
                        Import world
                    </button>
                    <input type="file" id="worldJsonInput" accept="application/json" style="display:none" />
                    <button id="exportWorldBtn" class="btn btn-primary btn-sm">
                        <i class="ph ph-download-simple"></i>
                        Download world
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="app-main">
            <div class="view-workspace">
                <div class="view-tabs-rail">
                    <div id="viewTabs" class="view-tabs hidden"></div>
                </div>
                <div class="view-surface" id="viewSurface">
                    <div id="viewContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="mobile-bottom-bar" id="mobileBottomBar">
        <button class="mobile-bottom-action" data-mobile-nav="grid" onclick="switchViewType('grid')">
            <i class="ph ph-table"></i>
            <span>Grid</span>
        </button>
        <button class="mobile-bottom-action" data-mobile-nav="card" onclick="switchViewType('card')">
            <i class="ph ph-cards-three"></i>
            <span>Card</span>
        </button>
        <button class="mobile-bottom-action" data-mobile-nav="kanban" onclick="switchViewType('kanban')">
            <i class="ph ph-kanban"></i>
            <span>Kanban</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('filterBtn')?.click()">
            <i class="ph ph-funnel"></i>
            <span>Filter</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('sortBtn')?.click()">
            <i class="ph ph-arrows-down-up"></i>
            <span>Sort</span>
        </button>
        <button class="mobile-bottom-action" onclick="document.getElementById('visualizeBtn')?.click()">
            <i class="ph ph-chart-bar"></i>
            <span>Visualize</span>
        </button>
    </div>

    <button class="mobile-fab" id="mobileFab" onclick="triggerPrimaryAction()" aria-label="Quick add">
        <i class="ph ph-plus"></i>
    </button>

    <!-- All Modals from previous version -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Confirm Action</h2>
            </div>
            <div class="modal-body">
                <p class="text-gray-700" id="confirmMessage"></p>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="confirmCancelBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="definitionModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="definitionModalTitle">Add Definition</h2>
                    <p class="text-sm text-gray-500">Provide a definition for any entity type.</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeDefinitionModal()" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="definitionForm" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div>
                        <label class="form-label">Entity Type</label>
                        <select id="definitionEntityType" class="border rounded px-3 py-2 w-full">
                            <option value="">Select type</option>
                            <option value="Record">Record</option>
                            <option value="Field">Field</option>
                            <option value="Set">Set</option>
                            <option value="Connection">Connection</option>
                            <option value="ViewEntity">ViewEntity</option>
                        </select>
                    </div>
                    <div>
                        <label class="form-label">Entity ID</label>
                        <input id="definitionEntityId" type="text" class="border rounded px-3 py-2 w-full" placeholder="entity identifier" />
                    </div>
                    <div>
                        <label class="form-label">Term</label>
                        <input id="definitionTerm" type="text" class="border rounded px-3 py-2 w-full" placeholder="Human-readable term" />
                    </div>
                    <div>
                        <label class="form-label">Definition</label>
                        <input id="definitionDefinition" type="text" class="border rounded px-3 py-2 w-full" placeholder="What does this mean?" />
                    </div>
                    <div>
                        <label class="form-label">Notes</label>
                        <input id="definitionNotes" type="text" class="border rounded px-3 py-2 w-full" placeholder="Optional clarifications" />
                    </div>
                    <div>
                        <label class="form-label">Tags (comma separated)</label>
                        <input id="definitionTags" type="text" class="border rounded px-3 py-2 w-full" placeholder="demo, core" />
                    </div>
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeDefinitionModal()">Cancel</button>
                <button class="btn btn-primary" type="submit" form="definitionForm" id="definitionSubmit">Add Definition</button>
            </div>
        </div>
    </div>

    <div id="connectionRelationModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="connectionRelationModalTitle">Add Relation Type</h2>
                    <p class="text-sm text-gray-500">Define a reusable relation like "is linked to"</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeModal('connectionRelationModal')" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="connectionRelationForm" class="space-y-4">
                    <div>
                        <label class="form-label">Category</label>
                        <select id="connectionRelationOperator" class="border rounded px-3 py-2 w-full">
                            <option value="">Select category</option>
                        </select>
                        <p class="text-xs text-gray-500 mt-1">Type of relation (CON = connection, SEG = segmentation, etc.)</p>
                    </div>
                    <div>
                        <label class="form-label">Relation verb</label>
                        <select id="connectionRelationMode" class="border rounded px-3 py-2 w-full"></select>
                        <p class="text-xs text-gray-500 mt-1">How the subject relates to the object</p>
                    </div>
                    <div>
                        <label class="form-label">Description (optional)</label>
                        <input id="connectionRelationDescription" type="text" class="border rounded px-3 py-2 w-full" placeholder="When to use this relation" />
                    </div>
                    <input id="connectionRelationName" type="hidden" value="" />
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeModal('connectionRelationModal')">Cancel</button>
                <button class="btn btn-primary" type="submit" form="connectionRelationForm" id="connectionRelationSubmit">Add</button>
            </div>
        </div>
    </div>

    <div id="connectionModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-lg">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="connectionModalTitle">Add Relationship</h2>
                    <p class="text-sm text-gray-500">Connect two things with a relation</p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeModal('connectionModal')" aria-label="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <form id="connectionForm" class="space-y-4">
                    <div>
                        <label class="form-label">Subject</label>
                        <div class="flex gap-2">
                            <select id="connectionSubjectType" class="border rounded px-3 py-2 w-32">
                                <option value="Record">Record</option>
                                <option value="Field">Field</option>
                                <option value="Set">Set</option>
                            </select>
                            <input id="connectionSubjectId" type="text" class="border rounded px-3 py-2 flex-1" placeholder="Select or enter ID" />
                        </div>
                    </div>
                    <div>
                        <label class="form-label">Relation</label>
                        <select id="connectionRelationSelect" class="border rounded px-3 py-2 w-full">
                            <option value="">Select a relation</option>
                        </select>
                        <div class="text-xs text-gray-500 mt-1" id="connectionRelationSummary"></div>
                    </div>
                    <div>
                        <label class="form-label">Object</label>
                        <div class="flex gap-2">
                            <select id="connectionOperandType" class="border rounded px-3 py-2 w-32">
                                <option value="Record">Record</option>
                                <option value="Field">Field</option>
                                <option value="Set">Set</option>
                            </select>
                            <input id="connectionOperandId" type="text" class="border rounded px-3 py-2 flex-1" placeholder="Select or enter ID" />
                        </div>
                    </div>
                    <div>
                        <label class="form-label">Description (optional)</label>
                        <input id="connectionDescription" type="text" class="border rounded px-3 py-2 w-full" placeholder="What does this relationship represent?" />
                    </div>
                    <div id="connectionParamFields" class="hidden"></div>
                </form>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button class="btn btn-secondary" type="button" onclick="closeModal('connectionModal')">Cancel</button>
                <button class="btn btn-primary" type="submit" form="connectionForm" id="connectionSubmit">Add</button>
            </div>
        </div>
    </div>

    <div id="expandedRecordModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between flex-shrink-0">
                <div class="flex items-center gap-4 flex-1">
                    <h2 class="text-2xl font-bold text-gray-900" id="expandedRecordTitle">Record Details</h2>
                    <div class="profile-selector" id="recordProfileSelector"></div>
                </div>
                <div class="flex items-center gap-2">
                    <button id="toggleHistorySidebarBtn" class="btn btn-secondary btn-sm">Hide History</button>
                    <button id="closeExpandedRecordBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex-1 overflow-hidden">
                <div class="grid grid-cols-1 md:grid-cols-3 h-full">
                    <div id="expandedRecordMainWrapper" class="md:col-span-2 p-6 overflow-y-auto border-r border-gray-200">
                        <div id="expandedRecordMain"></div>
                    </div>
                    <div id="expandedRecordHistoryColumn" class="overflow-hidden bg-gray-50 flex flex-col">
                        <div class="record-tabs">
                            <div class="record-tab active" data-tab="history" onclick="switchRecordTab('history')">History</div>
                            <div class="record-tab" data-tab="provenance" onclick="switchRecordTab('provenance')">Provenance</div>
                            <div class="record-tab" data-tab="connections" onclick="switchRecordTab('connections')">Relationships</div>
                        </div>
                        <div class="flex-1 overflow-y-auto p-6" id="expandedRecordSidebar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="filterModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Filter View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create advanced filter conditions</p>
                </div>
                <button id="closeFilterBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <div id="filterGroupsContainer"></div>
                <button id="addFilterGroupBtn" class="btn btn-secondary btn-sm mt-4">+ Add Filter Group</button>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="clearFiltersBtn" class="btn btn-secondary">Clear All</button>
                <button id="applyFiltersBtn" class="btn btn-primary">Apply Filters</button>
            </div>
        </div>
    </div>

    <div id="sortModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[80vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Sort View</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a sorting sequence for this view</p>
                </div>
                <button id="closeSortBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-3">
                <div id="sortRulesContainer" class="space-y-3"></div>
                <button id="addSortRuleBtn" class="btn btn-secondary btn-sm">+ Add Sort</button>
            </div>
            <div class="modal-footer flex justify-between gap-2">
                <div class="flex items-center gap-2 text-sm text-gray-500">
                    <span class="sort-sequence-badge"><i class="ph ph-arrow-line-up"></i>Earlier sorts run first</span>
                </div>
                <div class="flex gap-2">
                    <button id="clearSortsBtn" class="btn btn-secondary">Clear All</button>
                    <button id="applySortsBtn" class="btn btn-primary">Apply Sorts</button>
                </div>
            </div>
        </div>
    </div>

    <div id="visualizationModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Visualize Data</h2>
                    <p class="text-sm text-gray-500 mt-1">Create interactive charts from your data</p>
                </div>
                <button id="closeVisualizationBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-semibold mb-2">Chart Type</label>
                        <div class="flex gap-2 flex-wrap">
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="bar">
                                <i class="ph ph-chart-bar"></i>
                                Bar Chart
                            </button>
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="line">
                                <i class="ph ph-chart-line"></i>
                                Line Chart
                            </button>
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="pie">
                                <i class="ph ph-chart-pie-slice"></i>
                                Pie Chart
                            </button>
                            <button class="btn btn-secondary btn-sm viz-chart-type-btn" data-chart-type="area">
                                <i class="ph ph-chart-line-up"></i>
                                Area Chart
                            </button>
                        </div>
                    </div>
                    <div id="visualizationChartContainer" class="border border-gray-200 rounded-lg bg-white p-6 min-h-[400px]">
                        <div class="text-center text-gray-500 py-12">
                            Select a chart type to visualize your data
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="closeVisualizationModalBtn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <div id="popupSettingsModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white popup-config-shell">
            <div class="popup-config-header">
                <div>
                    <h2 class="text-2xl font-bold text-gray-900">Modal Configuration</h2>
                    <p class="text-sm text-gray-600 mt-1">Curate which fields show in record modals, define conditional visibility, and preview layouts.</p>
                </div>
                <div class="flex items-center gap-2">
                    <button class="btn btn-secondary btn-sm" onclick="resetPopupLayout()">Reset</button>
                    <button id="closePopupSettingsBtn" class="btn btn-secondary btn-sm">Close</button>
                </div>
            </div>

            <div class="popup-config-tabs">
                <button class="popup-config-tab active" data-tab="popupFields" onclick="setPopupTab('popupFields')"> Fields <span class="popup-badge" id="popupFieldCountBadge">0</span></button>
                <button class="popup-config-tab" data-tab="popupLayout" onclick="setPopupTab('popupLayout')"> Layout</button>
                <button class="popup-config-tab" data-tab="popupConditions" onclick="setPopupTab('popupConditions')"> Conditions</button>
            </div>

            <div class="popup-config-body">
                <div class="popup-tab-panel active" id="popupFields">
                    <div class="popup-panel-scroll">
                        <div class="popup-quick-filters" id="popupFilters"></div>
                        <div class="popup-info"><span></span><span><strong>Drag to reorder</strong> and toggle visibility. Click the gear to set conditional rules per field.</span></div>
                        <div id="popupFieldList"></div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupLayout">
                    <div class="popup-panel-scroll space-y-4">
                        <div class="popup-card">
                            <h4>Modal Size</h4>
                            <div class="popup-layout-options" id="popupSizeOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Column Layout</h4>
                            <div class="popup-layout-options" id="popupColumnOptions"></div>
                        </div>
                        <div class="popup-card">
                            <h4>Preview</h4>
                            <div id="popupPreview" class="popup-preview"></div>
                        </div>
                    </div>
                </div>

                <div class="popup-tab-panel" id="popupConditions">
                    <div class="popup-panel-scroll">
                        <div class="popup-info"><span></span><span><strong>Conditional visibility</strong> lets you keep modals focused and contextual.</span></div>
                        <div id="popupConditionsList" class="popup-conditions"></div>
                    </div>
                </div>

                <div class="popup-side">
                    <div class="popup-card">
                        <h4>Quick Stats</h4>
                        <div class="popup-stat-grid">
                            <div class="popup-stat">
                                <div class="value" id="popupVisibleCount">0</div>
                                <div class="label">Visible Fields</div>
                            </div>
                            <div class="popup-stat">
                                <div class="value" id="popupConditionalCount">0</div>
                                <div class="label">Conditional Rules</div>
                            </div>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Templates</h4>
                        <div class="popup-template-buttons">
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('minimal')"> Minimal View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('detailed')"> Detailed View</button>
                            <button class="btn btn-secondary btn-sm" onclick="applyPopupTemplate('compact')"> Compact View</button>
                        </div>
                    </div>
                    <div class="popup-card">
                        <h4>Recent Changes</h4>
                        <div id="popupRecentChanges" class="text-sm text-gray-600 space-y-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="addFieldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Add Field</h2>
                    <p class="text-sm text-gray-500 mt-1">Create a new field for your set</p>
                </div>
                <button id="closeAddFieldBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                  <div>
                      <label class="form-label">Field Name</label>
                      <input type="text" id="newFieldName" placeholder="e.g., Status, Amount, Contact Person" autofocus aria-describedby="fieldNameError">
                      <p class="form-hint">A descriptive name for your field</p>
                      <p id="fieldNameError" class="form-error hidden" role="alert"></p>
                  </div>
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="fieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="selectedFieldTypeName"></div>
                                    <div class="field-type-description" id="selectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="fieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="newFieldType" value="TEXT">
                </div>
                <div id="selectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="selectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="addSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="acceptNewOptions" checked class="mr-2">
                            <label for="acceptNewOptions" class="text-sm text-gray-700">Accept new options</label>
                        </div>
                    </div>
                </div>
                <div id="linkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <select id="linkToSet"></select>
                        <p class="form-hint">Select which set to link to</p>
                    </div>
                </div>
                <div id="formulaConfig" class="config-section">
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="relative">
                            <textarea id="formulaInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm" rows="4" placeholder="e.g., {Price} * {Quantity}"></textarea>
                            <div id="formulaAutocomplete" class="absolute z-10 hidden bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto" style="width: calc(100% - 2rem);"></div>
                        </div>
                        <p class="form-hint mt-2">Use {Field Name} to reference other fields. Available functions: SUM, AVG, MIN, MAX, IF, CONCAT, ROUND, etc.</p>
                        <div id="formulaValidation" class="mt-2 text-sm"></div>
                        <div class="mt-3">
                            <label class="form-label">Display Format</label>
                            <select id="formulaFormat" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                <option value="number">Number</option>
                                <option value="currency">Currency</option>
                                <option value="percentage">Percentage</option>
                                <option value="text">Text</option>
                            </select>
                        </div>
                        <div class="mt-3">
                            <label class="form-label">Decimal Places</label>
                            <input type="number" id="formulaDecimals" class="w-full px-3 py-2 border border-gray-300 rounded-lg" min="0" max="10" value="2">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddFieldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddFieldBtn" class="btn btn-primary">Add Field</button>
            </div>
        </div>
    </div>

    <div id="changeFieldTypeModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Change Field Type</h2>
                    <p class="text-sm text-gray-500 mt-1">Update the type for <span id="changeFieldName" class="font-medium text-gray-900"></span></p>
                    <p id="changeFieldTypeSummary" class="text-xs text-gray-500 mt-1"></p>
                </div>
                <button id="closeChangeFieldTypeBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-5">
                <div>
                    <label class="form-label">Field Type</label>
                    <div class="field-type-select">
                        <button type="button" id="changeFieldTypeTrigger" class="field-type-trigger">
                            <div class="field-type-trigger-content">
                                <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                <div class="field-type-trigger-text">
                                    <div class="field-type-name" id="changeSelectedFieldTypeName"></div>
                                    <div class="field-type-description" id="changeSelectedFieldTypeDescription"></div>
                                </div>
                            </div>
                            <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                        </button>
                        <div id="changeFieldTypeDropdown" class="field-type-dropdown hidden"></div>
                    </div>
                    <input type="hidden" id="changeFieldTypeInput" value="TEXT">
                </div>
                <div id="changeFieldSubtypeConfig" class="config-section"></div>
                <div id="changeSelectConfig" class="config-section">
                    <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                        <label class="form-label">Options</label>
                        <div id="changeSelectOptionsList" class="space-y-2 mb-3"></div>
                        <button onclick="changeAddSelectOption()" class="btn btn-secondary btn-sm">+ Add Option</button>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="changeAcceptNewOptions" checked class="mr-2">
                            <label for="changeAcceptNewOptions" class="text-sm text-gray-700">Accept new options</label>
                        </div>
                    </div>
                </div>
                <div id="changeLinkToRecordConfig" class="config-section">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <label class="form-label">Link to Set</label>
                        <select id="changeLinkToSet"></select>
                        <p class="form-hint">Select which set to link to</p>
                    </div>
                </div>
                <div id="changeFormulaConfig" class="config-section">
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                        <label class="form-label">Formula</label>
                        <div class="relative">
                            <textarea id="changeFormulaInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm" rows="4" placeholder="e.g., {Price} * {Quantity}"></textarea>
                            <div id="changeFormulaAutocomplete" class="absolute z-10 hidden bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto" style="width: calc(100% - 2rem);"></div>
                        </div>
                        <p class="form-hint mt-2">Use {Field Name} to reference other fields. Available functions: SUM, AVG, MIN, MAX, IF, CONCAT, ROUND, etc.</p>
                        <div id="changeFormulaValidation" class="mt-2 text-sm"></div>
                        <div class="mt-3">
                            <label class="form-label">Display Format</label>
                            <select id="changeFormulaFormat" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                <option value="number">Number</option>
                                <option value="currency">Currency</option>
                                <option value="percentage">Percentage</option>
                                <option value="text">Text</option>
                            </select>
                        </div>
                        <div class="mt-3">
                            <label class="form-label">Decimal Places</label>
                            <input type="number" id="changeFormulaDecimals" class="w-full px-3 py-2 border border-gray-300 rounded-lg" min="0" max="10" value="2">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelChangeFieldTypeBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveChangeFieldTypeBtn" class="btn btn-primary">Update Type</button>
            </div>
        </div>
    </div>

    <div id="addWorldModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Create World</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">World Name</label>
                    <input type="text" id="newWorldName" placeholder="e.g., Workspace Alpha">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddWorldBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddWorldBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addSetModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 id="addSetModalTitle" class="text-xl font-bold text-gray-900">Create Set</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">World</label>
                    <select id="newSetWorld"></select>
                </div>
                <div>
                    <label class="form-label">Set Name</label>
                    <input type="text" id="newSetName" placeholder="e.g., Projects, Contacts">
                </div>
                <div>
                    <label class="form-label">Icon</label>
                    <div id="newSetIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newSetIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Pick a visual icon</div>
                            <div id="newSetIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newSetIcon" value="ph-squares-four">
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddSetBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddSetBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="addRecordModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Add Record</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Select View</label>
                    <select id="addRecordViewSelect" class="w-full"></select>
                    <p class="form-hint">Choose which view to add the record to. The record will be structured based on the view's fields.</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddRecordBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddRecordBtn" class="btn btn-primary">Create Record</button>
            </div>
        </div>
    </div>

    <div id="addViewModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-xl">
            <div class="modal-header">
                <h2 id="addViewModalTitle" class="text-xl font-bold text-gray-900">Create View</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">View Name</label>
                    <input type="text" id="newViewName" placeholder="e.g., Active Items">
                </div>
                <div>
                    <label class="form-label">View Icon</label>
                    <div id="newViewIconSelector" class="icon-selector" role="button" tabindex="0">
                        <div id="newViewIconPreview" class="icon-selector-icon" aria-hidden="true"></div>
                        <div class="icon-selector-text">
                            <div class="icon-selector-label">Choose an icon visually</div>
                            <div id="newViewIconToken" class="icon-selector-token"></div>
                        </div>
                        <span class="icon-selector-chevron"></span>
                    </div>
                    <input type="hidden" id="newViewIcon" value="ph-table">
                </div>
                <div>
                    <label class="form-label">View Type</label>
                    <div class="grid grid-cols-2 gap-2">
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="grid" checked>
                            <div class="view-type-option-content">
                                <i class="ph ph-table"></i>
                                <span>Table</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="card">
                            <div class="view-type-option-content">
                                <i class="ph ph-cards-three"></i>
                                <span>Cards</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="kanban">
                            <div class="view-type-option-content">
                                <i class="ph ph-kanban"></i>
                                <span>Kanban</span>
                            </div>
                        </label>
                        <label class="view-type-option">
                            <input type="radio" name="newViewType" value="graph">
                            <div class="view-type-option-content">
                                <i class="ph ph-graph"></i>
                                <span>Graph</span>
                            </div>
                        </label>
                    </div>
                </div>
                <div>
                    <label class="form-label">Nest Under</label>
                    <select id="newViewParent"></select>
                    <p class="form-hint">Optionally place this view under another view</p>
                </div>
                <div>
                    <label class="form-label">How do you want to start?</label>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="viewCreationMode" value="blank" checked>
                            Blank View
                        </label>
                        <label class="flex items-start gap-2 font-medium">
                            <input type="radio" name="viewCreationMode" value="key">
                            <div class="flex-1">
                                <div>Create From Key</div>
                                <div class="mt-2">
                                    <select id="keyCandidateSelect" class="w-full" disabled>
                                        <option value="">Scanning for identity properties</option>
                                    </select>
                                    <p class="form-hint">We look for reused identifiers, links, and fuzzy matches to seed the shape.</p>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelAddViewBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveAddViewBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="iconPickerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl icon-picker-shell">
            <div class="modal-header flex items-center justify-between">
                <h2 class="text-xl font-bold text-gray-900">Pick an icon</h2>
                <button id="closeIconPickerBtn" class="btn btn-secondary btn-sm">Close</button>
            </div>
            <div class="modal-body space-y-4 icon-picker-body">
                <div class="icon-picker-controls">
                    <input type="text" id="iconPickerSearch" placeholder="Search icons (e.g., table, folder)" class="w-full icon-picker-search">
                    <div id="iconPickerPagination" class="icon-pagination"></div>
                </div>
                <div id="iconPickerOptions" class="icon-picker-grid"></div>
            </div>
        </div>
    </div>

    <div id="kanbanConfigModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-md">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Configure Kanban</h2>
            </div>
            <div class="modal-body space-y-4">
                <div>
                    <label class="form-label">Group By Field</label>
                    <select id="kanbanGroupField"></select>
                    <p class="form-hint">Select a single-select field to group records by</p>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelKanbanConfigBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveKanbanConfigBtn" class="btn btn-primary">Apply</button>
            </div>
        </div>
    </div>

    <div id="csvImportModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Import CSV</h2>
                    <p class="text-sm text-gray-500 mt-1">Choose a destination set before uploading, then map columns and preview fuzzy matches.</p>
                </div>
                <button id="closeCsvImportBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Destination</h3>
                            <p class="text-sm text-gray-500">Pick an existing set or create a new one before selecting a file.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="csvImportTargetMode" value="existing" checked>
                            Import into existing set
                        </label>
                        <div id="csvExistingSetPicker" class="pl-7 space-y-2">
                            <select id="csvTargetSetSelect"></select>
                            <p class="text-xs text-gray-500">We'll map columns to the selected set's fields.</p>
                        </div>
                        <label class="flex items-center gap-2 font-medium">
                            <input type="radio" name="csvImportTargetMode" value="new">
                            Create a new set from this CSV
                        </label>
                        <div id="csvNewSetFields" class="pl-7 space-y-2 hidden">
                            <input type="text" id="csvNewSetName" placeholder="e.g., Leads" class="w-full">
                            <p class="text-xs text-gray-500">We'll create fields from your headers automatically.</p>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-grid">
                    <div class="csv-helper-card">
                        <label class="form-label">Upload CSV File</label>
                        <input type="file" id="csvFileInput" accept=".csv" />
                        <p class="form-hint">Headers are required. We will auto-map matching field names.</p>
                    </div>
                    <div class="csv-helper-card">
                        <label class="form-label">Or Paste CSV Text</label>
                        <textarea id="csvTextInput" rows="5" placeholder="name,industry\nAcme,Technology"></textarea>
                        <div class="mt-2 flex justify-end">
                            <button id="parseCsvTextBtn" class="btn btn-secondary btn-sm">Preview CSV</button>
                        </div>
                    </div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Field Mapping</h3>
                            <p class="text-sm text-gray-500">Match CSV columns to fields in the current set.</p>
                        </div>
                        <span class="csv-match-pill" id="csvRowCountBadge">0 rows</span>
                    </div>
                    <div id="csvMappingContainer" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Preview</h3>
                            <p class="text-sm text-gray-500">First few records with applied mapping.</p>
                        </div>
                        <button id="refreshCsvPreviewBtn" class="btn btn-secondary btn-sm">Refresh Preview</button>
                    </div>
                    <div id="csvPreviewContainer" class="overflow-auto"></div>
                </div>

                <div class="csv-helper-card">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <h3 class="text-lg font-semibold">Fuzzy Match Suggestions</h3>
                            <p class="text-sm text-gray-500">We surface potential duplicates against existing records.</p>
                        </div>
                        <div class="text-xs text-gray-500">Score  0.6 shown</div>
                    </div>
                    <div id="csvMatchSuggestions" class="space-y-2"></div>
                </div>

                <div class="csv-helper-card border-blue-200 bg-blue-50/30">
                    <div class="flex items-center justify-between mb-3">
                        <div>
                            <h3 class="text-lg font-semibold flex items-center gap-2">
                                <span>Import Notes</span>
                                <span class="text-xs font-normal text-gray-500">(Optional)</span>
                            </h3>
                            <p class="text-sm text-gray-500">Add context about this data import for audit trail.</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="text-xs font-medium text-gray-700 block mb-1">Source System</label>
                                <input type="text" id="csvProvenanceSource" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., Salesforce, Excel">
                            </div>
                            <div>
                                <label class="text-xs font-medium text-gray-700 block mb-1">Data Type</label>
                                <input type="text" id="csvProvenanceDataType" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., Leads, Contacts">
                            </div>
                        </div>
                        <div>
                            <label class="text-xs font-medium text-gray-700 block mb-1">Notes</label>
                            <textarea id="csvProvenanceNotes" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" rows="2" placeholder="Any additional context about this import..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end gap-2">
                <button id="cancelCsvImportBtn" class="btn btn-secondary">Cancel</button>
                <button id="runCsvImportBtn" class="btn btn-primary">Import Records</button>
            </div>
        </div>
    </div>

    <!-- Provenance Review Modal (Tier 2 & 3) -->
    <div id="provenanceReviewModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Review Import Details</h2>
                    <p class="text-sm text-gray-500 mt-1">We've automatically detected information about your file. Review and edit if needed.</p>
                </div>
                <button id="closeProvenanceReviewBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-4">
                <!-- Filename Display -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                    <div class="text-sm font-medium text-gray-700">File:</div>
                    <div class="text-base font-mono" id="provenanceFilename"></div>
                </div>

                <!-- Tier 2: High Confidence Inferences -->
                <div class="border border-green-200 rounded-lg bg-green-50/50 p-4">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="w-2 h-2 rounded-full bg-green-500"></span>
                        <h3 class="text-base font-semibold text-gray-900">Auto-Detected Information</h3>
                        <span class="text-xs text-gray-500">(click to edit)</span>
                    </div>

                    <div class="space-y-3">
                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Source System:</label>
                            <input type="text" id="provenanceSourceSystem" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="Auto-detected">
                            <span class="text-xs text-gray-500" id="provenanceSourceSystemConfidence"></span>
                        </div>

                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Data Type:</label>
                            <input type="text" id="provenanceDataType" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="Auto-detected">
                        </div>

                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Method:</label>
                            <select id="provenanceMethod" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm">
                                <option value="measured">Measured (system)</option>
                                <option value="declared">Declared (manual)</option>
                                <option value="derived">Derived (calculated)</option>
                                <option value="aggregated">Aggregated</option>
                                <option value="inferred">Inferred</option>
                            </select>
                        </div>

                        <div class="flex items-center gap-3">
                            <label class="w-36 text-sm font-medium text-gray-700">Timeframe:</label>
                            <div class="flex-1 flex items-center gap-2">
                                <input type="text" id="provenanceTimeframeStart" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="Start date">
                                <span class="text-gray-400">to</span>
                                <input type="text" id="provenanceTimeframeEnd" class="flex-1 px-3 py-1.5 border border-gray-300 rounded-md text-sm" placeholder="End date">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tier 2: Medium Confidence (please verify) -->
                <div class="border border-amber-200 rounded-lg bg-amber-50/50 p-4">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="w-2 h-2 rounded-full bg-amber-500"></span>
                        <h3 class="text-base font-semibold text-gray-900">Additional Settings</h3>
                        <span class="text-xs text-gray-500">(please verify)</span>
                    </div>

                    <div class="space-y-3">
                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Compliance Standard:</label>
                            <div class="space-y-2 pl-3">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="us_gaap">
                                    <span class="text-sm">US GAAP</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="ifrs">
                                    <span class="text-sm">IFRS</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="sox">
                                    <span class="text-sm">SOX</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="internal">
                                    <span class="text-sm">Internal / Custom</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceJurisdiction" value="auto" checked>
                                    <span class="text-sm">Auto (use column hints)</span>
                                </label>
                            </div>
                        </div>

                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Organizational Scale:</label>
                            <div class="space-y-2 pl-3">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="individual">
                                    <span class="text-sm">Individual</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="team" checked>
                                    <span class="text-sm">Team</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="department">
                                    <span class="text-sm">Department</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceScale" value="organization">
                                    <span class="text-sm">Organization</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tier 3: Epistemic Context (Optional but Recommended) -->
                <div class="border border-blue-200 rounded-lg bg-blue-50/50 p-4">
                    <div class="flex items-center gap-2 mb-3">
                        <span class="text-blue-600"></span>
                        <h3 class="text-base font-semibold text-gray-900">Data Quality & Classification</h3>
                        <span class="text-xs text-gray-500">(optional but recommended)</span>
                    </div>

                    <div class="space-y-3">
                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Data Category:</label>
                            <div class="text-xs text-gray-500 mb-2">What type of data is this?</div>
                            <select id="provenanceFrame" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                                <option value="">None specified</option>
                                <option value="financial_reporting">Financial Reporting (GAAP/IFRS)</option>
                                <option value="operational">Operational Metrics</option>
                                <option value="sales_metrics">Sales & Revenue</option>
                                <option value="product_analytics">Product Analytics</option>
                                <option value="scientific">Scientific/Research</option>
                                <option value="legal_compliance">Legal/Compliance</option>
                                <option value="hr">Human Resources</option>
                                <option value="custom">Custom (specify below)</option>
                            </select>
                            <input type="text" id="provenanceFrameCustom" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm mt-2 hidden" placeholder="Specify custom frame">
                        </div>

                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Data Owner:</label>
                            <div class="text-xs text-gray-500 mb-2">Who is responsible for this data?</div>
                            <input type="text" id="provenanceAuthority" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm" placeholder="e.g., CFO - Finance Department">
                        </div>

                        <div>
                            <label class="text-sm font-medium text-gray-700 block mb-2">Trust Level:</label>
                            <div class="space-y-2 pl-3">
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceTrustLevel" value="authoritative" checked>
                                    <span class="text-sm">Authoritative (official record)</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceTrustLevel" value="provisional">
                                    <span class="text-sm">Provisional (draft/estimate)</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="provenanceTrustLevel" value="exploratory">
                                    <span class="text-sm">Exploratory (analysis/sandbox)</span>
                                </label>
                            </div>
                        </div>

                        <!-- External System Linkage -->
                        <div id="provenanceExternalLinksContainer" class="hidden">
                            <label class="text-sm font-medium text-gray-700 block mb-2">External System Link:</label>
                            <div class="bg-white border border-blue-200 rounded-md p-3">
                                <div class="flex items-center gap-2 mb-2">
                                    <span class="text-blue-600"></span>
                                    <span class="text-sm font-medium" id="provenanceExternalLinkText">Detected ID column</span>
                                </div>
                                <label class="flex items-center gap-2 text-sm">
                                    <input type="checkbox" id="provenanceEnableExternalLink">
                                    <span>Link to external system</span>
                                </label>
                                <input type="text" id="provenanceExternalLinkUrl" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm mt-2 hidden" placeholder="Base URL (e.g., https://mycompany.salesforce.com)">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Summary of Detections -->
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                    <div class="text-xs font-medium text-gray-700 mb-2">Detection Summary:</div>
                    <div id="provenanceSummary" class="text-xs text-gray-600 space-y-1"></div>
                </div>
            </div>
            <div class="modal-footer flex justify-between items-center gap-2">
                <button id="skipProvenanceBtn" class="btn btn-secondary">Skip - Use Defaults</button>
                <button id="continueToMappingBtn" class="btn btn-primary">Continue to Column Mapping </button>
            </div>
        </div>
    </div>

    <div id="columnRulesModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Column Rules</h2>
                    <p class="text-sm text-gray-500 mt-1">Pick how we resolve multiple observations per property.</p>
                </div>
                <button id="closeColumnRulesBtn" class="text-gray-400 hover:text-gray-600 transition p-2 rounded-lg hover:bg-gray-50">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body space-y-6">
                <!-- Columns Visibility Section -->
                <div class="border border-gray-200 rounded-xl bg-gradient-to-br from-white to-gray-50/50 p-4 hover:border-gray-300 transition-all">
                    <div class="flex items-start gap-3">
                        <div class="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-50 border border-blue-100 flex items-center justify-center">
                            <i class="ph ph-columns text-blue-600 text-xl"></i>
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="text-sm font-semibold text-gray-900 mb-1">Columns</div>
                            <div class="text-xs text-gray-500 mb-3">Toggle view-only columns like Row Numbers and Record ID.</div>
                            <div class="flex flex-wrap gap-4">
                                <label class="flex items-center gap-2 cursor-pointer select-none group">
                                    <span class="text-sm text-gray-700 font-medium">Row #</span>
                                    <div id="rowNumbersToggle" class="popup-toggle">
                                        <input id="rowNumbersVisibilityToggle" type="checkbox" class="hidden">
                                    </div>
                                </label>
                                <label class="flex items-center gap-2 cursor-pointer select-none group">
                                    <span class="text-sm text-gray-700 font-medium">Record ID</span>
                                    <div id="recordIdToggle" class="popup-toggle">
                                        <input id="recordIdVisibilityToggle" type="checkbox" class="hidden">
                                    </div>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Property Selection Section -->
                <div>
                    <label class="form-label flex items-center gap-2">
                        <i class="ph ph-tag text-gray-400"></i>
                        Property
                    </label>
                    <select id="columnRulesFieldSelect" class="w-full"></select>
                </div>

                <!-- Rule Selection Section -->
                <div>
                    <label class="form-label flex items-center gap-2">
                        <i class="ph ph-funnel text-gray-400"></i>
                        Rule
                    </label>
                    <select id="columnRulesRuleSelect" class="w-full">
                        <option value="sup_all">Show all (Multiple Observations)</option>
                        <option value="prefer_newest">Prefer newest</option>
                        <option value="prefer_oldest">Prefer oldest</option>
                        <option value="prefer_set">Prefer value from set</option>
                        <option value="average_numeric">Average numeric</option>
                        <option value="median_numeric">Median numeric</option>
                        <option value="concat_text">Concatenate text</option>
                        <option value="first_non_null">First non-null</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-2">Choose how to handle multiple values for the same property.</p>
                </div>

                <!-- Preferred Set Section (conditional) -->
                <div id="columnRulesSetPicker" class="hidden">
                    <label class="form-label flex items-center gap-2">
                        <i class="ph ph-stack text-gray-400"></i>
                        Preferred Set
                    </label>
                    <select id="columnRulesPreferredSet" class="w-full"></select>
                </div>

                <!-- Rule Summary -->
                <div class="rounded-xl border-2 border-blue-100 bg-blue-50/50 p-4 flex items-start gap-3" id="columnRulesSummaryContainer">
                    <div class="flex-shrink-0 w-8 h-8 rounded-lg bg-blue-100 border border-blue-200 flex items-center justify-center">
                        <i class="ph ph-check-circle text-blue-600"></i>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="text-xs font-semibold text-blue-900 uppercase tracking-wide mb-1">Current Rule</div>
                        <div id="columnRulesSummary" class="text-sm font-medium text-gray-900"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-between items-center gap-3">
                <button id="deleteColumnRuleBtn" class="btn btn-danger flex items-center gap-2">
                    <i class="ph ph-trash text-sm"></i>
                    Clear Rule
                </button>
                <button id="saveColumnRuleBtn" class="btn btn-primary flex items-center gap-2">
                    <i class="ph ph-check text-sm"></i>
                    Save Rule
                </button>
            </div>
        </div>
    </div>

    <!-- Field Manager Modal -->
    <div id="fieldManagerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">Field Manager</h2>
                    <p class="text-sm text-gray-500 mt-1">Manage schema fields: add, remove, rename, reorder, and change types</p>
                </div>
                <button id="closeFieldManagerBtn" class="text-gray-400 hover:text-gray-600 transition p-2 rounded-lg hover:bg-gray-50">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto modal-body">
                <!-- Field List -->
                <div class="space-y-2 mb-4" id="fieldManagerList"></div>

                <!-- Add Field Section -->
                <div class="border-t border-gray-200 pt-4 mt-4">
                    <button id="addFieldTriggerBtn" class="btn btn-primary w-full flex items-center justify-center gap-2">
                        <i class="ph ph-plus-circle"></i>
                        Add New Field
                    </button>

                    <!-- Add Field Form (initially hidden) -->
                    <div id="addFieldForm" class="hidden mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200 space-y-4">
                        <div>
                            <label class="form-label">Field Name</label>
                            <input type="text" id="fieldManagerNewName" class="w-full" placeholder="e.g., Email Address">
                        </div>
                        <div>
                            <label class="form-label">Field Type</label>
                            <div class="field-type-select">
                                <button type="button" id="fieldManagerTypeTrigger" class="field-type-trigger">
                                    <div class="field-type-trigger-content">
                                        <span class="field-type-trigger-icon" aria-hidden="true"></span>
                                        <div class="field-type-trigger-text">
                                            <div class="field-type-name" id="fieldManagerSelectedTypeName"></div>
                                            <div class="field-type-description" id="fieldManagerSelectedTypeDescription"></div>
                                        </div>
                                    </div>
                                    <span class="field-type-trigger-arrow" aria-hidden="true"></span>
                                </button>
                                <div id="fieldManagerTypeDropdown" class="field-type-dropdown hidden"></div>
                            </div>
                            <input type="hidden" id="fieldManagerNewType" value="TEXT">
                        </div>
                        <!-- Type-specific config containers -->
                        <div id="fieldManagerSelectConfig" class="config-section">
                            <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                                <label class="form-label">Options</label>
                                <div id="fieldManagerSelectOptionsList" class="space-y-2 mb-3"></div>
                                <button onclick="addFieldManagerSelectOption()" type="button" class="btn btn-secondary btn-sm">+ Add Option</button>
                                <div class="mt-4 flex items-center">
                                    <input type="checkbox" id="fieldManagerAcceptNewOptions" checked class="mr-2">
                                    <label for="fieldManagerAcceptNewOptions" class="text-sm text-gray-700">Accept new options</label>
                                </div>
                            </div>
                        </div>
                        <div id="fieldManagerLinkToRecordConfig" class="config-section">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <label class="form-label">Link to Set</label>
                                <select id="fieldManagerLinkToSet"></select>
                                <p class="form-hint">Select which set to link to</p>
                            </div>
                        </div>
                        <div id="fieldManagerFormulaConfig" class="config-section">
                            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
                                <label class="form-label">Formula</label>
                                <div class="relative">
                                    <textarea id="fieldManagerFormulaInput" class="w-full px-3 py-2 border border-gray-300 rounded-lg font-mono text-sm" rows="4" placeholder="e.g., {Price} * {Quantity}"></textarea>
                                    <div id="fieldManagerFormulaAutocomplete" class="absolute z-10 hidden bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto" style="width: calc(100% - 2rem);"></div>
                                </div>
                                <p class="form-hint mt-2">Use {Field Name} to reference other fields. Available functions: SUM, AVG, MIN, MAX, IF, CONCAT, ROUND, etc.</p>
                                <div id="fieldManagerFormulaValidation" class="mt-2 text-sm"></div>
                                <div class="mt-3">
                                    <label class="form-label">Display Format</label>
                                    <select id="fieldManagerFormulaFormat" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                        <option value="number">Number</option>
                                        <option value="currency">Currency</option>
                                        <option value="percentage">Percentage</option>
                                        <option value="text">Text</option>
                                    </select>
                                </div>
                                <div class="mt-3">
                                    <label class="form-label">Decimal Places</label>
                                    <input type="number" id="fieldManagerFormulaDecimals" class="w-full px-3 py-2 border border-gray-300 rounded-lg" min="0" max="10" value="2">
                                </div>
                            </div>
                        </div>

                        <div class="flex gap-2">
                            <button id="saveNewFieldBtn" class="btn btn-primary flex-1">
                                <i class="ph ph-check"></i>
                                Save Field
                            </button>
                            <button id="cancelNewFieldBtn" class="btn btn-secondary flex-1">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer flex justify-end items-center gap-3">
                <button id="closeFieldManagerFooterBtn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <div id="historyPanel" class="side-panel">
        <div class="bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Edit History</h3>
                    <p class="text-sm opacity-90 mt-1">Full audit trail</p>
                </div>
                <button id="closeHistoryBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <input type="text" id="historySearch" class="w-full text-gray-900 rounded-lg" placeholder="Search history...">
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="historyContent"></div>
    </div>

    <div id="fuzzyMatchPanel" class="side-panel">
        <div class="bg-gradient-to-r from-emerald-500 to-blue-600 text-white p-6 flex-shrink-0">
            <div class="flex items-center justify-between mb-4">
                <div>
                    <h3 class="text-xl font-bold">Fuzzy Matches</h3>
                    <p class="text-sm opacity-90 mt-1">Possible duplicate or related records</p>
                </div>
                <button id="closeFuzzyPanelBtn" class="text-white hover:bg-white hover:bg-opacity-20 p-2 rounded-lg transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="panel-controls">
                <label class="text-sm flex-1">Similarity threshold
                    <input id="fuzzyThresholdInput" type="range" min="0.4" max="0.95" step="0.01" value="0.65" class="w-full">
                </label>
                <button id="refreshFuzzyMatchesBtn" class="btn btn-secondary btn-sm">Recompute</button>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto p-6" id="fuzzyMatchList"></div>
    </div>

    <!-- Cell History Modal -->
    <div id="cellHistoryModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900" id="cellHistoryTitle">Cell History</h2>
                    <p class="text-sm text-gray-500 mt-1" id="cellHistorySubtitle"></p>
                </div>
                <button class="text-gray-400 hover:text-gray-600 transition p-2" onclick="closeModal('cellHistoryModal')">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="p-6 overflow-auto" id="cellHistoryContent"></div>
        </div>
    </div>

    <!-- JSON Viewer Modal -->
    <div id="jsonViewerModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-6xl h-[90vh] max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header flex items-center justify-between">
                <div>
                    <h2 class="text-xl font-bold text-gray-900">JSON Data</h2>
                    <p class="text-sm text-gray-500 mt-1">View the complete data structure</p>
                </div>
                <button id="closeJsonViewerBtn" class="text-gray-400 hover:text-gray-600 transition p-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex border-b border-gray-200">
                <button class="json-tab active" data-tab="all" onclick="switchJsonTab('all')">All Data</button>
                <button class="json-tab" data-tab="sets" onclick="switchJsonTab('sets')">Sets</button>
                <button class="json-tab" data-tab="current" onclick="switchJsonTab('current')">Current Set</button>
                <button class="json-tab" data-tab="events" onclick="switchJsonTab('events')">Event Stream</button>
            </div>
            <div class="flex-1 overflow-hidden relative">
                <pre id="jsonContent" class="p-6 overflow-auto h-full text-sm bg-gray-50 font-mono"></pre>
                <button id="copyJsonBtn" class="absolute top-4 right-4 btn btn-secondary btn-sm">
                    <i class="ph ph-clipboard-text"></i>
                    Copy
                </button>
            </div>
        </div>
    </div>

    <!-- Search Data Modal -->
    <div id="searchDataModal" class="hidden fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
        <div class="modal-container bg-white w-full max-w-6xl max-h-[90vh] overflow-hidden flex flex-col">
            <div class="modal-header">
                <h2 class="text-xl font-bold text-gray-900">Search Data</h2>
                <p class="text-sm text-gray-500 mt-1">Find fields, records, and values. Focus on anything to explore its context.</p>
            </div>
            <div class="search-shell">
                <!-- LEFT: SEARCH + RESULTS -->
                <div class="search-surface">
                    <div class="search-input-row">
                        <input type="text" id="searchDataInput" placeholder="Type to search..." />
                        <div class="scope-pill" id="searchScopePill">Scope: Everything</div>
                    </div>
                    <div class="search-results-container" id="searchDataResults">
                        <p class="text-sm text-gray-400 px-5 pt-2">Type to search...</p>
                    </div>
                </div>

                <!-- RIGHT: FOCUS PANEL -->
                <aside class="focus-panel hidden" id="focusPanel">
                    <div class="focus-header">
                        <div class="focus-label">Focus</div>
                        <div class="focus-title-row">
                            <div style="flex: 1;">
                                <div class="focus-title" id="focusTitle">Select an item</div>
                                <div class="focus-subtitle" id="focusSubtitle"></div>
                            </div>
                            <span class="focus-tag" id="focusTag">-</span>
                        </div>
                        <button class="focus-clear" onclick="clearFocus()">Clear Focus</button>
                    </div>
                    <div class="focus-body" id="focusBody">
                        <p class="text-sm text-gray-500">Click "Focus" on any search result to see detailed information here.</p>
                    </div>
                    <div class="focus-actions" id="focusActions"></div>
                </aside>
            </div>
            <div class="modal-footer flex justify-between gap-2" style="border-top: 1px solid var(--border);">
                <div class="flex gap-2">
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="everything" checked onchange="updateSearchScope()">
                        <span>Everything</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="fields" onchange="updateSearchScope()">
                        <span>Fields</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="records" onchange="updateSearchScope()">
                        <span>Records</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm">
                        <input type="radio" name="searchScope" value="values" onchange="updateSearchScope()">
                        <span>Values</span>
                    </label>
                </div>
                <button id="closeSearchDataBtn" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <script>
        const BRAND_ASSETS = {
            light: 'assets/eo-icons/eo-bracket-light.svg',
            dark: 'assets/eo-icons/eo-bracket-dark.svg'
        };

        function getTimeOfDayBrandMode() {
            const hour = new Date().getHours();
            return hour >= 6 && hour < 18 ? 'light' : 'dark';
        }

        function applyTimeBasedBranding() {
            const mode = getTimeOfDayBrandMode();
            const bracketAsset = BRAND_ASSETS[mode] || BRAND_ASSETS.light;

            const faviconLink = document.querySelector('link#dynamicFavicon');
            if (faviconLink) {
                faviconLink.href = bracketAsset;
            }

            const appleIcon = document.querySelector('link#dynamicAppleIcon');
            if (appleIcon) {
                appleIcon.href = bracketAsset;
            }

            const cornerLogo = document.getElementById('topCornerLogo');
            if (cornerLogo) {
                const darkAsset = BRAND_ASSETS.dark || bracketAsset;
                cornerLogo.src = darkAsset;
                cornerLogo.alt = 'EO bracket logo for dark mode';
                cornerLogo.dataset.brandMode = 'dark';
            }

            document.documentElement.dataset.brandMode = mode;
        }

        // STATE
        const state = {
            worlds: new Map(),
            entities: new Map(),
            currentWorldId: null,
            sets: new Map(),
            currentSetId: null,
            currentViewId: null,
            currentProfileId: 'default',
            eventStream: [],
            eventIdCounter: 1,
            currentUser: { type: 'Person', id: 'user_1', name: 'User' },
            operatorSet: {},
            connectionModes: {},
            connectionRelations: new Map(),
            leanContext: null, // Will be initialized in initializeApp
            interpretationRules: [],
            definitions: new Map(),
            entityFormState: { activeFilter: 'all', editingId: null, selectedType: 'set', expandedEntities: new Set() },
            connections: new Map(),
            demoRefs: {},
            connectionBuilder: { targetSetId: null, targetRecordId: '', searchQuery: '', relationId: null, params: {} },
            currentSpecialView: null,
            definitionFormState: { editingId: null, activeFilter: 'all', showImportPanel: false },
            connectionFormState: { editingId: null, selectedRelationId: null },
            connectionRelationFormState: { editingId: null },
            sidebarCollapsed: false,
            sidebarOpenMobile: false,
            modalStack: [],
            currentRecordTab: 'history',
            recordHistoryVisible: true,
            openTabs: [],
            confirmCallback: null,
            selectOptions: [{ value: 'Option 1', color: 'blue' }],
            changeSelectOptions: [{ value: 'Option 1', color: 'blue' }],
            changeLinkedSetId: '',
            changeFieldOriginalType: null,
            fieldTypeDropdownOpen: false,
            changeFieldTypeDropdownOpen: false,
            changeFieldContext: null,
            expandedSets: new Set(),
            collapsedNavSections: new Set(), // Track collapsed nav sections: 'world', 'explore', 'actions'
            draggedRecord: null,
            cellHistoryContext: null,
            setEditorContext: null,
            viewEditorContext: null,
            iconPickerTarget: null,
            iconPickerQuery: '',
            popupUi: { filter: 'all', activeTab: 'popupFields' },
            popupEventStream: [],
            popupDraggedField: null,
            iconPickerPage: 1,
            selectedRecordIds: new Set(),
            lastSelectedRecordId: null,
            selectedCell: null,
            lastSelectedCell: null,
            editingCell: null,
            csvImportState: { headers: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'existing', targetSetId: null, newSetName: '' },
            fuzzyPanelState: { threshold: 0.65, matches: [] },
            fieldTypeHistory: new Map()
        };

        function registerEntity(entity) {
            if (!entity || !entity.id || !entity.type) {
                throw new Error('Entities require an id and type');
            }
            if (!state.entities) state.entities = new Map();
            const existing = state.entities.get(entity.id) || {};
            const worldId = entity.worldId || existing.worldId || deriveWorldIdForEntity(entity);
            const payload = {
                ...existing,
                ...entity,
                worldId,
                entityType: entity.entityType || existing.entityType || entity.type,
                origin: entity.origin || existing.origin || 'system'
            };
            state.entities.set(entity.id, payload);
            return payload;
        }

        function deleteEntity(entityId) {
            if (!state.entities?.has(entityId)) return null;
            const existing = state.entities.get(entityId);
            state.entities.delete(entityId);
            return existing;
        }

        function getEntityView(filterFn) {
            const entities = Array.from(state.entities.values()).filter(entity => !entity.worldId || entity.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? entities.filter(filterFn) : entities;
        }

        const columnDragState = {
            timer: null,
            holdTimer: null,
            holdReady: false,
            draggedFieldId: null,
            dropFieldId: null,
            dropPosition: null,
            ghost: null,
            offsetX: 0,
            offsetY: 0,
            sourceElement: null,
            preventClick: false
        };

        const tabDragState = {
            draggingKey: null,
            dropKey: null,
            dropPosition: null
        };

        const COLUMN_WIDTH_MIN = 60;
        const COLUMN_WIDTH_MAX = 600;

        function clampColumnWidth(width) {
            if (isNaN(width)) return 150;
            return Math.min(COLUMN_WIDTH_MAX, Math.max(COLUMN_WIDTH_MIN, width));
        }

        function getFieldWidth(field) {
            const numericWidth = parseInt(field?.width || '150', 10);
            return clampColumnWidth(numericWidth);
        }



        const FIELD_TYPES = {
            TEXT: {
                id: 'TEXT',
                name: 'Text',
                description: 'Text fields with formatting options',
                defaultValue: '',
                icon: 'ph-text-t',
                subtypes: {
                    SHORT: { id: 'SHORT', name: 'Short Text', description: 'Single line text for titles and labels', icon: 'ph-text-t' },
                    LONG: { id: 'LONG', name: 'Long Text', description: 'Multi-line text for notes and descriptions', icon: 'ph-article' },
                    RICH: { id: 'RICH', name: 'Rich Text', description: 'Formatted text with markdown and HTML support', icon: 'ph-text-aa' }
                },
                defaultSubtype: 'SHORT'
            },
            NUMBER: {
                id: 'NUMBER',
                name: 'Number',
                description: 'Numeric values with formatting',
                defaultValue: 0,
                icon: 'ph-hash',
                subtypes: {
                    NUMBER: { id: 'NUMBER', name: 'Number', description: 'Plain numeric values with sorting and calculations', icon: 'ph-hash' },
                    CURRENCY: { id: 'CURRENCY', name: 'Currency', description: 'Financial amounts with currency formatting', icon: 'ph-currency-dollar' }
                },
                defaultSubtype: 'NUMBER'
            },
            DATE: {
                id: 'DATE',
                name: 'Date',
                description: 'Capture due dates, milestones, and schedules',
                defaultValue: '',
                icon: 'ph-calendar-blank'
            },
            CONTACT: {
                id: 'CONTACT',
                name: 'Contact',
                description: 'Contact information fields',
                defaultValue: '',
                icon: 'ph-address-book',
                subtypes: {
                    EMAIL: { id: 'EMAIL', name: 'Email', description: 'Email addresses with validation', icon: 'ph-envelope-simple' },
                    URL: { id: 'URL', name: 'URL', description: 'Links to webpages, docs, or media', icon: 'ph-link-simple' },
                    PHONE: { id: 'PHONE', name: 'Phone', description: 'Phone numbers for contacts', icon: 'ph-phone' }
                },
                defaultSubtype: 'EMAIL'
            },
            LINK_RECORD: {
                id: 'LINK_RECORD',
                name: 'Link to Record',
                description: 'Connect records across sets with relationships',
                defaultValue: '',
                icon: 'ph-link-simple-horizontal',
                needsConfig: true
            },
            LOOKUP: {
                id: 'LOOKUP',
                name: 'Lookup',
                description: 'Search and reference records from another set',
                defaultValue: '',
                icon: 'ph-magnifying-glass',
                needsConfig: true
            },
            SELECT: {
                id: 'SELECT',
                name: 'Select',
                description: 'Choose from a list of options',
                defaultValue: '',
                icon: 'ph-list-bullets',
                needsConfig: true,
                subtypes: {
                    SINGLE: { id: 'SINGLE', name: 'Single Select', description: 'Choose one option from a list', icon: 'ph-list-bullets' },
                    MULTIPLE: { id: 'MULTIPLE', name: 'Multiple Select', description: 'Choose multiple options from a list', icon: 'ph-list-checks' }
                },
                defaultSubtype: 'SINGLE'
            },
            CHECKBOX: {
                id: 'CHECKBOX',
                name: 'Checkbox',
                description: 'Quick yes/no or done/undone tracking',
                defaultValue: false,
                icon: 'ph-check-square'
            },
            FORMULA: {
                id: 'FORMULA',
                name: 'Formula',
                description: 'Calculate values using spreadsheet-style formulas',
                defaultValue: '',
                icon: 'ph-function',
                needsConfig: true
            }
        };

        const VIEW_TYPE_ICONS = { grid: 'ph-table', card: 'ph-cards-three', kanban: 'ph-kanban', graph: 'ph-graph', KEY_DERIVED: 'ph-key' };

        // Formula Autocomplete
        function initFormulaAutocomplete() {
            const input = document.getElementById('formulaInput');
            const autocomplete = document.getElementById('formulaAutocomplete');
            const validation = document.getElementById('formulaValidation');

            if (!input || !autocomplete) return;

            let autocompleteState = {
                cursorPos: 0,
                searchText: '',
                isActive: false
            };

            function hideAutocomplete() {
                autocomplete.classList.add('hidden');
                autocompleteState.isActive = false;
            }

            function showAutocomplete(items, searchText) {
                if (items.length === 0) {
                    hideAutocomplete();
                    return;
                }

                autocomplete.innerHTML = items.map((item, index) => `
                    <div class="autocomplete-item px-3 py-2 hover:bg-purple-100 cursor-pointer ${index === 0 ? 'bg-purple-50' : ''}"
                         data-value="${item.value}"
                         data-index="${index}">
                        <div class="font-medium text-sm">${item.label}</div>
                        ${item.description ? `<div class="text-xs text-gray-500">${item.description}</div>` : ''}
                    </div>
                `).join('');

                // Add click handlers
                autocomplete.querySelectorAll('.autocomplete-item').forEach(el => {
                    el.onclick = () => {
                        insertAutocomplete(el.dataset.value, searchText);
                        hideAutocomplete();
                    };
                });

                autocomplete.classList.remove('hidden');
                autocompleteState.isActive = true;
            }

            function insertAutocomplete(value, searchText) {
                const text = input.value;
                const cursorPos = input.selectionStart;
                const beforeCursor = text.substring(0, cursorPos);
                const afterCursor = text.substring(cursorPos);

                let newText, newCursorPos;

                // Check if we're inserting a field (starts with {) or a function
                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos && value.startsWith('{')) {
                    // Inserting a field reference
                    newText = text.substring(0, lastBracePos) + value + afterCursor;
                    newCursorPos = lastBracePos + value.length;
                } else {
                    // Inserting a function - replace the partial word
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch) {
                        const startPos = cursorPos - wordMatch[0].length;
                        newText = text.substring(0, startPos) + value + afterCursor;
                        newCursorPos = startPos + value.length;
                    } else {
                        // Fallback: just insert at cursor
                        newText = beforeCursor + value + afterCursor;
                        newCursorPos = cursorPos + value.length;
                    }
                }

                input.value = newText;
                input.setSelectionRange(newCursorPos, newCursorPos);
                input.focus();

                validateFormula();
            }

            function validateFormula() {
                const formula = input.value.trim();
                if (!formula) {
                    validation.innerHTML = '';
                    return;
                }

                const set = getCurrentSet();
                const result = FormulaEngine.validateFormula(formula, set.schema);

                if (result.valid) {
                    validation.innerHTML = '<span class="text-green-600"> Valid formula</span>';
                    if (result.dependencies.length > 0) {
                        validation.innerHTML += `<div class="text-xs text-gray-600 mt-1">Uses: ${result.dependencies.join(', ')}</div>`;
                    }
                } else {
                    validation.innerHTML = `<span class="text-red-600"> ${result.error}</span>`;
                }
            }

            input.addEventListener('input', (e) => {
                const cursorPos = input.selectionStart;
                const text = input.value;
                const beforeCursor = text.substring(0, cursorPos);

                // Check if we're inside a field reference
                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos) {
                    // We're inside a field reference
                    const searchText = beforeCursor.substring(lastBracePos + 1).toLowerCase();
                    const set = getCurrentSet();

                    // Get field suggestions
                    const fields = set.schema
                        .filter(f => f.name.toLowerCase().includes(searchText))
                        .map(f => ({
                            label: f.name,
                            value: `{${f.name}}`,
                            description: FIELD_TYPES[f.type]?.name || f.type
                        }));

                    showAutocomplete(fields, searchText);
                } else {
                    // Check if we're typing a function name
                    // Look for the last word before cursor (alphanumeric characters)
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch && wordMatch[0].length > 0) {
                        const searchText = wordMatch[0].toUpperCase();

                        // Function descriptions
                        const functionDescriptions = {
                            SUM: 'Add numbers together',
                            AVG: 'Calculate average of numbers',
                            MIN: 'Find minimum value',
                            MAX: 'Find maximum value',
                            ROUND: 'Round number to decimals',
                            ABS: 'Absolute value',
                            SQRT: 'Square root',
                            POWER: 'Raise to power',
                            IF: 'Conditional logic',
                            AND: 'Logical AND',
                            OR: 'Logical OR',
                            NOT: 'Logical NOT',
                            CONCAT: 'Combine text',
                            UPPER: 'Convert to uppercase',
                            LOWER: 'Convert to lowercase',
                            TRIM: 'Remove whitespace',
                            LEN: 'Text length',
                            LEFT: 'Get left characters',
                            RIGHT: 'Get right characters',
                            COUNT: 'Count non-null values',
                            COUNTA: 'Count non-empty values',
                            ISBLANK: 'Check if blank',
                            ISNUMBER: 'Check if number'
                        };

                        // Get function suggestions
                        const functions = Object.keys(FormulaEngine.functions)
                            .filter(fn => fn.startsWith(searchText))
                            .map(fn => ({
                                label: fn,
                                value: fn + '(',
                                description: functionDescriptions[fn] || 'Function'
                            }));

                        if (functions.length > 0) {
                            showAutocomplete(functions, searchText);
                        } else {
                            hideAutocomplete();
                        }
                    } else {
                        hideAutocomplete();
                    }
                }

                validateFormula();
            });

            input.addEventListener('keydown', (e) => {
                if (autocompleteState.isActive) {
                    const items = autocomplete.querySelectorAll('.autocomplete-item');
                    const selected = autocomplete.querySelector('.bg-purple-50');

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (selected && selected.nextElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.nextElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (selected && selected.previousElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.previousElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'Enter' || e.key === 'Tab') {
                        e.preventDefault();
                        if (selected) {
                            const searchText = input.value.substring(0, input.selectionStart).split('{').pop();
                            insertAutocomplete(selected.dataset.value, searchText);
                            hideAutocomplete();
                        }
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                    }
                }
            });

            input.addEventListener('blur', () => {
                // Delay hiding to allow click on autocomplete
                setTimeout(hideAutocomplete, 200);
            });

            validateFormula();
        }

        // Change Formula Autocomplete (for change field type modal)
        function initChangeFormulaAutocomplete() {
            const input = document.getElementById('changeFormulaInput');
            const autocomplete = document.getElementById('changeFormulaAutocomplete');
            const validation = document.getElementById('changeFormulaValidation');

            if (!input || !autocomplete) return;

            let autocompleteState = {
                cursorPos: 0,
                searchText: '',
                isActive: false
            };

            function hideAutocomplete() {
                autocomplete.classList.add('hidden');
                autocompleteState.isActive = false;
            }

            function showAutocomplete(items, searchText) {
                if (items.length === 0) {
                    hideAutocomplete();
                    return;
                }

                autocomplete.innerHTML = items.map((item, index) => `
                    <div class="autocomplete-item px-3 py-2 hover:bg-purple-100 cursor-pointer ${index === 0 ? 'bg-purple-50' : ''}"
                         data-value="${item.value}"
                         data-index="${index}">
                        <div class="font-medium text-sm">${item.label}</div>
                        ${item.description ? `<div class="text-xs text-gray-500">${item.description}</div>` : ''}
                    </div>
                `).join('');

                autocomplete.querySelectorAll('.autocomplete-item').forEach(el => {
                    el.onclick = () => {
                        insertAutocomplete(el.dataset.value, searchText);
                        hideAutocomplete();
                    };
                });

                autocomplete.classList.remove('hidden');
                autocompleteState.isActive = true;
            }

            function insertAutocomplete(value, searchText) {
                const text = input.value;
                const cursorPos = input.selectionStart;
                const beforeCursor = text.substring(0, cursorPos);
                const afterCursor = text.substring(cursorPos);

                let newText, newCursorPos;

                // Check if we're inserting a field (starts with {) or a function
                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos && value.startsWith('{')) {
                    // Inserting a field reference
                    newText = text.substring(0, lastBracePos) + value + afterCursor;
                    newCursorPos = lastBracePos + value.length;
                } else {
                    // Inserting a function - replace the partial word
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch) {
                        const startPos = cursorPos - wordMatch[0].length;
                        newText = text.substring(0, startPos) + value + afterCursor;
                        newCursorPos = startPos + value.length;
                    } else {
                        // Fallback: just insert at cursor
                        newText = beforeCursor + value + afterCursor;
                        newCursorPos = cursorPos + value.length;
                    }
                }

                input.value = newText;
                input.setSelectionRange(newCursorPos, newCursorPos);
                input.focus();

                validateFormula();
            }

            function validateFormula() {
                const formula = input.value.trim();
                if (!formula) {
                    validation.innerHTML = '';
                    return;
                }

                const set = getCurrentSet();
                const result = FormulaEngine.validateFormula(formula, set.schema);

                if (result.valid) {
                    validation.innerHTML = '<span class="text-green-600"> Valid formula</span>';
                    if (result.dependencies.length > 0) {
                        validation.innerHTML += `<div class="text-xs text-gray-600 mt-1">Uses: ${result.dependencies.join(', ')}</div>`;
                    }
                } else {
                    validation.innerHTML = `<span class="text-red-600"> ${result.error}</span>`;
                }
            }

            input.addEventListener('input', (e) => {
                const cursorPos = input.selectionStart;
                const text = input.value;
                const beforeCursor = text.substring(0, cursorPos);

                const lastBracePos = beforeCursor.lastIndexOf('{');
                const lastCloseBracePos = beforeCursor.lastIndexOf('}');

                if (lastBracePos > lastCloseBracePos) {
                    // We're inside a field reference
                    const searchText = beforeCursor.substring(lastBracePos + 1).toLowerCase();
                    const set = getCurrentSet();

                    const fields = set.schema
                        .filter(f => f.name.toLowerCase().includes(searchText))
                        .map(f => ({
                            label: f.name,
                            value: `{${f.name}}`,
                            description: FIELD_TYPES[f.type]?.name || f.type
                        }));

                    showAutocomplete(fields, searchText);
                } else {
                    // Check if we're typing a function name
                    const wordMatch = beforeCursor.match(/[A-Z_]+$/i);
                    if (wordMatch && wordMatch[0].length > 0) {
                        const searchText = wordMatch[0].toUpperCase();

                        // Function descriptions
                        const functionDescriptions = {
                            SUM: 'Add numbers together',
                            AVG: 'Calculate average of numbers',
                            MIN: 'Find minimum value',
                            MAX: 'Find maximum value',
                            ROUND: 'Round number to decimals',
                            ABS: 'Absolute value',
                            SQRT: 'Square root',
                            POWER: 'Raise to power',
                            IF: 'Conditional logic',
                            AND: 'Logical AND',
                            OR: 'Logical OR',
                            NOT: 'Logical NOT',
                            CONCAT: 'Combine text',
                            UPPER: 'Convert to uppercase',
                            LOWER: 'Convert to lowercase',
                            TRIM: 'Remove whitespace',
                            LEN: 'Text length',
                            LEFT: 'Get left characters',
                            RIGHT: 'Get right characters',
                            COUNT: 'Count non-null values',
                            COUNTA: 'Count non-empty values',
                            ISBLANK: 'Check if blank',
                            ISNUMBER: 'Check if number'
                        };

                        // Get function suggestions
                        const functions = Object.keys(FormulaEngine.functions)
                            .filter(fn => fn.startsWith(searchText))
                            .map(fn => ({
                                label: fn,
                                value: fn + '(',
                                description: functionDescriptions[fn] || 'Function'
                            }));

                        if (functions.length > 0) {
                            showAutocomplete(functions, searchText);
                        } else {
                            hideAutocomplete();
                        }
                    } else {
                        hideAutocomplete();
                    }
                }

                validateFormula();
            });

            input.addEventListener('keydown', (e) => {
                if (autocompleteState.isActive) {
                    const items = autocomplete.querySelectorAll('.autocomplete-item');
                    const selected = autocomplete.querySelector('.bg-purple-50');

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (selected && selected.nextElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.nextElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (selected && selected.previousElementSibling) {
                            selected.classList.remove('bg-purple-50');
                            selected.previousElementSibling.classList.add('bg-purple-50');
                        }
                    } else if (e.key === 'Enter' || e.key === 'Tab') {
                        e.preventDefault();
                        if (selected) {
                            const searchText = input.value.substring(0, input.selectionStart).split('{').pop();
                            insertAutocomplete(selected.dataset.value, searchText);
                            hideAutocomplete();
                        }
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                    }
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(hideAutocomplete, 200);
            });

            validateFormula();
        }

        // Formula Engine
        const FormulaEngine = {
            functions: {
                // Math functions
                SUM: (...args) => args.reduce((sum, val) => sum + (Number(val) || 0), 0),
                AVG: (...args) => {
                    const nums = args.map(v => Number(v) || 0);
                    return nums.length ? nums.reduce((sum, val) => sum + val, 0) / nums.length : 0;
                },
                MIN: (...args) => Math.min(...args.map(v => Number(v) || 0)),
                MAX: (...args) => Math.max(...args.map(v => Number(v) || 0)),
                ROUND: (num, decimals = 0) => {
                    const n = Number(num) || 0;
                    const d = Number(decimals) || 0;
                    return Math.round(n * Math.pow(10, d)) / Math.pow(10, d);
                },
                ABS: (num) => Math.abs(Number(num) || 0),
                SQRT: (num) => Math.sqrt(Number(num) || 0),
                POWER: (base, exp) => Math.pow(Number(base) || 0, Number(exp) || 0),

                // Logical functions
                IF: (condition, trueVal, falseVal) => condition ? trueVal : falseVal,
                AND: (...args) => args.every(v => !!v),
                OR: (...args) => args.some(v => !!v),
                NOT: (val) => !val,

                // Text functions
                CONCAT: (...args) => args.map(v => String(v ?? '')).join(''),
                UPPER: (text) => String(text ?? '').toUpperCase(),
                LOWER: (text) => String(text ?? '').toLowerCase(),
                TRIM: (text) => String(text ?? '').trim(),
                LEN: (text) => String(text ?? '').length,
                LEFT: (text, count) => String(text ?? '').substring(0, Number(count) || 0),
                RIGHT: (text, count) => {
                    const str = String(text ?? '');
                    const n = Number(count) || 0;
                    return str.substring(Math.max(0, str.length - n));
                },

                // Counting functions
                COUNT: (...args) => args.filter(v => v != null).length,
                COUNTA: (...args) => args.filter(v => v !== null && v !== undefined && v !== '').length,

                // Value checks
                ISBLANK: (val) => val == null || val === '',
                ISNUMBER: (val) => typeof val === 'number' && !isNaN(val),
            },

            evaluate(formula, record, schema) {
                if (!formula) return '';

                try {
                    // Replace field references {FieldName} with their values
                    let processedFormula = formula;
                    const fieldRefs = formula.match(/\{([^}]+)\}/g);

                    if (fieldRefs) {
                        for (const ref of fieldRefs) {
                            const fieldName = ref.slice(1, -1); // Remove { and }
                            const field = schema.find(f => f.name === fieldName);
                            if (field) {
                                let value = record[field.id];
                                // Convert value to appropriate type for formula
                                if (value === undefined || value === null) value = '';
                                if (typeof value === 'string') {
                                    // If it's a number string, convert it for math operations
                                    const num = parseFloat(value);
                                    if (!isNaN(num) && value.trim() !== '') {
                                        value = num;
                                    } else {
                                        value = `"${value.replace(/"/g, '\\"')}"`;
                                    }
                                }
                                processedFormula = processedFormula.replace(ref, value);
                            } else {
                                processedFormula = processedFormula.replace(ref, '""');
                            }
                        }
                    }

                    // Replace concatenation operator & with JavaScript's +
                    // Must be done carefully to avoid replacing bitwise AND in conditions
                    processedFormula = processedFormula.replace(/&/g, '+');

                    // Replace function calls
                    for (const [funcName, funcImpl] of Object.entries(this.functions)) {
                        const regex = new RegExp(`\\b${funcName}\\s*\\(`, 'g');
                        processedFormula = processedFormula.replace(regex, `FormulaEngine.functions.${funcName}(`);
                    }

                    // Evaluate the formula
                    const result = eval(processedFormula);
                    return result;
                } catch (error) {
                    console.error('Formula evaluation error:', error, formula);
                    return '#ERROR';
                }
            },

            extractFieldReferences(formula) {
                if (!formula) return [];
                const matches = formula.match(/\{([^}]+)\}/g);
                if (!matches) return [];
                return matches.map(m => m.slice(1, -1));
            },

            validateFormula(formula, schema) {
                if (!formula) return { valid: false, error: 'Formula is empty' };

                try {
                    // Check for field references
                    const fieldRefs = this.extractFieldReferences(formula);
                    const invalidFields = [];

                    for (const fieldName of fieldRefs) {
                        const field = schema.find(f => f.name === fieldName);
                        if (!field) {
                            invalidFields.push(fieldName);
                        }
                    }

                    if (invalidFields.length > 0) {
                        return {
                            valid: false,
                            error: `Unknown fields: ${invalidFields.join(', ')}`,
                            dependencies: fieldRefs
                        };
                    }

                    return {
                        valid: true,
                        error: null,
                        dependencies: fieldRefs
                    };
                } catch (error) {
                    return {
                        valid: false,
                        error: error.message,
                        dependencies: []
                    };
                }
            },

            formatFormulaValue(value, format, decimals) {
                if (value === '#ERROR' || value === null || value === undefined) return value;

                decimals = decimals || 2;

                switch (format) {
                    case 'number':
                        if (typeof value === 'number') {
                            return value.toFixed(decimals);
                        }
                        return String(value);

                    case 'currency':
                        if (typeof value === 'number') {
                            return new Intl.NumberFormat('en-US', {
                                style: 'currency',
                                currency: 'USD',
                                minimumFractionDigits: decimals,
                                maximumFractionDigits: decimals
                            }).format(value);
                        }
                        return String(value);

                    case 'percentage':
                        if (typeof value === 'number') {
                            return (value * 100).toFixed(decimals) + '%';
                        }
                        return String(value);

                    case 'text':
                    default:
                        return String(value);
                }
            }
        };

        const ICON_OPTIONS = [
            // Organization & Layout
            { token: 'ph-squares-four', label: 'Grid', keywords: ['dashboard', 'board', 'overview', 'layout'] },
            { token: 'ph-table', label: 'Table', keywords: ['grid', 'sheet', 'records', 'spreadsheet'] },
            { token: 'ph-cards-three', label: 'Cards', keywords: ['gallery', 'kanban', 'tiles', 'card'] },
            { token: 'ph-kanban', label: 'Kanban', keywords: ['workflow', 'board', 'columns', 'agile'] },
            { token: 'ph-list', label: 'List', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-bullets', label: 'List Bullets', keywords: ['todo', 'tasks', 'rows', 'items'] },
            { token: 'ph-list-checks', label: 'List Checks', keywords: ['todo', 'tasks', 'checklist', 'complete'] },
            { token: 'ph-list-dashes', label: 'List Dashes', keywords: ['items', 'menu', 'rows'] },
            { token: 'ph-list-numbers', label: 'List Numbers', keywords: ['ordered', 'sequence', 'steps'] },
            { token: 'ph-rows', label: 'Rows', keywords: ['layout', 'horizontal', 'lines'] },
            { token: 'ph-columns', label: 'Columns', keywords: ['layout', 'vertical', 'split'] },
            { token: 'ph-sidebar', label: 'Sidebar', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-sidebar-simple', label: 'Sidebar Simple', keywords: ['navigation', 'menu', 'panel'] },
            { token: 'ph-layout', label: 'Layout', keywords: ['design', 'structure', 'template'] },
            { token: 'ph-app-window', label: 'App Window', keywords: ['browser', 'application', 'screen'] },

            // Files & Folders
            { token: 'ph-folder', label: 'Folder', keywords: ['directory', 'files', 'organize'] },
            { token: 'ph-folders', label: 'Folders', keywords: ['files', 'library', 'taxonomy', 'organize'] },
            { token: 'ph-folder-open', label: 'Folder Open', keywords: ['directory', 'files', 'browse'] },
            { token: 'ph-folder-plus', label: 'Folder Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-file', label: 'File', keywords: ['document', 'page', 'content'] },
            { token: 'ph-file-text', label: 'File Text', keywords: ['document', 'page', 'text'] },
            { token: 'ph-file-plus', label: 'File Plus', keywords: ['create', 'new', 'add'] },
            { token: 'ph-files', label: 'Files', keywords: ['documents', 'pages', 'multiple'] },
            { token: 'ph-note', label: 'Note', keywords: ['memo', 'text', 'write'] },
            { token: 'ph-note-blank', label: 'Note Blank', keywords: ['new', 'empty', 'create'] },
            { token: 'ph-notebook', label: 'Notebook', keywords: ['notes', 'doc', 'wiki', 'journal'] },
            { token: 'ph-notepad', label: 'Notepad', keywords: ['notes', 'memo', 'write'] },
            { token: 'ph-article', label: 'Article', keywords: ['blog', 'post', 'content'] },
            { token: 'ph-newspaper', label: 'Newspaper', keywords: ['news', 'article', 'media'] },
            { token: 'ph-book', label: 'Book', keywords: ['library', 'reading', 'documentation'] },
            { token: 'ph-book-open', label: 'Book Open', keywords: ['reading', 'documentation', 'learn'] },
            { token: 'ph-books', label: 'Books', keywords: ['library', 'reading', 'education'] },

            // Documents & Text
            { token: 'ph-clipboard', label: 'Clipboard', keywords: ['copy', 'paste', 'temp'] },
            { token: 'ph-clipboard-text', label: 'Clipboard Text', keywords: ['notes', 'summary', 'doc', 'copy'] },
            { token: 'ph-article-medium', label: 'Article Medium', keywords: ['blog', 'post', 'medium'] },
            { token: 'ph-textbox', label: 'Textbox', keywords: ['input', 'field', 'form'] },
            { token: 'ph-text-aa', label: 'Text AA', keywords: ['font', 'typography', 'letters'] },
            { token: 'ph-text-t', label: 'Text T', keywords: ['font', 'type', 'letter'] },
            { token: 'ph-quotes', label: 'Quotes', keywords: ['citation', 'text', 'speech'] },
            { token: 'ph-signature', label: 'Signature', keywords: ['sign', 'approve', 'autograph'] },

            // Communication
            { token: 'ph-chat', label: 'Chat', keywords: ['message', 'conversation', 'talk'] },
            { token: 'ph-chat-circle', label: 'Chat Circle', keywords: ['message', 'bubble', 'talk'] },
            { token: 'ph-chat-dots', label: 'Chat Dots', keywords: ['message', 'typing', 'conversation'] },
            { token: 'ph-chats', label: 'Chats', keywords: ['messages', 'conversations', 'multiple'] },
            { token: 'ph-envelope', label: 'Envelope', keywords: ['email', 'mail', 'message'] },
            { token: 'ph-envelope-open', label: 'Envelope Open', keywords: ['email', 'read', 'mail'] },
            { token: 'ph-envelope-simple', label: 'Envelope Simple', keywords: ['email', 'mail', 'send'] },
            { token: 'ph-paper-plane-tilt', label: 'Paper Plane', keywords: ['send', 'message', 'mail'] },
            { token: 'ph-phone', label: 'Phone', keywords: ['contact', 'call', 'support', 'telephone'] },
            { token: 'ph-phone-call', label: 'Phone Call', keywords: ['calling', 'telephone', 'contact'] },
            { token: 'ph-megaphone', label: 'Megaphone', keywords: ['announcement', 'broadcast', 'marketing'] },
            { token: 'ph-speaker-high', label: 'Speaker High', keywords: ['volume', 'sound', 'audio'] },
            { token: 'ph-bell', label: 'Bell', keywords: ['alerts', 'reminders', 'updates', 'notifications'] },
            { token: 'ph-bell-ringing', label: 'Bell Ringing', keywords: ['alert', 'notification', 'alarm'] },

            // Users & People
            { token: 'ph-user', label: 'User', keywords: ['person', 'profile', 'account'] },
            { token: 'ph-user-circle', label: 'User Circle', keywords: ['profile', 'account', 'avatar'] },
            { token: 'ph-user-plus', label: 'User Plus', keywords: ['add', 'invite', 'new'] },
            { token: 'ph-users', label: 'Users', keywords: ['people', 'group', 'team'] },
            { token: 'ph-users-three', label: 'Users Three', keywords: ['people', 'collaboration', 'group', 'team'] },
            { token: 'ph-user-gear', label: 'User Gear', keywords: ['settings', 'profile', 'account'] },
            { token: 'ph-identification-card', label: 'ID Card', keywords: ['profile', 'identity', 'badge'] },
            { token: 'ph-address-book', label: 'Address Book', keywords: ['contacts', 'people', 'directory'] },

            // Time & Calendar
            { token: 'ph-calendar', label: 'Calendar', keywords: ['dates', 'schedule', 'events', 'day'] },
            { token: 'ph-calendar-blank', label: 'Calendar Blank', keywords: ['dates', 'schedule', 'events', 'empty'] },
            { token: 'ph-calendar-check', label: 'Calendar Check', keywords: ['event', 'confirmed', 'scheduled'] },
            { token: 'ph-calendar-plus', label: 'Calendar Plus', keywords: ['add', 'event', 'new'] },
            { token: 'ph-calendar-x', label: 'Calendar X', keywords: ['cancel', 'delete', 'remove'] },
            { token: 'ph-clock', label: 'Clock', keywords: ['time', 'schedule', 'hour'] },
            { token: 'ph-clock-countdown', label: 'Clock Countdown', keywords: ['timer', 'countdown', 'deadline'] },
            { token: 'ph-timer', label: 'Timer', keywords: ['stopwatch', 'time', 'clock'] },
            { token: 'ph-hourglass', label: 'Hourglass', keywords: ['time', 'waiting', 'pending'] },
            { token: 'ph-alarm', label: 'Alarm', keywords: ['clock', 'reminder', 'alert'] },

            // Actions & Controls
            { token: 'ph-plus', label: 'Plus', keywords: ['add', 'create', 'new'] },
            { token: 'ph-plus-circle', label: 'Plus Circle', keywords: ['add', 'create', 'new'] },
            { token: 'ph-minus', label: 'Minus', keywords: ['remove', 'subtract', 'delete'] },
            { token: 'ph-minus-circle', label: 'Minus Circle', keywords: ['remove', 'delete', 'subtract'] },
            { token: 'ph-x', label: 'X', keywords: ['close', 'cancel', 'delete'] },
            { token: 'ph-x-circle', label: 'X Circle', keywords: ['close', 'cancel', 'remove'] },
            { token: 'ph-check', label: 'Check', keywords: ['done', 'complete', 'confirm'] },
            { token: 'ph-check-circle', label: 'Check Circle', keywords: ['done', 'complete', 'success'] },
            { token: 'ph-trash', label: 'Trash', keywords: ['delete', 'remove', 'bin'] },
            { token: 'ph-pencil', label: 'Pencil', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pencil-simple', label: 'Pencil Simple', keywords: ['edit', 'write', 'modify'] },
            { token: 'ph-pen', label: 'Pen', keywords: ['write', 'edit', 'signature'] },
            { token: 'ph-eraser', label: 'Eraser', keywords: ['delete', 'remove', 'clear'] },
            { token: 'ph-copy', label: 'Copy', keywords: ['duplicate', 'clone', 'paste'] },
            { token: 'ph-scissors', label: 'Scissors', keywords: ['cut', 'trim', 'clip'] },
            { token: 'ph-floppy-disk', label: 'Floppy Disk', keywords: ['save', 'store', 'disk'] },
            { token: 'ph-download', label: 'Download', keywords: ['save', 'export', 'get'] },
            { token: 'ph-upload', label: 'Upload', keywords: ['import', 'add', 'send'] },
            { token: 'ph-export', label: 'Export', keywords: ['download', 'save', 'output'] },
            { token: 'ph-share', label: 'Share', keywords: ['send', 'distribute', 'forward'] },
            { token: 'ph-share-network', label: 'Share Network', keywords: ['social', 'distribute', 'connect'] },

            // Navigation
            { token: 'ph-arrow-left', label: 'Arrow Left', keywords: ['back', 'previous', 'return'] },
            { token: 'ph-arrow-right', label: 'Arrow Right', keywords: ['forward', 'next', 'continue'] },
            { token: 'ph-arrow-up', label: 'Arrow Up', keywords: ['top', 'scroll', 'increase'] },
            { token: 'ph-arrow-down', label: 'Arrow Down', keywords: ['bottom', 'scroll', 'decrease'] },
            { token: 'ph-caret-left', label: 'Caret Left', keywords: ['previous', 'back', 'nav'] },
            { token: 'ph-caret-right', label: 'Caret Right', keywords: ['next', 'forward', 'nav'] },
            { token: 'ph-caret-up', label: 'Caret Up', keywords: ['expand', 'show', 'nav'] },
            { token: 'ph-caret-down', label: 'Caret Down', keywords: ['dropdown', 'expand', 'nav'] },
            { token: 'ph-house', label: 'House', keywords: ['home', 'main', 'start'] },
            { token: 'ph-house-line', label: 'House Line', keywords: ['overview', 'landing', 'summary', 'home'] },
            { token: 'ph-compass', label: 'Compass', keywords: ['navigation', 'explore', 'direction'] },
            { token: 'ph-map-pin', label: 'Map Pin', keywords: ['location', 'marker', 'place'] },
            { token: 'ph-map-trifold', label: 'Map Trifold', keywords: ['location', 'routes', 'navigation', 'geography'] },
            { token: 'ph-navigation-arrow', label: 'Navigation Arrow', keywords: ['direction', 'gps', 'location'] },

            // Search & View
            { token: 'ph-magnifying-glass', label: 'Search', keywords: ['find', 'search', 'look'] },
            { token: 'ph-magnifying-glass-plus', label: 'Zoom In', keywords: ['enlarge', 'magnify', 'expand'] },
            { token: 'ph-magnifying-glass-minus', label: 'Zoom Out', keywords: ['reduce', 'shrink', 'minimize'] },
            { token: 'ph-eye', label: 'Eye', keywords: ['view', 'see', 'preview'] },
            { token: 'ph-eye-closed', label: 'Eye Closed', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-eye-slash', label: 'Eye Slash', keywords: ['hide', 'hidden', 'invisible'] },
            { token: 'ph-binoculars', label: 'Binoculars', keywords: ['search', 'find', 'explore'] },
            { token: 'ph-funnel', label: 'Funnel', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-funnel-simple', label: 'Funnel Simple', keywords: ['filter', 'sort', 'refine'] },
            { token: 'ph-sliders', label: 'Sliders', keywords: ['settings', 'adjust', 'control'] },
            { token: 'ph-sliders-horizontal', label: 'Sliders Horizontal', keywords: ['settings', 'adjust', 'filter'] },
            { token: 'ph-adjustments', label: 'Adjustments', keywords: ['settings', 'controls', 'tune'] },

            // Business & Work
            { token: 'ph-briefcase', label: 'Briefcase', keywords: ['portfolio', 'business', 'clients', 'work'] },
            { token: 'ph-suitcase', label: 'Suitcase', keywords: ['travel', 'business', 'luggage'] },
            { token: 'ph-bank', label: 'Bank', keywords: ['finance', 'money', 'institution'] },
            { token: 'ph-buildings', label: 'Buildings', keywords: ['city', 'office', 'company'] },
            { token: 'ph-storefront', label: 'Storefront', keywords: ['shop', 'store', 'retail'] },
            { token: 'ph-shopping-bag', label: 'Shopping Bag', keywords: ['purchase', 'buy', 'retail'] },
            { token: 'ph-shopping-cart', label: 'Shopping Cart', keywords: ['sales', 'store', 'orders', 'ecommerce'] },
            { token: 'ph-shopping-cart-simple', label: 'Cart Simple', keywords: ['purchase', 'buy', 'shop'] },
            { token: 'ph-currency-dollar', label: 'Dollar', keywords: ['money', 'price', 'payment'] },
            { token: 'ph-money', label: 'Money', keywords: ['cash', 'payment', 'finance'] },
            { token: 'ph-credit-card', label: 'Credit Card', keywords: ['payment', 'transaction', 'purchase'] },
            { token: 'ph-coin', label: 'Coin', keywords: ['money', 'currency', 'payment'] },
            { token: 'ph-receipt', label: 'Receipt', keywords: ['invoice', 'payment', 'transaction'] },
            { token: 'ph-invoice', label: 'Invoice', keywords: ['bill', 'payment', 'receipt'] },
            { token: 'ph-wallet', label: 'Wallet', keywords: ['money', 'payment', 'finance'] },

            // Analytics & Data
            { token: 'ph-chart-line', label: 'Chart Line', keywords: ['metrics', 'reporting', 'dash', 'analytics', 'graph'] },
            { token: 'ph-chart-bar', label: 'Chart Bar', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-bar-horizontal', label: 'Chart Bar Horizontal', keywords: ['graph', 'statistics', 'data'] },
            { token: 'ph-chart-pie', label: 'Chart Pie', keywords: ['graph', 'statistics', 'distribution'] },
            { token: 'ph-chart-pie-slice', label: 'Chart Pie Slice', keywords: ['graph', 'statistics', 'portion'] },
            { token: 'ph-chart-line-up', label: 'Chart Line Up', keywords: ['growth', 'increase', 'trending'] },
            { token: 'ph-chart-line-down', label: 'Chart Line Down', keywords: ['decrease', 'decline', 'trending'] },
            { token: 'ph-trend-up', label: 'Trend Up', keywords: ['growth', 'increase', 'positive'] },
            { token: 'ph-trend-down', label: 'Trend Down', keywords: ['decrease', 'decline', 'negative'] },
            { token: 'ph-presentation', label: 'Presentation', keywords: ['slides', 'meeting', 'report'] },
            { token: 'ph-presentation-chart', label: 'Presentation Chart', keywords: ['slides', 'analytics', 'report'] },

            // Tech & Development
            { token: 'ph-code', label: 'Code', keywords: ['development', 'programming', 'developer'] },
            { token: 'ph-terminal', label: 'Terminal', keywords: ['console', 'command', 'cli'] },
            { token: 'ph-terminal-window', label: 'Terminal Window', keywords: ['console', 'command', 'shell'] },
            { token: 'ph-brackets-curly', label: 'Brackets Curly', keywords: ['code', 'json', 'programming'] },
            { token: 'ph-bug', label: 'Bug', keywords: ['error', 'issue', 'debug'] },
            { token: 'ph-cpu', label: 'CPU', keywords: ['processor', 'hardware', 'computing'] },
            { token: 'ph-hard-drive', label: 'Hard Drive', keywords: ['storage', 'disk', 'data'] },
            { token: 'ph-database', label: 'Database', keywords: ['storage', 'records', 'warehouse', 'data'] },
            { token: 'ph-server', label: 'Server', keywords: ['database', 'hosting', 'backend'] },
            { token: 'ph-cloud', label: 'Cloud', keywords: ['sync', 'storage', 'backup', 'online'] },
            { token: 'ph-cloud-arrow-up', label: 'Cloud Upload', keywords: ['sync', 'upload', 'backup'] },
            { token: 'ph-cloud-arrow-down', label: 'Cloud Download', keywords: ['sync', 'download', 'retrieve'] },
            { token: 'ph-git-branch', label: 'Git Branch', keywords: ['version', 'control', 'code'] },
            { token: 'ph-git-commit', label: 'Git Commit', keywords: ['version', 'control', 'save'] },
            { token: 'ph-git-merge', label: 'Git Merge', keywords: ['version', 'control', 'combine'] },
            { token: 'ph-github-logo', label: 'GitHub', keywords: ['code', 'repository', 'git'] },

            // Security
            { token: 'ph-lock', label: 'Lock', keywords: ['security', 'private', 'secure'] },
            { token: 'ph-lock-key', label: 'Lock Key', keywords: ['permissions', 'security', 'access', 'roles'] },
            { token: 'ph-lock-open', label: 'Lock Open', keywords: ['unlock', 'access', 'open'] },
            { token: 'ph-key', label: 'Key', keywords: ['password', 'access', 'security'] },
            { token: 'ph-shield', label: 'Shield', keywords: ['security', 'protection', 'safety'] },
            { token: 'ph-shield-check', label: 'Shield Check', keywords: ['security', 'verified', 'protected'] },
            { token: 'ph-fingerprint', label: 'Fingerprint', keywords: ['biometric', 'security', 'identity'] },
            { token: 'ph-password', label: 'Password', keywords: ['security', 'login', 'access'] },

            // Media & Design
            { token: 'ph-image', label: 'Image', keywords: ['photo', 'picture', 'media'] },
            { token: 'ph-images', label: 'Images', keywords: ['photos', 'gallery', 'media'] },
            { token: 'ph-camera', label: 'Camera', keywords: ['photo', 'picture', 'capture'] },
            { token: 'ph-video-camera', label: 'Video Camera', keywords: ['recording', 'film', 'media'] },
            { token: 'ph-play', label: 'Play', keywords: ['video', 'start', 'media'] },
            { token: 'ph-pause', label: 'Pause', keywords: ['stop', 'media', 'video'] },
            { token: 'ph-film-strip', label: 'Film Strip', keywords: ['video', 'movie', 'cinema'] },
            { token: 'ph-music-notes', label: 'Music Notes', keywords: ['audio', 'sound', 'song'] },
            { token: 'ph-palette', label: 'Palette', keywords: ['color', 'design', 'art'] },
            { token: 'ph-paint-brush', label: 'Paint Brush', keywords: ['design', 'art', 'draw'] },
            { token: 'ph-paint-roller', label: 'Paint Roller', keywords: ['design', 'theme', 'style'] },
            { token: 'ph-eyedropper', label: 'Eyedropper', keywords: ['color', 'picker', 'design'] },

            // Symbols & Shapes
            { token: 'ph-star', label: 'Star', keywords: ['favorite', 'rating', 'important'] },
            { token: 'ph-heart', label: 'Heart', keywords: ['like', 'favorite', 'love'] },
            { token: 'ph-flag', label: 'Flag', keywords: ['marker', 'important', 'report'] },
            { token: 'ph-bookmark', label: 'Bookmark', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-bookmark-simple', label: 'Bookmark Simple', keywords: ['save', 'favorite', 'mark'] },
            { token: 'ph-tag', label: 'Tag', keywords: ['labels', 'categories', 'taxonomy', 'label'] },
            { token: 'ph-hash', label: 'Hash', keywords: ['hashtag', 'number', 'tag'] },
            { token: 'ph-at', label: 'At', keywords: ['mention', 'email', 'address'] },
            { token: 'ph-info', label: 'Info', keywords: ['information', 'help', 'about'] },
            { token: 'ph-question', label: 'Question', keywords: ['help', 'faq', 'support'] },
            { token: 'ph-warning', label: 'Warning', keywords: ['alert', 'caution', 'danger'] },
            { token: 'ph-warning-circle', label: 'Warning Circle', keywords: ['alert', 'caution', 'error'] },
            { token: 'ph-prohibit', label: 'Prohibit', keywords: ['blocked', 'forbidden', 'no'] },
            { token: 'ph-circle', label: 'Circle', keywords: ['shape', 'dot', 'round'] },
            { token: 'ph-square', label: 'Square', keywords: ['shape', 'box', 'rectangle'] },
            { token: 'ph-triangle', label: 'Triangle', keywords: ['shape', 'arrow', 'pointer'] },
            { token: 'ph-diamond', label: 'Diamond', keywords: ['shape', 'gem', 'special'] },

            // Actions & Ideas
            { token: 'ph-rocket', label: 'Rocket', keywords: ['project', 'ship', 'release', 'launch'] },
            { token: 'ph-rocket-launch', label: 'Rocket Launch', keywords: ['start', 'deploy', 'begin'] },
            { token: 'ph-lightbulb', label: 'Lightbulb', keywords: ['brainstorm', 'concepts', 'innovation', 'ideas'] },
            { token: 'ph-target', label: 'Target', keywords: ['goal', 'objective', 'aim'] },
            { token: 'ph-trophy', label: 'Trophy', keywords: ['achievement', 'success', 'award'] },
            { token: 'ph-medal', label: 'Medal', keywords: ['award', 'achievement', 'winner'] },
            { token: 'ph-gift', label: 'Gift', keywords: ['present', 'reward', 'bonus'] },
            { token: 'ph-crown', label: 'Crown', keywords: ['premium', 'vip', 'royal'] },
            { token: 'ph-magic-wand', label: 'Magic Wand', keywords: ['auto', 'ai', 'magic'] },
            { token: 'ph-sparkle', label: 'Sparkle', keywords: ['new', 'special', 'shine'] },
            { token: 'ph-lightning', label: 'Lightning', keywords: ['fast', 'quick', 'speed'] },
            { token: 'ph-fire', label: 'Fire', keywords: ['hot', 'trending', 'popular'] },

            // Connectivity & Links
            { token: 'ph-link', label: 'Link', keywords: ['url', 'connection', 'attach'] },
            { token: 'ph-link-simple', label: 'Link Simple', keywords: ['connection', 'attach', 'url', 'hyperlink'] },
            { token: 'ph-link-break', label: 'Link Break', keywords: ['unlink', 'disconnect', 'remove'] },
            { token: 'ph-paperclip', label: 'Paperclip', keywords: ['attach', 'file', 'attachment'] },
            { token: 'ph-anchor', label: 'Anchor', keywords: ['link', 'fixed', 'permanent'] },
            { token: 'ph-wireless', label: 'Wireless', keywords: ['wifi', 'connection', 'network'] },
            { token: 'ph-wifi-high', label: 'WiFi High', keywords: ['wireless', 'connection', 'network'] },
            { token: 'ph-globe', label: 'Globe', keywords: ['world', 'internet', 'global'] },
            { token: 'ph-globe-hemisphere-west', label: 'Globe West', keywords: ['world', 'map', 'earth'] },

            // Settings & Configuration
            { token: 'ph-gear', label: 'Gear', keywords: ['settings', 'configuration', 'options'] },
            { token: 'ph-gear-six', label: 'Gear Six', keywords: ['settings', 'config', 'preferences'] },
            { token: 'ph-wrench', label: 'Wrench', keywords: ['tools', 'fix', 'maintenance'] },
            { token: 'ph-nut', label: 'Nut', keywords: ['settings', 'configuration', 'hardware'] },
            { token: 'ph-faders', label: 'Faders', keywords: ['settings', 'adjust', 'mixer'] },
            { token: 'ph-toggle-left', label: 'Toggle Left', keywords: ['switch', 'off', 'disable'] },
            { token: 'ph-toggle-right', label: 'Toggle Right', keywords: ['switch', 'on', 'enable'] },

            // Miscellaneous
            { token: 'ph-smiley', label: 'Smiley', keywords: ['emoji', 'happy', 'face'] },
            { token: 'ph-package', label: 'Package', keywords: ['box', 'delivery', 'product'] },
            { token: 'ph-cube', label: 'Cube', keywords: ['3d', 'box', 'object'] },
            { token: 'ph-puzzle-piece', label: 'Puzzle Piece', keywords: ['plugin', 'extension', 'addon'] },
            { token: 'ph-tree', label: 'Tree', keywords: ['nature', 'hierarchy', 'branch'] },
            { token: 'ph-plant', label: 'Plant', keywords: ['nature', 'growing', 'organic'] }
        ];

        const ICONS_PER_PAGE = 60;

        function renderIcon(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            if (trimmed.startsWith('<')) return trimmed;
            if (trimmed.startsWith('ph ')) return `<i class="${trimmed}"></i>`;
            if (trimmed.startsWith('ph-')) return `<i class="ph ${trimmed}"></i>`;
            return trimmed;
        }

        function cloneConfig(config) {
            if (typeof structuredClone === 'function') return structuredClone(config || null);
            return JSON.parse(JSON.stringify(config || null));
        }

        function extractIconToken(icon) {
            if (!icon) return '';
            const trimmed = icon.toString().trim();
            const match = trimmed.match(/ph-[\w-]+/);
            if (match) return match[0];
            return trimmed;
        }

        function buildIconSearchText(option) {
            const keywords = (option.keywords || []).join(' ');
            return `${option.label} ${option.token} ${keywords}`.toLowerCase();
        }

        function fuzzyScore(query, text) {
            const normalizedQuery = (query || '').trim().toLowerCase();
            if (!normalizedQuery) return 1;
            const normalizedText = text.toLowerCase();
            const parts = normalizedQuery.split(/\s+/).filter(Boolean);

            let score = 0;
            parts.forEach(part => {
                if (normalizedText.includes(part)) {
                    score += 2;
                    return;
                }

                let lastIndex = -1;
                let subsequenceScore = 0;
                for (const char of part) {
                    const idx = normalizedText.indexOf(char, lastIndex + 1);
                    if (idx === -1) { subsequenceScore = 0; break; }
                    const distance = lastIndex === -1 ? 0 : idx - lastIndex - 1;
                    subsequenceScore += Math.max(0.1, 1 - distance * 0.08);
                    lastIndex = idx;
                }
                if (subsequenceScore > 0) {
                    const proximityBoost = Math.min(0.5, part.length / 12);
                    score += (subsequenceScore / part.length) + proximityBoost;
                }
            });

            return score / parts.length;
        }

        function findIconMeta(token) {
            const clean = extractIconToken(token);
            return ICON_OPTIONS.find(opt => opt.token === clean);
        }

        const ICON_SELECTOR_TARGETS = {
            newSetIcon: { selectorId: 'newSetIconSelector', previewId: 'newSetIconPreview', tokenId: 'newSetIconToken' },
            newViewIcon: { selectorId: 'newViewIconSelector', previewId: 'newViewIconPreview', tokenId: 'newViewIconToken' }
        };

        function syncIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            const input = document.getElementById(inputId);
            if (!config || !input) return;
            const token = extractIconToken(input.value || '');
            const meta = findIconMeta(token);
            const preview = document.getElementById(config.previewId);
            if (preview) preview.innerHTML = renderIcon(token || 'ph-squares-four');
            const tokenLabel = document.getElementById(config.tokenId);
            if (tokenLabel) tokenLabel.textContent = meta ? `${meta.label}  ${meta.token}` : (token || 'Select an icon');
        }

        function bindIconSelector(inputId) {
            const config = ICON_SELECTOR_TARGETS[inputId];
            if (!config) return;
            const selector = document.getElementById(config.selectorId);
            if (selector) {
                const trigger = () => openIconPicker(inputId);
                selector.onclick = trigger;
                selector.onkeydown = (event) => {
                    if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
                        event.preventDefault();
                        trigger();
                    }
                };
            }
            const input = document.getElementById(inputId);
            if (input) input.addEventListener('change', () => syncIconSelector(inputId));
            syncIconSelector(inputId);
        }

        function openIconPicker(targetInputId) {
            state.iconPickerTarget = targetInputId;
            state.iconPickerQuery = '';
            state.iconPickerPage = 1;
            const searchInput = document.getElementById('iconPickerSearch');
            if (searchInput) {
                searchInput.value = '';
                setTimeout(() => searchInput.focus(), 50);
            }
            renderIconPickerOptions();
            openModal('iconPickerModal');
        }

        function renderIconPickerOptions() {
            const container = document.getElementById('iconPickerOptions');
            const pagination = document.getElementById('iconPickerPagination');
            if (!container) return;
            const search = (state.iconPickerQuery || '').toLowerCase();
            const currentValue = state.iconPickerTarget ? extractIconToken(document.getElementById(state.iconPickerTarget)?.value || '') : '';

            container.innerHTML = '';
            if (pagination) pagination.innerHTML = '';

            const scored = ICON_OPTIONS
                .map(opt => ({ ...opt, score: fuzzyScore(search, buildIconSearchText(opt)) }))
                .filter(entry => entry.score > 0)
                .sort((a, b) => b.score - a.score);

            if (scored.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No icons match your search. Try a related term like table or board.</p>';
                return;
            }

            const totalPages = Math.max(1, Math.ceil(scored.length / ICONS_PER_PAGE));
            state.iconPickerPage = Math.min(Math.max(state.iconPickerPage, 1), totalPages);
            const startIndex = (state.iconPickerPage - 1) * ICONS_PER_PAGE;
            const pagedIcons = scored.slice(startIndex, startIndex + ICONS_PER_PAGE);

            if (pagination) {
                pagination.innerHTML = `
                    <span class="icon-pagination-count">${scored.length} icons</span>
                    <div class="icon-pagination-buttons">
                        <button type="button" class="icon-page-btn" data-direction="prev" ${state.iconPickerPage === 1 ? 'disabled' : ''}>Prev</button>
                        <span class="text-sm text-gray-600">Page ${state.iconPickerPage} / ${totalPages}</span>
                        <button type="button" class="icon-page-btn" data-direction="next" ${state.iconPickerPage === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                `;

                pagination.querySelectorAll('.icon-page-btn').forEach(btn => {
                    btn.onclick = () => {
                        const direction = btn.getAttribute('data-direction');
                        if (direction === 'prev' && state.iconPickerPage > 1) {
                            state.iconPickerPage -= 1;
                        } else if (direction === 'next' && state.iconPickerPage < totalPages) {
                            state.iconPickerPage += 1;
                        }
                        renderIconPickerOptions();
                    };
                });
            }

            pagedIcons.forEach(opt => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `icon-option${opt.token === currentValue ? ' active' : ''}`;
                btn.setAttribute('aria-label', opt.label);
                btn.innerHTML = `
                    <span class="icon-chip">${renderIcon(opt.token)}</span>
                    <span class="sr-only">${opt.label}</span>
                `;
                btn.onclick = () => selectIconFromPicker(opt.token);
                container.appendChild(btn);
            });
        }

        function selectIconFromPicker(token) {
            if (state.iconPickerTarget) {
                const input = document.getElementById(state.iconPickerTarget);
                if (input) {
                    input.value = token;
                    input.dispatchEvent(new Event('change'));
                }
            }
            closeModal('iconPickerModal');
        }

        const EO_OPERATOR_SET = {
            INS: { id: 'INS', name: 'Instantiate', description: 'Create a new object that did not exist before.' },
            DES: { id: 'DES', name: 'Designate', description: 'Assign a name, ID, label, alias, or classification.' },
            SEG: { id: 'SEG', name: 'Segment', description: 'Change boundaries, structure, or partition membership.' },
            CON: { id: 'CON', name: 'Connect', description: 'Create or remove a connection between objects.' },
            ALT: { id: 'ALT', name: 'Alternate', description: 'Toggle or switch between mutually exclusive states.' },
            SYN: { id: 'SYN', name: 'Synthesize', description: 'Combine two or more objects into a new unified whole.' },
            SUP: { id: 'SUP', name: 'Superposition', description: 'Hold contradictory states as simultaneously true without resolving them.' },
            REC: { id: 'REC', name: 'Recurse', description: 'Introduce a new layer of logic, rules, or self-reference.' },
            NUL: { id: 'NUL', name: 'Nullify', description: 'Declare absence, deletion, or erasure.' }
        };

        function getModesForOperator(operator) {
            return state.connectionModes?.[operator] || [];
        }

        function normalizeParamList(params = []) {
            if (params === undefined || params === null) return [];
            if (!Array.isArray(params)) throw new Error('Parameter lists must be arrays');

            return Array.from(
                new Set(
                    params
                        .map(param => typeof param === 'string' ? param.trim() : String(param || '').trim())
                        .filter(Boolean)
                )
            );
        }

        function validateConnectionRelationPayload(relation) {
            const modes = getModesForOperator(relation?.operator);
            if (!modes.length) throw new Error('Invalid operator');
            if (!modes.includes(relation?.mode)) throw new Error('Invalid mode for operator');

            const requiredParams = normalizeParamList(relation.requiredParams || []);
            const optionalParams = normalizeParamList(relation.optionalParams || []);
            const worldId = relation.worldId || state.currentWorldId;

            return {
                ...relation,
                id: relation.id || `REL_${relation.operator}_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
                operator: relation.operator,
                mode: relation.mode,
                name: relation.name || '',
                description: relation.description || '',
                requiredParams,
                optionalParams,
                createdAt: relation.createdAt || new Date().toISOString(),
                worldId
            };
        }

        function addConnectionRelation(relation) {
            let payload;
            try {
                payload = validateConnectionRelationPayload(relation);
            } catch (error) {
                showToast(` ${error.message || 'Unable to create connection relation'}`);
                return null;
            }

            state.connectionRelations.set(payload.id, payload);
            return payload.id;
        }

        function updateConnectionRelation(relationId, updates = {}) {
            const existing = state.connectionRelations.get(relationId);
            if (!existing) throw new Error(`Connection relation ${relationId} not found`);

            const merged = validateConnectionRelationPayload({ ...existing, ...updates, id: relationId });
            state.connectionRelations.set(relationId, { ...existing, ...merged, updatedAt: new Date().toISOString() });
            return relationId;
        }

        function deleteConnectionRelation(relationId) {
            if (!state.connectionRelations.has(relationId)) throw new Error(`Connection relation ${relationId} not found`);
            const inUse = Array.from(state.connections.values()).some(conn => conn.relationId === relationId);
            if (inUse) throw new Error('Cannot delete a relation that is used by existing relationships');
            state.connectionRelations.delete(relationId);
            return relationId;
        }

        function getConnectionRelationView(filterFn) {
            const relations = Array.from(state.connectionRelations.values()).filter(rel => !rel.worldId || rel.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? relations.filter(filterFn) : relations;
        }

        function findConnectionRelation(relationId) {
            return state.connectionRelations.get(relationId) || null;
        }

        function getDefaultConnectionRelationId(preferredOperator = null) {
            const relations = getConnectionRelationView(rel => !preferredOperator || rel.operator === preferredOperator);
            return relations.length ? relations[0].id : null;
        }

        function suggestFormatsForView(view) {
            const suggestions = [];

            if (view?.filters?.length) {
                suggestions.push('SEG');
            }

            if (view?.aggregationRules?.length) {
                suggestions.push('SYN');
            }

            if (view?.pivotField) {
                suggestions.push('SUP');
            }

            return suggestions;
        }

        // DEFINITIONS & CONNECTIONS
        function deriveWorldIdForEntity(entity) {
            if (!entity) return state.currentWorldId;
            if (entity.type === 'Record') {
                const ref = getRecordById(entity.id);
                if (ref?.set?.worldId) return ref.set.worldId;
            }
            if (entity.type === 'Set') {
                const set = state.sets.get(entity.id);
                if (set?.worldId) return set.worldId;
            }
            if (entity.type === 'Connection') {
                const existing = state.connections.get(entity.id);
                if (existing?.worldId) return existing.worldId;
            }
            return state.currentWorldId;
        }

        function findDefinitionByEntity(entity, worldId = state.currentWorldId) {
            if (!entity) return null;
            return Array.from(state.definitions.values()).find(def =>
                def.entity?.type === entity.type &&
                def.entity?.id === entity.id &&
                (!worldId || !def.worldId || def.worldId === worldId)
            ) || null;
        }

        function renderEntityLabel(entity) {
            if (!entity) return '';
            const def = findDefinitionByEntity(entity);
            if (def?.term) return def.term;

            if (entity.type === 'Record') {
                const displayName = getRecordDisplayName(entity.id);
                if (displayName) return displayName;
                // Fall back to set name if available
                const ref = getRecordById(entity.id);
                if (ref?.set?.name) return ref.set.name;
                return 'Record';
            }
            if (entity.type === 'Set') {
                return state.sets.get(entity.id)?.name || 'Set';
            }
            if (entity.type === 'Connection') {
                const conn = state.connections.get(entity.id);
                if (conn) return `${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}`;
            }
            return entity.type || 'Entity';
        }

        function addDefinition(def) {
            if (!def?.entity || !def?.entity?.type || !def?.entity?.id) {
                throw new Error('Definitions require an entity with type and id');
            }
            if (!def.term || !def.definition) {
                throw new Error('Definitions require both term and definition text');
            }

            const id = def.id || `def_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            const worldId = def.worldId || deriveWorldIdForEntity(def.entity);
            const payload = {
                ...def,
                id,
                worldId,
                tags: def.tags || [],
                createdAt: def.createdAt || new Date().toISOString()
            };

            state.definitions.set(id, payload);

            // Register definition as an entity for tracking
            registerEntity({
                id: payload.id,
                type: 'Definition',
                entityType: 'Definition',
                name: payload.term,
                worldId: payload.worldId,
                createdAt: payload.createdAt,
                origin: 'manual'
            });

            return payload;
        }

        function updateDefinition(id, updates = {}) {
            const existing = state.definitions.get(id);
            if (!existing) throw new Error(`Definition ${id} not found`);

            const next = {
                ...existing,
                ...updates,
                id,
                updatedAt: new Date().toISOString()
            };

            state.definitions.set(id, next);
            return next;
        }

        function deleteDefinition(id) {
            const existing = state.definitions.get(id);
            if (!existing) throw new Error(`Definition ${id} not found`);
            state.definitions.delete(id);
            return existing;
        }

        function getDefinitionView(filterFn) {
            const defs = Array.from(state.definitions.values()).filter(def => !def.worldId || def.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? defs.filter(filterFn) : defs;
        }

        function getConnectionView(filterFn) {
            const conns = Array.from(state.connections.values()).filter(conn => !conn.worldId || conn.worldId === state.currentWorldId);
            return typeof filterFn === 'function' ? conns.filter(filterFn) : conns;
        }

        function seedWorldDefaults(worldId = state.currentWorldId) {
            const locationsId = createSet('Locations', 'ph-map-pin', worldId);
            const locationsSet = state.sets.get(locationsId);
            locationsSet.schema = [
                { id: 'name', name: 'Location', type: 'TEXT', width: '220px' },
                { id: 'area', name: 'Area', type: 'TEXT', width: '180px' },
                { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '260px' }
            ];

            const observationsId = createSet('Observations', 'ph-binoculars', worldId);
            const observationsSet = state.sets.get(observationsId);
            observationsSet.schema = [
                { id: 'date', name: 'Date', type: 'DATE', width: '140px' },
                { id: 'observer', name: 'Observer', type: 'TEXT', width: '180px' },
                { id: 'observation', name: 'Observation', type: 'LONG_TEXT', width: '260px' }
            ];

            createView(locationsId, 'Locations', { type: 'grid', sorts: [{ fieldId: 'name', direction: 'asc' }] });
            createView(observationsId, 'Observations', { type: 'grid', sorts: [{ fieldId: 'date', direction: 'desc' }] });

            return { locationsId, observationsId };
        }

        // INITIALIZATION
        async function initializeApp() {
            state.operatorSet = EO_OPERATOR_SET;

            // Initialize lean context system
            if (typeof EOLeanContext !== 'undefined') {
                state.leanContext = new EOLeanContext();
                console.log(' Lean Context System initialized');
            }

            initializeOperatorRules();
            await loadConnectionModes();
            createSampleData();
            applyRouteParams();
            renderWorldSelector();
            renderSidebar();
            initializeNavSections();
            if (state.currentSpecialView) {
                renderCurrentView();
            } else if (state.currentSetId) {
                switchSet(state.currentSetId, state.currentViewId);
            } else {
                // Default to dashboard if no other view is specified
                state.currentSpecialView = 'dashboard';
                renderCurrentView();
            }
            setupEventListeners();
            setupKeyboardShortcuts();
            applyResponsiveLayout();
            window.addEventListener('resize', applyResponsiveLayout);
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function normalizeOperatorModeDictionary(data) {
            if (!data || typeof data !== 'object' || Array.isArray(data)) return {};

            const normalized = {};
            Object.entries(data).forEach(([op, modes]) => {
                if (!Array.isArray(modes)) return;
                const cleaned = modes.map(mode => typeof mode === 'string' ? mode.trim() : '').filter(Boolean);
                if (cleaned.length) normalized[op] = cleaned;
            });

            return normalized;
        }

        async function loadConnectionModes() {
            try {
                const response = await fetch('data/connection_modes.json');
                if (!response.ok) throw new Error('Unable to load operator dictionary');

                const rawModes = await response.json();
                state.connectionModes = normalizeOperatorModeDictionary(rawModes);
            } catch (error) {
                console.warn('Unable to load connection modes', error);
                state.connectionModes = {};
            }
        }

        function readRouteParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                worldId: params.get('world'),
                setId: params.get('set'),
                viewId: params.get('view'),
                special: params.get('special')
            };
        }

        function applyRouteParams() {
            const route = readRouteParams();
            if (route.worldId && state.worlds.has(route.worldId)) {
                state.currentWorldId = route.worldId;
            }

            if (route.special) {
                state.currentSpecialView = route.special;
                state.currentSetId = null;
                state.currentViewId = null;
                return;
            }

            if (route.setId && state.sets.has(route.setId)) {
                state.currentSetId = route.setId;
                const set = state.sets.get(route.setId);
                if (route.viewId && set.views.has(route.viewId)) {
                    state.currentViewId = route.viewId;
                } else if (set.views.size > 0) {
                    state.currentViewId = Array.from(set.views.keys())[0];
                }
            }
        }

        function syncUrlState() {
            const params = new URLSearchParams();
            if (state.currentWorldId) params.set('world', state.currentWorldId);

            if (state.currentSpecialView) {
                params.set('special', state.currentSpecialView);
            } else {
                if (state.currentSetId) params.set('set', state.currentSetId);
                if (state.currentViewId) params.set('view', state.currentViewId);
            }

            const query = params.toString();
            const nextUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
            window.history.replaceState({}, '', nextUrl);
        }

        function applyResponsiveLayout() {
            const appContainer = document.getElementById('appContainer');
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            const bottomBar = document.getElementById('mobileBottomBar');
            const fab = document.getElementById('mobileFab');
            const topbar = document.getElementById('mobileTopbar');

            if (isMobile) {
                appContainer.classList.add('mobile-layout');
                appContainer.classList.toggle('sidebar-open-mobile', state.sidebarOpenMobile);
                appContainer.classList.remove('sidebar-collapsed');
                bottomBar?.classList.remove('hidden');
                fab?.classList.remove('hidden');
                topbar?.classList.remove('hidden');
            } else {
                appContainer.classList.remove('mobile-layout');
                appContainer.classList.remove('sidebar-open-mobile');
                appContainer.classList.toggle('sidebar-collapsed', state.sidebarCollapsed);
                bottomBar?.classList.add('hidden');
                fab?.classList.add('hidden');
                topbar?.classList.add('hidden');
            }

            updateMobileChrome();
        }

        function updateMobileChrome() {
            const titleEl = document.getElementById('mobileTopbarTitle');
            const set = getCurrentSet();
            const view = getCurrentView();
            const special = state.currentSpecialView === 'definitions'
                ? 'Definitions'
                : state.currentSpecialView === 'relations'
                    ? 'Relations'
                    : state.currentSpecialView === 'entities'
                        ? 'Entities'
                        : null;

            if (titleEl) titleEl.textContent = special || set?.name || 'EO';

            document.querySelectorAll('.mobile-bottom-action').forEach(btn => {
                const type = btn.dataset.mobileNav;
                if (!type) return;
                btn.classList.toggle('active', !special && view?.type === type);
            });
        }

        let toolbarMenuCleanup = null;
        function setupToolbarMenu() {
            if (typeof toolbarMenuCleanup === 'function') {
                toolbarMenuCleanup();
                toolbarMenuCleanup = null;
            }

            const menu = document.querySelector('.toolbar-menu');
            const toggle = document.getElementById('toolbarMenuToggle');
            const panel = document.getElementById('toolbarMenuPanel');
            if (!menu || !toggle || !panel) return;

            const closeMenu = () => menu.classList.remove('open');

            const toggleHandler = (event) => {
                event.stopPropagation();
                menu.classList.toggle('open');
            };

            const panelHandler = (event) => {
                event.stopPropagation();
                if (event.target.closest('button')) closeMenu();
            };

            const clickHandler = (event) => {
                if (!menu.contains(event.target)) closeMenu();
            };

            const keydownHandler = (event) => {
                if (event.key === 'Escape') closeMenu();
            };

            toggle.addEventListener('click', toggleHandler);
            panel.addEventListener('click', panelHandler);
            document.addEventListener('click', clickHandler);
            document.addEventListener('keydown', keydownHandler);

            toolbarMenuCleanup = () => {
                toggle.removeEventListener('click', toggleHandler);
                panel.removeEventListener('click', panelHandler);
                document.removeEventListener('click', clickHandler);
                document.removeEventListener('keydown', keydownHandler);
            };
        }

        function handleAddRecord() {
            const set = getCurrentSet();
            if (!set) return;

            // Clear selection state to prevent restoration
            state.selectedCell = null;
            state.lastSelectedCell = null;
            state.editingCell = null;

            const record = { id: `rec_${Date.now()}` };
            set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);

            // If on a filtered view, pre-populate the record with filter values
            // so it's immediately visible after creation
            const view = getCurrentView();
            if (view && view.filters && view.filters.length > 0) {
                // Use the first filter group to populate values
                const firstGroup = view.filters[0];
                const rules = firstGroup.filter(r => r.field);
                rules.forEach(rule => {
                    if (rule.field && rule.value !== undefined) {
                        record[rule.field] = rule.value;
                    }
                });
            }

            set.records.set(record.id, record);

            // Track the new record for auto-focus after render
            state.newlyAddedRecordId = record.id;

            renderCurrentView();
            showToast(' Record added');
        }

        function wireViewStageActions() {
            const addRecordBtn = document.getElementById('addRecordBtn');
            if (addRecordBtn) addRecordBtn.onclick = handleAddRecord;

            const addFieldBtn = document.getElementById('addFieldBtn');
            if (addFieldBtn) addFieldBtn.onclick = openAddFieldModal;

            const addLinkedFieldsBtn = document.getElementById('addLinkedFieldsBtn');
            if (addLinkedFieldsBtn) addLinkedFieldsBtn.onclick = openLinkedFieldsModal;

            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) filterBtn.onclick = openFilterModal;

            const sortBtn = document.getElementById('sortBtn');
            if (sortBtn) sortBtn.onclick = openSortModal;

            const visualizeBtn = document.getElementById('visualizeBtn');
            if (visualizeBtn) visualizeBtn.onclick = openVisualizationModal;

            const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
            if (deleteSelectedBtn) deleteSelectedBtn.onclick = handleDeleteSelectedRecords;

            const reifyBtn = document.getElementById('reifyViewBtn');
            if (reifyBtn) reifyBtn.onclick = reifyCurrentView;

            const reifyRecordsBtn = document.getElementById('reifyRecordsBtn');
            if (reifyRecordsBtn) reifyRecordsBtn.onclick = reifyImportView;

            const toolbarActions = [
                ['popupSettingsBtn', openPopupSettingsModal],
                ['importCsvBtn', openCsvImportModal],
                ['fuzzyPanelBtn', openFuzzyPanel]
            ];

            toolbarActions.forEach(([id, handler]) => {
                const el = document.getElementById(id);
                if (el) el.onclick = handler;
            });
        }

        function renderViewActions(extraControls = '') {
            const view = getCurrentView();
            const isImportView = view && view.isTemporary && view.importMetadata;

            // Add reify button for import views
            const reifyButton = isImportView ? `
                <button id="reifyRecordsBtn" class="btn btn-success btn-sm" style="background: #10b981; border-color: #10b981;">
                    <i class="ph ph-check-circle"></i>
                    Make Permanent
                </button>
            ` : '';

            return `
                <div class="view-stage-actions">
                    ${isImportView ? `
                        <div class="import-banner" style="background: #064e3b; border: 1px solid #10b981; border-radius: 8px; padding: 0.75rem 1rem; margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <i class="ph ph-info" style="font-size: 20px; color: #10b981;"></i>
                                <div>
                                    <div style="font-weight: 600; color: #d1fae5;">Temporary Import</div>
                                    <div style="font-size: 0.875rem; color: #a7f3d0;">
                                        This is a temporary import view. Make it permanent or it will expire in ${Math.ceil((view.importMetadata.expiresAt - Date.now()) / (24 * 60 * 60 * 1000))} days.
                                    </div>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    <div class="toolbar-row">
                        <div class="toolbar-group">
                            <div class="selection-group">
                                <div id="selectionIndicator" class="selection-indicator hidden">
                                    <i class="ph ph-check-square-offset"></i>
                                    <span><span id="selectedCount">0</span> selected</span>
                                </div>
                            </div>
                            <div class="view-stage-inline-actions">
                                ${reifyButton}
                                <button id="filterBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-funnel-simple"></i>
                                    Filter
                                </button>
                                <button id="sortBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-arrows-down-up"></i>
                                    Sort
                                </button>
                                <button id="visualizeBtn" class="btn btn-secondary btn-sm">
                                    <i class="ph ph-chart-bar"></i>
                                    Visualize
                                </button>
                            </div>
                            ${extraControls ? `<div class="toolbar-group">${extraControls}</div>` : ''}
                        </div>
                        <div class="toolbar-group">
                            <button id="addRecordBtn" class="btn btn-primary btn-sm">+ Add Record</button>
                            <button id="addFieldBtn" class="btn btn-secondary btn-sm">+ Add Field</button>
                            <button id="addLinkedFieldsBtn" class="btn btn-secondary btn-sm">
                                <i class="ph ph-link-simple-horizontal"></i>
                                Add Linked Fields
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="openFieldManager()">
                                <i class="ph ph-gear-six text-sm"></i>
                                <span class="ml-1">Fields</span>
                            </button>
                            <div class="toolbar-menu">
                                <button id="toolbarMenuToggle" class="btn btn-secondary btn-sm toolbar-menu-toggle">
                                    <i class="ph ph-dots-three-outline"></i>
                                    Actions
                                </button>
                                <div class="toolbar-menu-panel" id="toolbarMenuPanel">
                                    <button id="popupSettingsBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-gear-six"></i>
                                        Details
                                    </button>
                                    <button id="importCsvBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-upload-simple"></i>
                                        Import CSV
                                    </button>
                                    <div class="toolbar-menu-divider"></div>
                                    <button id="fuzzyPanelBtn" class="btn btn-secondary btn-sm toolbar-menu-item">
                                        <i class="ph ph-graph"></i>
                                        Fuzzy Matches
                                    </button>
                                </div>
                            </div>
                            <button id="deleteSelectedBtn" class="btn btn-danger btn-sm" disabled>
                                <i class="ph ph-trash"></i>
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function finalizeViewStage() {
            wireViewStageActions();
            setupToolbarMenu();
        }

        function triggerPrimaryAction() {
            const addRecordBtn = document.getElementById('addRecordBtn');
            if (addRecordBtn) { addRecordBtn.click(); return; }

            document.getElementById('addFieldBtn')?.click();
        }

        function initializeOperatorRules() {
            const defaultRules = [
                {
                    rule_id: 'rule_ins_requires_object',
                    applies_to_op: 'INS',
                    description: 'Instantiation must target an identifiable object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_events_require_actor',
                    description: 'All events must be attributable to an actor.',
                    effect: 'require_actor'
                },
                {
                    rule_id: 'rule_con_requires_object',
                    applies_to_op: 'CON',
                    description: 'Connections must reference a concrete edge object.',
                    effect: 'require_object_id'
                },
                {
                    rule_id: 'rule_con_requires_endpoints',
                    applies_to_op: 'CON',
                    description: 'Connections must include both source and target references.',
                    effect: 'require_connection_endpoints'
                },
                {
                    rule_id: 'rule_nullify_marks_deleted',
                    applies_to_op: 'NUL',
                    description: 'Nullify operations explicitly mark the object as deleted in the payload.',
                    effect: 'mark_deleted'
                }
            ];

            defaultRules.forEach(rule => registerInterpretationRule(rule, { skipEvent: true }));
        }

        function createSampleData() {
            const defaultWorldId = createWorld('Example World', 'world_example');
            state.currentWorldId = defaultWorldId;
            const worldDefaults = state.worlds.get(defaultWorldId)?.defaults || {};

            const locationsId = worldDefaults.locationsId || createSet('Locations', 'ph-map-pin', defaultWorldId);
            const observationsId = worldDefaults.observationsId || createSet('Observations', 'ph-binoculars', defaultWorldId);

            const locationsSet = state.sets.get(locationsId);
            locationsSet.schema = [
                { id: 'name', name: 'Location', type: 'TEXT', width: '220px' },
                { id: 'area', name: 'Area', type: 'TEXT', width: '180px' },
                { id: 'notes', name: 'Notes', type: 'LONG_TEXT', width: '260px' }
            ];

            locationsSet.records.clear();
            locationsSet.views.clear();
            const ridgeId = addRecord(locationsId, { name: 'Summit Ridge', area: 'Highlands', notes: 'Windy lookout with clean sight lines.' });
            const marshId = addRecord(locationsId, { name: 'Quiet Marsh', area: 'Wetlands', notes: 'Shallow water and dense reeds.' });
            const groveId = addRecord(locationsId, { name: 'North Grove', area: 'Forest Edge', notes: 'Shaded trail with frequent wildlife activity.' });

            createView(locationsId, 'Locations', { type: 'grid', sorts: [{ fieldId: 'name', direction: 'asc' }] });
            createView(locationsId, 'By Area', {
                type: 'KEY_DERIVED',
                key: { setId: locationsId, fieldId: 'area' },
                schema: [
                    { id: 'locationNames', name: 'Locations', type: 'TEXT', sourceFieldId: 'name' },
                    { id: 'notesSummary', name: 'Notes', type: 'LONG_TEXT', sourceFieldId: 'notes' }
                ],
                columnRules: {
                    locationNames: { rule: 'sup_all' },
                    notesSummary: { rule: 'sup_all' }
                }
            });

            const observationsSet = state.sets.get(observationsId);
            observationsSet.schema = [
                { id: 'date', name: 'Date', type: 'DATE', width: '140px' },
                { id: 'location', name: 'Location', type: 'TEXT', width: '200px' },
                { id: 'observer', name: 'Observer', type: 'TEXT', width: '180px' },
                { id: 'observation', name: 'Observation', type: 'LONG_TEXT', width: '260px' }
            ];

            observationsSet.records.clear();
            observationsSet.views.clear();
            const obs1Id = addRecord(observationsId, { date: '2024-04-12', location: 'Summit Ridge', observer: 'M. Ellis', observation: 'Found fresh tracks along the ridge path.' });
            const obs2Id = addRecord(observationsId, { date: '2024-04-13', location: 'Quiet Marsh', observer: 'S. Kaur', observation: 'Low mist over the marsh; water depth at 0.4m.' });
            const obs3Id = addRecord(observationsId, { date: '2024-04-14', location: 'North Grove', observer: 'J. Rivera', observation: 'Pair of hawks circling above the grove at noon.' });
            const obs4Id = addRecord(observationsId, { date: '2024-04-15', location: 'Summit Ridge', observer: 'M. Ellis', observation: 'Clear skies; ridge visibility extends 10km.' });

            createView(observationsId, 'Observations', {
                type: 'grid',
                sorts: [{ fieldId: 'date', direction: 'desc' }]
            });

            createView(observationsId, 'By Location', {
                type: 'KEY_DERIVED',
                key: { setId: observationsId, fieldId: 'location' },
                schema: [
                    { id: 'notes', name: 'Observations', type: 'LONG_TEXT', sourceFieldId: 'observation' },
                    { id: 'observers', name: 'Observers', type: 'TEXT', sourceFieldId: 'observer' },
                    { id: 'latestDate', name: 'Most Recent', type: 'DATE', sourceFieldId: 'date' }
                ],
                columnRules: {
                    notes: { rule: 'sup_all' },
                    observers: { rule: 'sup_all' },
                    latestDate: { rule: 'prefer_newest' }
                }
            });

            createView(observationsId, 'By Observer', {
                type: 'KEY_DERIVED',
                key: { setId: observationsId, fieldId: 'observer' },
                schema: [
                    { id: 'locations', name: 'Locations', type: 'TEXT', sourceFieldId: 'location' },
                    { id: 'notes', name: 'Observations', type: 'LONG_TEXT', sourceFieldId: 'observation' },
                    { id: 'latestDate', name: 'Most Recent', type: 'DATE', sourceFieldId: 'date' }
                ],
                columnRules: {
                    locations: { rule: 'sup_all' },
                    notes: { rule: 'sup_all' },
                    latestDate: { rule: 'prefer_newest' }
                }
            });

            Array.from(state.definitions.values())
                .filter(def => def.worldId === defaultWorldId)
                .forEach(def => state.definitions.delete(def.id));

            Array.from(state.connectionRelations.values())
                .filter(fmt => fmt.worldId === defaultWorldId)
                .forEach(fmt => state.connectionRelations.delete(fmt.id));

            const observationLinkRelationId = addConnectionRelation({
                id: `${defaultWorldId}_format_observation_link`,
                operator: 'CON',
                mode: 'is linked to',
                description: 'Links an observation to its location',
                requiredParams: ['context'],
                optionalParams: ['notes'],
                worldId: defaultWorldId
            });

            if (!observationLinkRelationId) return;

            addDefinition({
                id: `${defaultWorldId}_def_location`,
                entity: { type: 'Record', id: ridgeId },
                term: 'Field Location',
                definition: 'A place where observations are collected in the example world.',
                notes: 'Locations anchor the observation network.',
                tags: ['example', 'location'],
                worldId: defaultWorldId
            });
            addDefinition({
                id: `${defaultWorldId}_def_observation`,
                entity: { type: 'Record', id: obs1Id },
                term: 'Observation Entry',
                definition: 'A single sighting or measurement recorded by an observer.',
                notes: 'Use date and observer to track context.',
                tags: ['example', 'observation'],
                worldId: defaultWorldId
            });
            addDefinition({
                id: `${defaultWorldId}_def_link`,
                entity: { type: 'Connection', id: `${defaultWorldId}_example_conn_1` },
                term: 'Observed At',
                definition: 'Connects each observation to the location where it was made.',
                notes: 'Maintains spatial context for notes.',
                tags: ['example', 'connection'],
                worldId: defaultWorldId
            });

            Array.from(state.connections.values())
                .filter(conn => conn.worldId === defaultWorldId)
                .forEach(conn => state.connections.delete(conn.id));

            addConnection({
                id: `${defaultWorldId}_example_conn_1`,
                subject: { type: 'Record', id: obs1Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: ridgeId },
                description: 'Tracks where the ridge observation was made.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_2`,
                subject: { type: 'Record', id: obs2Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: marshId },
                description: 'Links marsh observation to its site.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_3`,
                subject: { type: 'Record', id: obs3Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: groveId },
                description: 'Associates grove observation with location.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            addConnection({
                id: `${defaultWorldId}_example_conn_4`,
                subject: { type: 'Record', id: obs4Id },
                relationId: observationLinkRelationId,
                operand: { type: 'Record', id: ridgeId },
                description: 'Links the second ridge observation to its site.',
                params: { context: 'location' },
                worldId: defaultWorldId
            });

            state.currentSetId = observationsId;
            state.currentViewId = Array.from(observationsSet.views.keys())[0];
            state.expandedSets.add(observationsId);
            state.expandedSets.add(locationsId);
        }

        function createGraphDemo() {
            const demoWorldId = createWorld('Graph Demo', 'world_graph_demo');
            state.currentWorldId = demoWorldId;
            const worldDefaults = state.worlds.get(demoWorldId)?.defaults || {};

            // Create sets for different entity types
            const projectsId = createSet('Projects', 'ph-folder', demoWorldId);
            const peopleId = createSet('People', 'ph-users', demoWorldId);
            const tasksId = createSet('Tasks', 'ph-list-checks', demoWorldId);
            const conceptsId = createSet('Concepts', 'ph-lightbulb', demoWorldId);

            // Schema for Projects
            const projectsSet = state.sets.get(projectsId);
            projectsSet.schema = [
                { id: 'name', name: 'Project', type: 'TEXT', width: '200px' },
                { id: 'status', name: 'Status', type: 'TEXT', width: '120px' },
                { id: 'description', name: 'Description', type: 'LONG_TEXT', width: '300px' }
            ];

            // Schema for People
            const peopleSet = state.sets.get(peopleId);
            peopleSet.schema = [
                { id: 'name', name: 'Name', type: 'TEXT', width: '180px' },
                { id: 'role', name: 'Role', type: 'TEXT', width: '150px' },
                { id: 'expertise', name: 'Expertise', type: 'TEXT', width: '200px' }
            ];

            // Schema for Tasks
            const tasksSet = state.sets.get(tasksId);
            tasksSet.schema = [
                { id: 'title', name: 'Task', type: 'TEXT', width: '220px' },
                { id: 'priority', name: 'Priority', type: 'TEXT', width: '100px' },
                { id: 'description', name: 'Description', type: 'LONG_TEXT', width: '280px' }
            ];

            // Schema for Concepts
            const conceptsSet = state.sets.get(conceptsId);
            conceptsSet.schema = [
                { id: 'concept', name: 'Concept', type: 'TEXT', width: '200px' },
                { id: 'category', name: 'Category', type: 'TEXT', width: '150px' },
                { id: 'definition', name: 'Definition', type: 'LONG_TEXT', width: '320px' }
            ];

            // Add project records
            projectsSet.records.clear();
            const proj1 = addRecord(projectsId, {
                name: 'Knowledge Graph',
                status: 'Active',
                description: 'Build interactive knowledge graph visualization system'
            });
            const proj2 = addRecord(projectsId, {
                name: 'Context Engine',
                status: 'Active',
                description: 'Develop epistemic observability context tracking'
            });
            const proj3 = addRecord(projectsId, {
                name: 'Formula System',
                status: 'Planning',
                description: 'Implement reactive formula field calculations'
            });

            // Add people records
            peopleSet.records.clear();
            const person1 = addRecord(peopleId, {
                name: 'Dr. Sarah Chen',
                role: 'Technical Lead',
                expertise: 'Graph Theory, Distributed Systems'
            });
            const person2 = addRecord(peopleId, {
                name: 'Alex Morgan',
                role: 'Engineer',
                expertise: 'Frontend, Data Visualization'
            });
            const person3 = addRecord(peopleId, {
                name: 'Jordan Kim',
                role: 'Researcher',
                expertise: 'Knowledge Management, Ontologies'
            });

            // Add task records
            tasksSet.records.clear();
            const task1 = addRecord(tasksId, {
                title: 'Design node layout algorithm',
                priority: 'High',
                description: 'Create force-directed graph layout with clustering'
            });
            const task2 = addRecord(tasksId, {
                title: 'Implement edge rendering',
                priority: 'High',
                description: 'Add support for curved edges and directional arrows'
            });
            const task3 = addRecord(tasksId, {
                title: 'Build context tracker',
                priority: 'Medium',
                description: 'Track provenance and lineage of data values'
            });
            const task4 = addRecord(tasksId, {
                title: 'Add formula parser',
                priority: 'Medium',
                description: 'Parse and evaluate spreadsheet-like formulas'
            });
            const task5 = addRecord(tasksId, {
                title: 'Research graph databases',
                priority: 'Low',
                description: 'Evaluate Neo4j and other graph database options'
            });

            // Add concept records
            conceptsSet.records.clear();
            const concept1 = addRecord(conceptsId, {
                concept: 'Epistemic Observability',
                category: 'Core Concept',
                definition: 'The ability to trace the origin and context of every data value'
            });
            const concept2 = addRecord(conceptsId, {
                concept: 'Superposition',
                category: 'Data Pattern',
                definition: 'Multiple simultaneous values with different contexts'
            });
            const concept3 = addRecord(conceptsId, {
                concept: 'Reactive Formula',
                category: 'Computation',
                definition: 'Formula that automatically recalculates when dependencies change'
            });
            const concept4 = addRecord(conceptsId, {
                concept: 'Knowledge Graph',
                category: 'Data Structure',
                definition: 'Network of entities and relationships forming a semantic model'
            });

            // Create views
            createView(projectsId, 'Projects', { type: 'grid' });
            createView(peopleId, 'People', { type: 'grid' });
            createView(tasksId, 'Tasks', { type: 'grid' });
            createView(conceptsId, 'Concepts', { type: 'grid' });

            // Clear existing definitions and connections for this world
            Array.from(state.definitions.values())
                .filter(def => def.worldId === demoWorldId)
                .forEach(def => state.definitions.delete(def.id));
            Array.from(state.connectionRelations.values())
                .filter(fmt => fmt.worldId === demoWorldId)
                .forEach(fmt => state.connectionRelations.delete(fmt.id));

            // Create connection relations
            const ownsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_owns`,
                operator: 'OWN',
                mode: 'owns',
                description: 'Person owns/leads a project',
                worldId: demoWorldId
            });

            const assignedRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_assigned`,
                operator: 'ASG',
                mode: 'assigned to',
                description: 'Task assigned to person',
                worldId: demoWorldId
            });

            const partOfRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_part_of`,
                operator: 'SUB',
                mode: 'part of',
                description: 'Task is part of project',
                worldId: demoWorldId
            });

            const implementsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_implements`,
                operator: 'IMP',
                mode: 'implements',
                description: 'Project implements concept',
                worldId: demoWorldId
            });

            const dependsRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_depends`,
                operator: 'DEP',
                mode: 'depends on',
                description: 'Task depends on another task',
                worldId: demoWorldId
            });

            const relatesRelationId = addConnectionRelation({
                id: `${demoWorldId}_format_relates`,
                operator: 'REL',
                mode: 'relates to',
                description: 'Concept relates to concept',
                worldId: demoWorldId
            });

            // Add definitions for key entities
            addDefinition({
                id: `${demoWorldId}_def_proj1`,
                entity: { type: 'Record', id: proj1 },
                term: 'Knowledge Graph Project',
                definition: 'Primary project for building interactive visualization of entity relationships',
                tags: ['demo', 'project'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_proj2`,
                entity: { type: 'Record', id: proj2 },
                term: 'Context Engine',
                definition: 'Core infrastructure for tracking data provenance and lineage',
                tags: ['demo', 'project'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_proj3`,
                entity: { type: 'Record', id: proj3 },
                term: 'Formula System',
                definition: 'Reactive computation system for derived values',
                tags: ['demo', 'project'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_person1`,
                entity: { type: 'Record', id: person1 },
                term: 'Dr. Sarah Chen',
                definition: 'Technical lead with expertise in graph algorithms and distributed systems',
                tags: ['demo', 'person'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_person2`,
                entity: { type: 'Record', id: person2 },
                term: 'Alex Morgan',
                definition: 'Engineer focused on frontend development and data visualization',
                tags: ['demo', 'person'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_person3`,
                entity: { type: 'Record', id: person3 },
                term: 'Jordan Kim',
                definition: 'Researcher specializing in knowledge management and ontology design',
                tags: ['demo', 'person'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_concept1`,
                entity: { type: 'Record', id: concept1 },
                term: 'Epistemic Observability',
                definition: 'Core principle: every data value should be traceable to its source and context',
                tags: ['demo', 'concept'],
                worldId: demoWorldId
            });

            addDefinition({
                id: `${demoWorldId}_def_concept4`,
                entity: { type: 'Record', id: concept4 },
                term: 'Knowledge Graph',
                definition: 'Semantic network representing entities and their relationships',
                tags: ['demo', 'concept'],
                worldId: demoWorldId
            });

            // Clear existing connections
            Array.from(state.connections.values())
                .filter(conn => conn.worldId === demoWorldId)
                .forEach(conn => state.connections.delete(conn.id));

            // Add connections: People own projects
            addConnection({
                id: `${demoWorldId}_conn_1`,
                subject: { type: 'Record', id: person1 },
                relationId: ownsRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Sarah leads the Knowledge Graph project',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_2`,
                subject: { type: 'Record', id: person1 },
                relationId: ownsRelationId,
                operand: { type: 'Record', id: proj2 },
                description: 'Sarah oversees Context Engine development',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_3`,
                subject: { type: 'Record', id: person3 },
                relationId: ownsRelationId,
                operand: { type: 'Record', id: proj3 },
                description: 'Jordan leads Formula System research',
                worldId: demoWorldId
            });

            // Add connections: Tasks assigned to people
            addConnection({
                id: `${demoWorldId}_conn_4`,
                subject: { type: 'Record', id: task1 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person1 },
                description: 'Node layout assigned to Sarah',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_5`,
                subject: { type: 'Record', id: task2 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person2 },
                description: 'Edge rendering assigned to Alex',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_6`,
                subject: { type: 'Record', id: task3 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person2 },
                description: 'Context tracker assigned to Alex',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_7`,
                subject: { type: 'Record', id: task4 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person3 },
                description: 'Formula parser assigned to Jordan',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_8`,
                subject: { type: 'Record', id: task5 },
                relationId: assignedRelationId,
                operand: { type: 'Record', id: person3 },
                description: 'Database research assigned to Jordan',
                worldId: demoWorldId
            });

            // Add connections: Tasks part of projects
            addConnection({
                id: `${demoWorldId}_conn_9`,
                subject: { type: 'Record', id: task1 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Layout algorithm is part of Knowledge Graph',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_10`,
                subject: { type: 'Record', id: task2 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Edge rendering is part of Knowledge Graph',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_11`,
                subject: { type: 'Record', id: task3 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj2 },
                description: 'Context tracker is part of Context Engine',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_12`,
                subject: { type: 'Record', id: task4 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj3 },
                description: 'Formula parser is part of Formula System',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_13`,
                subject: { type: 'Record', id: task5 },
                relationId: partOfRelationId,
                operand: { type: 'Record', id: proj1 },
                description: 'Graph database research supports Knowledge Graph',
                worldId: demoWorldId
            });

            // Add connections: Projects implement concepts
            addConnection({
                id: `${demoWorldId}_conn_14`,
                subject: { type: 'Record', id: proj1 },
                relationId: implementsRelationId,
                operand: { type: 'Record', id: concept4 },
                description: 'Knowledge Graph project implements graph concepts',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_15`,
                subject: { type: 'Record', id: proj2 },
                relationId: implementsRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Context Engine implements epistemic observability',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_16`,
                subject: { type: 'Record', id: proj3 },
                relationId: implementsRelationId,
                operand: { type: 'Record', id: concept3 },
                description: 'Formula System implements reactive formulas',
                worldId: demoWorldId
            });

            // Add connections: Task dependencies
            addConnection({
                id: `${demoWorldId}_conn_17`,
                subject: { type: 'Record', id: task2 },
                relationId: dependsRelationId,
                operand: { type: 'Record', id: task1 },
                description: 'Edge rendering depends on layout algorithm',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_18`,
                subject: { type: 'Record', id: task5 },
                relationId: dependsRelationId,
                operand: { type: 'Record', id: task1 },
                description: 'Database research depends on layout design',
                worldId: demoWorldId
            });

            // Add connections: Concept relationships
            addConnection({
                id: `${demoWorldId}_conn_19`,
                subject: { type: 'Record', id: concept2 },
                relationId: relatesRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Superposition requires epistemic observability',
                worldId: demoWorldId
            });

            addConnection({
                id: `${demoWorldId}_conn_20`,
                subject: { type: 'Record', id: concept4 },
                relationId: relatesRelationId,
                operand: { type: 'Record', id: concept1 },
                description: 'Knowledge graphs benefit from context tracking',
                worldId: demoWorldId
            });

            // Create a graph view for this demo
            const graphViewId = createView(projectsId, 'Graph Demo', { type: 'graph' });

            state.currentSetId = projectsId;
            state.currentViewId = graphViewId;
            state.expandedSets.add(projectsId);
            state.expandedSets.add(peopleId);
            state.expandedSets.add(tasksId);
            state.expandedSets.add(conceptsId);
        }

        // WORLD & SET MANAGEMENT
        function createWorld(name, worldId = null) {
            const resolvedWorldId = worldId || ('world_' + Date.now());
            const defaults = seedWorldDefaults(resolvedWorldId);

            state.worlds.set(resolvedWorldId, {
                id: resolvedWorldId,
                name,
                setIds: new Set([defaults.locationsId, defaults.observationsId].filter(Boolean)),
                createdAt: new Date().toISOString(),
                defaults
            });
            return resolvedWorldId;
        }

        function getWorld(worldId = state.currentWorldId) {
            return worldId ? state.worlds.get(worldId) : null;
        }

        function getSetsForWorld(worldId = state.currentWorldId) {
            return Array.from(state.sets.values()).filter(set => set.worldId === worldId);
        }

        function createSet(name, icon = 'ph-squares-four', worldId = state.currentWorldId) {
            const resolvedWorldId = worldId || state.currentWorldId;
            const setId = 'set_' + Date.now();
            state.sets.set(setId, {
                id: setId,
                name: name,
                icon: icon,
                worldId: resolvedWorldId,
                schema: [],
                records: new Map(),
                views: new Map(),
                profiles: new Map([['default', { id: 'default', name: 'All Fields', visibleFields: [] }]])
            });
            registerEntity({ id: setId, type: 'Set', name, worldId: resolvedWorldId });
            const world = getWorld(resolvedWorldId);
            world?.setIds?.add(setId);
            createEvent(
                'Create Set',
                'INS',
                { type: 'Set', id: setId },
                { name, worldId: resolvedWorldId },
                { summary: `Created set "${name}"`, scale: 'collection' }
            );
            return setId;
        }

        function inferIdentifierFieldId(set) {
            if (!set?.schema) return null;

            const explicitName = set.schema.find(f => f.id === 'name' || (f.name || '').toLowerCase() === 'name');
            if (explicitName) return explicitName.id;

            const textLike = set.schema.find(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            if (textLike) return textLike.id;

            return set.schema[0]?.id || null;
        }

        function ensureViewColumnOrder(view, schema, includeRecordId = false) {
            if (!view || !schema) return [];

            const existingOrder = Array.isArray(view.columnOrder) ? view.columnOrder : [];
            const baseOrder = schema.map(f => f.id);
            const shouldTrackRecordId = includeRecordId || existingOrder.includes('__recordId');
            if (shouldTrackRecordId && !baseOrder.includes('__recordId')) baseOrder.unshift('__recordId');

            const mergedOrder = [
                ...existingOrder.filter(id => baseOrder.includes(id)),
                ...baseOrder.filter(id => !existingOrder.includes(id))
            ];

            view.columnOrder = mergedOrder;
            return mergedOrder;
        }

        function buildTableSchema(view, schema) {
            const columnOrder = ensureViewColumnOrder(view, schema, view?.showRecordId);
            const visibilitySet = new Set(view?.hiddenFields || []);

            const baseFields = columnOrder
                .filter(id => id !== '__recordId' || view?.showRecordId)
                .map(id => id === '__recordId' ? getRecordIdFieldDefinition() : schema.find(f => f.id === id))
                .filter(Boolean)
                .filter(field => !visibilitySet.has(field.id));

            // Add linked fields (lookups and rollups) from view
            const linkedFields = [];

            // Add lookup fields
            if (view?.relationships && Array.isArray(view.relationships)) {
                view.relationships.forEach(rel => {
                    if (rel.type === 'lookup') {
                        linkedFields.push({
                            id: rel.id,
                            name: rel.displayName || `Linked: ${rel.targetFieldId}`,
                            type: 'LINKED_LOOKUP',
                            _linkedConfig: rel,
                            width: '150px'
                        });
                    }
                });
            }

            // Add rollup fields
            if (view?.rollups && Array.isArray(view.rollups)) {
                view.rollups.forEach(rollup => {
                    linkedFields.push({
                        id: rollup.id,
                        name: rollup.displayName || `Rollup: ${rollup.targetFieldId}`,
                        type: 'LINKED_ROLLUP',
                        _linkedConfig: rollup,
                        width: '150px'
                    });
                });
            }

            return [...baseFields, ...linkedFields];
        }

        function createView(setId, name, config = {}) {
            const viewId = 'view_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const set = state.sets.get(setId);
            const defaultIdentifier = config.identifierField || inferIdentifierFieldId(set);
            const viewPayload = {
                id: viewId,
                setId,
                name: name,
                type: config.type || 'grid',
                icon: config.icon || VIEW_TYPE_ICONS[config.type || 'grid'] || '',
                filters: config.filters || [],
                sorts: config.sorts || [],
                hiddenFields: config.hiddenFields || [],
                popupVisibilityRules: config.popupVisibilityRules || [],
                popupLayout: config.popupLayout || { size: 'medium', columns: 4, rows: 4 },
                kanbanGroupField: config.kanbanGroupField || null,
                cardFields: config.cardFields || [],
                parentId: config.parentId || null,
                key: config.key || null,
                schema: config.schema || null,
                relationships: config.relationships || [],
                rollups: config.rollups || [],
                showRecordId: config.showRecordId || false,
                showRowNumbers: config.showRowNumbers !== undefined ? config.showRowNumbers : true,
                identifierField: defaultIdentifier,
                columnRules: config.columnRules || {},
                columnOrder: config.columnOrder || null,
                createdAt: Date.now(),
                createdBy: state.currentUser.id
            };
            set.views.set(viewId, viewPayload);

            if (config.type === 'KEY_DERIVED') {
                createEvent(
                    'Create Key View',
                    'SYN',
                    { type: 'View', id: viewId, setId },
                    { view: viewPayload, summary: `Generated view "${name}" from identity property` },
                    { scale: 'collection' }
                );
            }

            return viewId;
        }

        function reifyCurrentView() {
            const view = getCurrentView();
            if (!view) {
                showToast(' No active view to reify');
                return null;
            }
            const setId = state.currentSetId;
            return reifyView({ ...view, setId: view.setId || setId });
        }

        function reifyView(view) {
            if (!view) return null;

            const randomId = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            const id = `entity_view_${randomId}`;
            const viewRef = {
                setId: view.setId || view.sourceSet || view.sourceSetId || null,
                viewId: view.id || view.key || view.name,
                viewName: view.name
            };
            const memberRefs = collectViewMembers(view);
            const viewWorldId = viewRef.setId ? state.sets.get(viewRef.setId)?.worldId : state.currentWorldId;
            const viewEntity = {
                id,
                type: 'ViewEntity',
                entityType: view.name || 'Reified View',
                viewRef,
                sourceSet: view.setId || view.sourceSet || null,
                memberRefs,
                origin: 'reified',
                worldId: viewWorldId,
                createdAt: Date.now()
            };

            registerEntity(viewEntity);

            addDefinition({
                id: `def_${id}`,
                entity: { type: 'ViewEntity', id },
                term: view.name || 'Reified View',
                definition: 'A view created from filters, groups, or aggregates.',
                notes: `Reified from view ${viewRef.viewName || viewRef.viewId || ''}`.trim(),
                tags: ['reified', 'view'],
                worldId: viewWorldId
            });

            const lineage = extractViewLineage(view, id);
            lineage.forEach(conn => addConnection(conn));

            showToast(` View reified as entity: ${id}`);
            return id;
        }

        function collectViewMembers(view) {
            if (!view) return [];
            const setId = view.setId || view.sourceSet || view.sourceSetId || null;
            const set = setId ? state.sets.get(setId) : null;
            if (!set) return [];

            let records = Array.from(set.records.values());
            if (Array.isArray(view.filters) && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (Array.isArray(view.sorts) && view.sorts.length > 0) records = applySorts(records, view.sorts, set.schema);

            return records.map(record => ({ type: 'Record', id: record.id, setId: set.id }));
        }

        function extractViewLineage(view, newEntityId) {
            const list = [];
            const sourceSetId = view.setId || view.sourceSet || view.sourceSetId || null;
            const idFactory = () => `conn_${crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}_${Math.random().toString(36).substr(2, 6)}`}`;

            if (Array.isArray(view.filters)) {
                view.filters.forEach(filter => {
                    if (!filter?.fieldId) return;
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Field', id: filter.fieldId },
                        operator: 'SEG',
                        mode: 'filters by',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'View generated by filtering',
                        params: filter
                    });
                });
            }

            if (Array.isArray(view.groupBy)) {
                view.groupBy.forEach(group => {
                    if (!group?.fieldId) return;
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Field', id: group.fieldId },
                        operator: 'SEG',
                        mode: 'groups by',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'View grouped by field',
                        params: group
                    });
                });
            }

            if (Array.isArray(view.aggregationRules)) {
                view.aggregationRules.forEach(rule => {
                    list.push({
                        id: idFactory(),
                        subject: { type: 'Set', id: sourceSetId },
                        operator: 'SYN',
                        mode: 'aggregates into',
                        operand: { type: 'ViewEntity', id: newEntityId },
                        description: 'Aggregated fields/materialized view',
                        params: rule
                    });
                });
            }

            if (view.pivotField) {
                list.push({
                    id: idFactory(),
                    subject: { type: 'Field', id: view.pivotField },
                    operator: 'SUP',
                    mode: 'superposes over',
                    operand: { type: 'ViewEntity', id: newEntityId },
                    description: 'View pivoted on field',
                    params: {}
                });
            }

            return list;
        }

        function scoreKeyCandidate(set, fieldId, fieldName, fieldType = 'TEXT') {
            let score = 0;
            if (fieldType === 'LINK_RECORD') score += 0.35;

            const values = Array.from(set.records.values()).map(r => r[fieldId]).filter(v => v !== undefined && v !== null);
            if (values.length > 0) {
                const unique = new Set(values.map(v => JSON.stringify(v))).size;
                const reuseRatio = 1 - unique / values.length;
                score += reuseRatio * 0.4;
            }

            for (const otherSet of getSetsForWorld(set.worldId)) {
                if (otherSet.id === set.id) continue;
                const overlap = otherSet.schema.some(f => f.id === fieldId || f.name === fieldName || f.name === fieldId);
                const dataOverlap = Array.from(otherSet.records.values()).some(r => r[fieldId] !== undefined);
                if (overlap || dataOverlap) score += 0.15;
            }

            score = Math.min(1, score);
            return { score };
        }

        function scoreFieldAsKey(set, field) {
            return scoreKeyCandidate(set, field.id, field.name, field.type);
        }

        function findLooseKeyCandidates(set) {
            const schemaFieldIds = new Set(set.schema.map(f => f.id));
            const counts = new Map();

            set.records.forEach(record => {
                Object.keys(record || {}).forEach(fieldId => {
                    if (fieldId === 'id' || schemaFieldIds.has(fieldId)) return;
                    counts.set(fieldId, (counts.get(fieldId) || 0) + 1);
                });
            });

            const totalRecords = Math.max(set.records.size, 1);
            return [...counts.entries()]
                .map(([fieldId, count]) => ({
                    fieldId,
                    fieldName: fieldId,
                    score: Math.min(1, count / totalRecords)
                }))
                .filter(candidate => candidate.score > 0.6);
        }

        function findKeyCandidates() {
            const candidates = new Map();

            const isValueField = (field) => (field.id?.toLowerCase() === 'value' || field.name?.toLowerCase() === 'value');

            const addCandidate = (setId, fieldId, fieldName, score) => {
                if (!fieldId) return;
                const key = `${setId}:${fieldId}`;
                const existing = candidates.get(key);
                if (!existing || score > existing.score) {
                    candidates.set(key, { setId, fieldId, fieldName, score });
                }
            };

            getSetsForWorld().forEach(set => {
                const setId = set.id;
                set.schema.forEach(field => {
                    const usage = scoreFieldAsKey(set, field);
                    if (usage.score > 0.6) {
                        addCandidate(setId, field.id, field.name, usage.score);
                    }
                });

                const valueField = set.schema.find(isValueField);
                if (valueField) {
                    const values = Array.from(set.records.values())
                        .map(r => r[valueField.id])
                        .filter(v => v !== undefined && v !== null && v !== '');
                    if (values.length > 0) {
                        const unique = new Set(values.map(v => JSON.stringify(v))).size;
                        const reuseRatio = 1 - unique / values.length;
                        const score = Math.min(1, Math.max(0.65, reuseRatio * 0.8 + 0.2));
                        addCandidate(setId, valueField.id, valueField.name || valueField.id, score);
                    }
                }

                set.views.forEach(view => {
                    if (!Array.isArray(view.schema)) return;
                    view.schema.forEach(field => {
                        const sourceFieldId = field.sourceFieldId || field.id;
                        const usage = scoreKeyCandidate(set, sourceFieldId, field.name || sourceFieldId, field.type);
                        if (usage.score > 0.6) {
                            addCandidate(setId, sourceFieldId, field.name || sourceFieldId, usage.score);
                        }
                    });
                });

                findLooseKeyCandidates(set).forEach(candidate => {
                    addCandidate(setId, candidate.fieldId, candidate.fieldName, candidate.score);
                });
            });

            return [...candidates.values()].sort((a, b) => b.score - a.score);
        }

        function findFieldAcrossSets(fieldId) {
            for (const set of getSetsForWorld()) {
                const setId = set.id;
                const schemaField = set.schema.find(f => f.id === fieldId);
                if (schemaField) return { setId, field: schemaField };

                for (const view of set.views.values()) {
                    if (!Array.isArray(view.schema)) continue;
                    const viewField = view.schema.find(f => f.id === fieldId || f.sourceFieldId === fieldId);
                    if (viewField) return { setId, field: viewField };
                }
            }
            return null;
        }

        function findAllItemsForKey(setId, fieldId) {
            const results = [];

            const worldId = state.sets.get(setId)?.worldId || state.currentWorldId;
            getSetsForWorld(worldId).forEach(set => {
                set.records.forEach((record, id) => {
                    if (record[fieldId] !== null && record[fieldId] !== undefined) {
                        results.push({ setId: set.id, recordId: id, record });
                    }
                });
            });

            return results;
        }

        function buildPropertyInventory(items, keyFieldId) {
            const propertyCount = new Map();

            items.forEach(({ record }) => {
                Object.keys(record).forEach(fieldId => {
                    if (fieldId === keyFieldId) return;
                    propertyCount.set(fieldId, (propertyCount.get(fieldId) || 0) + 1);
                });
            });

            return [...propertyCount.entries()]
                .filter(([_, count]) => count / Math.max(items.length, 1) > 0.2)
                .map(([f]) => f);
        }

        function detectRelationships(propertyIds) {
            return propertyIds
                .map(fieldId => {
                    const hit = findFieldAcrossSets(fieldId);
                    if (!hit) return null;
                    if (hit.field.type === 'LINK_RECORD') {
                        return { fieldId, setId: hit.setId, type: 'link' };
                    }
                    if (Array.isArray(hit.field.defaultValue)) {
                        return { fieldId, setId: hit.setId, type: 'array' };
                    }
                    return null;
                })
                .filter(Boolean);
        }

        function detectRollups(keyRef) {
            const rollups = [];
            const worldId = state.sets.get(keyRef.setId)?.worldId || state.currentWorldId;
            getSetsForWorld(worldId).forEach(set => {
                const setId = set.id;
                const hasReference = set.schema.some(f => f.id === keyRef.fieldId || f.name === keyRef.fieldId || f.config?.linkedSetId === keyRef.setId);
                if (hasReference) {
                    rollups.push({
                        type: 'count',
                        fromSetId: setId,
                        fieldId: keyRef.fieldId,
                        label: `Count of ${set.name} where ${keyRef.fieldId} matches`
                    });
                }
            });
            return rollups;
        }

        function autoDetectSchemaFromKey(keyRef) {
            const allItems = findAllItemsForKey(keyRef.setId, keyRef.fieldId);
            const propertyIds = buildPropertyInventory(allItems, keyRef.fieldId);
            const relationships = detectRelationships(propertyIds);
            const rollups = detectRollups(keyRef);

            const schema = propertyIds.map(propId => {
                const match = findFieldAcrossSets(propId);
                return {
                    id: `derived_${propId}`,
                    sourceFieldId: propId,
                    sourceSetId: match?.setId || null,
                    name: match?.field?.name || propId,
                    type: match?.field?.type || 'TEXT'
                };
            });

            return { schema, relationships, rollups };
        }

        function groupByKeyValue(items, keyFieldId) {
            const grouped = new Map();
            items.forEach(item => {
                const key = item.record[keyFieldId];
                if (key === undefined || key === null) return;
                if (!grouped.has(key)) grouped.set(key, []);
                grouped.get(key).push(item);
            });
            return grouped;
        }

        function applyColumnRule(values, ruleConfig = {}) {
            if (!values || values.length === 0) return null;
            const uniqueValues = values.filter(v => v !== undefined && v !== null);
            if (uniqueValues.length === 0) return null;
            const rule = ruleConfig.rule || 'sup_all';

            switch (rule) {
                case 'prefer_newest':
                    return uniqueValues[uniqueValues.length - 1];
                case 'prefer_oldest':
                    return uniqueValues[0];
                case 'prefer_set':
                    if (ruleConfig.setId) {
                        const found = uniqueValues.find(v => v && v.__sourceSetId === ruleConfig.setId);
                        if (found !== undefined) return found;
                    }
                    return uniqueValues[0];
                case 'average_numeric':
                    const nums = uniqueValues.map(Number).filter(n => !Number.isNaN(n));
                    return nums.length ? nums.reduce((a, b) => a + b, 0) / nums.length : null;
                case 'median_numeric':
                    const sorted = uniqueValues.map(Number).filter(n => !Number.isNaN(n)).sort((a, b) => a - b);
                    if (!sorted.length) return null;
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                case 'concat_text':
                    return uniqueValues.join(', ');
                case 'first_non_null':
                    return uniqueValues.find(v => v !== null && v !== undefined);
                case 'sup_all':
                default:
                    return { value: uniqueValues.map(val => ({ val })), _sup: true };
            }
        }

        function buildRowsFromGroups(grouped, view) {
            const rows = [];
            grouped.forEach((items, keyValue) => {
                const row = { id: `key_${keyValue}`, keyValue, __sourceItems: items };
                (view.schema || []).forEach(field => {
                    const values = items.map(item => {
                        const raw = item.record[field.sourceFieldId || field.id];
                        if (raw && typeof raw === 'object' && !raw.__sourceSetId) {
                            return { ...raw, __sourceSetId: item.setId };
                        }
                        if (raw !== undefined && raw !== null) {
                            return typeof raw === 'object' ? { ...raw, __sourceSetId: item.setId } : raw;
                        }
                        return undefined;
                    }).filter(v => v !== undefined);
                    row[field.id] = applyColumnRule(values, view.columnRules?.[field.id]);
                });
                rows.push(row);
            });
            return rows;
        }

        function addRecord(setId, data) {
            const set = state.sets.get(setId);
            const recordId = 'rec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const record = { id: recordId, ...data };
            set.records.set(recordId, record);
            registerEntity({ id: recordId, type: 'Record', setId, data, createdAt: new Date().toISOString() });
            createEvent(
                'Create Record',
                'INS',
                { type: 'Record', id: recordId, setId },
                { setId, recordId, data, summary: 'Created record' }
            );
            return recordId;
        }

        function getRecordById(recordId) {
            // First check current world's sets
            for (const set of getSetsForWorld()) {
                if (set.records.has(recordId)) {
                    return { setId: set.id, set, record: set.records.get(recordId) };
                }
            }
            // Fall back to searching all sets across all worlds
            for (const set of state.sets.values()) {
                if (set.records.has(recordId)) {
                    return { setId: set.id, set, record: set.records.get(recordId) };
                }
            }
            return null;
        }

        function getLinkedSet(field) {
            const linkedSetId = field?.config?.linkedSetId;
            if (!linkedSetId) return null;
            return state.sets.get(linkedSetId) || null;
        }

        function getLinkedRecordOptions(field) {
            const linkedSet = getLinkedSet(field);
            return linkedSet ? Array.from(linkedSet.records.values()) : [];
        }

        function createLinkedRecordOptionList(field) {
            const options = getLinkedRecordOptions(field);
            const linkedSet = getLinkedSet(field);
            return options.map(opt => ({
                id: opt.id,
                label: opt.name || getRecordDisplayName(opt.id) || linkedSet?.name || 'Record'
            }));
        }

        // CSV IMPORT & FUZZY MATCHING
        const CREATE_FIELD_PREFIX = '__create__';
        const CSV_FIELD_MATCH_THRESHOLD = 0.75;

        function slugifyFieldId(name) {
            return (name || '').toLowerCase()
                .replace(/[^a-z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_+|_+$/g, '') || 'field';
        }

        function isCreateFieldValue(value) {
            return typeof value === 'string' && value.startsWith(CREATE_FIELD_PREFIX);
        }

        function buildCreateFieldValue(header) {
            return `${CREATE_FIELD_PREFIX}${slugifyFieldId(header)}`;
        }

        function findBestFieldMatch(header, schema) {
            const target = (header || '').trim();
            let best = null;
            schema.forEach(field => {
                const score = Math.max(
                    similarityScore(target, field.name),
                    similarityScore(target, field.id)
                );
                if (!best || score > best.score) {
                    best = { field, score };
                }
            });
            return best;
        }

        function resetCsvImportState() {
            const defaultSetId = state.currentSetId || Array.from(state.sets.keys())[0] || null;
            state.csvImportState = {
                headers: [],
                rows: [],
                mappings: {},
                previewRows: [],
                matches: [],
                targetMode: defaultSetId ? 'existing' : 'new',
                targetSetId: defaultSetId,
                newSetName: ''
            };
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = '0 rows';
            const mappingEl = document.getElementById('csvMappingContainer');
            if (mappingEl) mappingEl.innerHTML = '<p class="text-sm text-gray-500">Load a CSV file or paste CSV text to start mapping.</p>';
            const previewEl = document.getElementById('csvPreviewContainer');
            if (previewEl) previewEl.innerHTML = '<p class="text-sm text-gray-500">Preview will appear after parsing.</p>';
            const matchesEl = document.getElementById('csvMatchSuggestions');
            if (matchesEl) matchesEl.innerHTML = '<p class="text-sm text-gray-500">No suggestions yet.</p>';
            const textInput = document.getElementById('csvTextInput');
            if (textInput) textInput.value = '';
            const fileInput = document.getElementById('csvFileInput');
            if (fileInput) fileInput.value = '';
            populateCsvTargetSetOptions();
            syncCsvImportTargetUi();
        }

        function populateCsvTargetSetOptions() {
            const select = document.getElementById('csvTargetSetSelect');
            if (!select) return;
            const options = getSetsForWorld().map(set => `<option value="${set.id}">${set.name}</option>`);
            if (!options.length) {
                select.innerHTML = '<option value="" disabled>No sets available</option>';
                select.value = '';
                state.csvImportState.targetSetId = null;
                return;
            }
            select.innerHTML = options.join('');
            const desired = state.csvImportState.targetSetId || state.currentSetId || select.options[0]?.value || '';
            select.value = desired;
            state.csvImportState.targetSetId = select.value || null;
        }

        function syncCsvImportTargetUi() {
            const mode = state.csvImportState.targetMode;
            document.querySelectorAll('input[name="csvImportTargetMode"]').forEach(input => {
                input.checked = input.value === mode;
            });
            document.getElementById('csvExistingSetPicker')?.classList.toggle('hidden', mode !== 'existing');
            document.getElementById('csvNewSetFields')?.classList.toggle('hidden', mode !== 'new');
            const select = document.getElementById('csvTargetSetSelect');
            if (select && mode === 'existing') select.value = state.csvImportState.targetSetId || '';
            const nameInput = document.getElementById('csvNewSetName');
            if (nameInput && mode === 'new') nameInput.value = state.csvImportState.newSetName || '';
        }

        function getCsvTargetSet() {
            if (state.csvImportState.targetMode === 'existing') {
                const setId = state.csvImportState.targetSetId || state.currentSetId;
                return setId ? state.sets.get(setId) : null;
            }
            return {
                id: null,
                name: state.csvImportState.newSetName?.trim() || 'New Set',
                schema: [],
                records: new Map()
            };
        }

        function handleCsvTargetChange() {
            populateCsvTargetSetOptions();
            syncCsvImportTargetUi();
            if (state.csvImportState.headers.length) {
                const set = getCsvTargetSet();
                state.csvImportState.mappings = autoMapColumns(state.csvImportState.headers, set);
                renderCsvMapping();
                renderCsvPreview();
                renderCsvMatches();
            }
        }

        function openCsvImportModal(targetSetId = null) {
            resetCsvImportState();
            if (targetSetId) {
                state.csvImportState.targetMode = 'existing';
                state.csvImportState.targetSetId = targetSetId;
                populateCsvTargetSetOptions();
                syncCsvImportTargetUi();
            }
            openModal('csvImportModal');
        }

        function handleCsvFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;
            const targetSet = getCsvTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                event.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvText = e.target.result || '';
                const { headers, rows } = parseCsvContent(csvText);

                // Extract provenance in background but don't show modal
                if (window.EOProvenanceExtractor) {
                    const extractor = new EOProvenanceExtractor();
                    const provenance = extractor.extractFullProvenance(file, csvText, headers, rows);

                    // Store provenance for optional review in import modal
                    state.csvImportState.provenance = provenance;
                    state.csvImportState.filename = file.name;
                    state.csvImportState.file = file;
                }

                // Go directly to field mapping
                handleCsvData(headers, rows);
            };
            reader.readAsText(file);
        }

        // PROVENANCE REVIEW MODAL FUNCTIONS

        function showProvenanceReviewModal(provenance, onContinue) {
            // Store the continuation callback
            state.csvImportState.provenanceContinueCallback = onContinue;

            // Populate modal fields with extracted provenance
            populateProvenanceModal(provenance);

            // Show the modal
            openModal('provenanceReviewModal');
        }

        function populateProvenanceModal(provenance) {
            const { file, filename, inferred, confidence, embedded, schema } = provenance;

            // Set filename
            document.getElementById('provenanceFilename').textContent = file.filename || '';

            // High confidence inferences
            if (inferred.sourceSystem) {
                document.getElementById('provenanceSourceSystem').value = inferred.sourceSystem.name || '';
                const confPercent = Math.round((confidence.sourceSystem || 0) * 100);
                document.getElementById('provenanceSourceSystemConfidence').textContent = `${confPercent}% confidence`;
            } else {
                document.getElementById('provenanceSourceSystem').value = '';
                document.getElementById('provenanceSourceSystemConfidence').textContent = '';
            }

            document.getElementById('provenanceDataType').value = inferred.dataType || '';

            // Method
            const methodSelect = document.getElementById('provenanceMethod');
            if (inferred.method && inferred.method.name) {
                methodSelect.value = inferred.method.name;
            }

            // Timeframe
            if (inferred.timeframe) {
                document.getElementById('provenanceTimeframeStart').value = inferred.timeframe.start || '';
                document.getElementById('provenanceTimeframeEnd').value = inferred.timeframe.end || '';
            } else {
                document.getElementById('provenanceTimeframeStart').value = '';
                document.getElementById('provenanceTimeframeEnd').value = '';
            }

            // Medium confidence: Jurisdiction
            if (inferred.jurisdiction && inferred.jurisdiction.name) {
                const jurisdictionValue = inferred.jurisdiction.name.toLowerCase().replace(/\s+/g, '_');
                const jurisdictionRadio = document.querySelector(`input[name="provenanceJurisdiction"][value="${jurisdictionValue}"]`);
                if (jurisdictionRadio) {
                    jurisdictionRadio.checked = true;
                } else {
                    document.querySelector('input[name="provenanceJurisdiction"][value="auto"]').checked = true;
                }
            } else {
                document.querySelector('input[name="provenanceJurisdiction"][value="auto"]').checked = true;
            }

            // Scale
            if (inferred.scale && inferred.scale.name) {
                const scaleRadio = document.querySelector(`input[name="provenanceScale"][value="${inferred.scale.name}"]`);
                if (scaleRadio) {
                    scaleRadio.checked = true;
                }
            }

            // Frame
            const frameSelect = document.getElementById('provenanceFrame');
            if (inferred.frame && inferred.frame.name) {
                frameSelect.value = inferred.frame.name;
            } else {
                frameSelect.value = '';
            }

            // External links
            if (inferred.externalLinks && inferred.externalLinks.length > 0) {
                const link = inferred.externalLinks[0];
                document.getElementById('provenanceExternalLinksContainer').classList.remove('hidden');
                document.getElementById('provenanceExternalLinkText').textContent =
                    `Detected ID column: "${link.idColumn}" (${link.system})`;
            } else {
                document.getElementById('provenanceExternalLinksContainer').classList.add('hidden');
            }

            // Build summary
            const summaryEl = document.getElementById('provenanceSummary');
            const summaryItems = [];

            if (schema.externalIds && schema.externalIds.length > 0) {
                summaryItems.push(` Found ${schema.externalIds.length} external ID column(s)`);
            }
            if (schema.timestamps && schema.timestamps.length > 0) {
                summaryItems.push(` Found ${schema.timestamps.length} timestamp column(s)`);
            }
            if (schema.definitionColumns && schema.definitionColumns.length > 0) {
                summaryItems.push(` Found ${schema.definitionColumns.length} definition column(s)`);
            }
            if (embedded && Object.keys(embedded).length > 0) {
                summaryItems.push(` Extracted ${Object.keys(embedded).length} embedded metadata field(s)`);
            }

            summaryEl.innerHTML = summaryItems.length > 0
                ? summaryItems.join('<br>')
                : ' No special markers detected';
        }

        function captureProvenanceEdits() {
            // Capture user edits from the modal
            const edits = {
                sourceSystem: document.getElementById('provenanceSourceSystem').value.trim() || null,
                dataType: document.getElementById('provenanceDataType').value.trim() || null,
                method: document.getElementById('provenanceMethod').value || null,
                timeframe: {
                    start: document.getElementById('provenanceTimeframeStart').value || null,
                    end: document.getElementById('provenanceTimeframeEnd').value || null
                },
                jurisdiction: document.querySelector('input[name="provenanceJurisdiction"]:checked')?.value || 'auto',
                scale: document.querySelector('input[name="provenanceScale"]:checked')?.value || 'individual',
                frame: document.getElementById('provenanceFrame').value || null,
                authority: document.getElementById('provenanceAuthority').value.trim() || null,
                trustLevel: document.querySelector('input[name="provenanceTrustLevel"]:checked')?.value || 'authoritative',
                externalLink: {
                    enabled: document.getElementById('provenanceEnableExternalLink')?.checked || false,
                    url: document.getElementById('provenanceExternalLinkUrl')?.value.trim() || null
                }
            };

            // Handle custom frame
            if (edits.frame === 'custom') {
                edits.frame = document.getElementById('provenanceFrameCustom').value.trim() || null;
            }

            return edits;
        }

        function closeProvenanceReviewModal() {
            closeModal('provenanceReviewModal');
            // Clear the callback
            state.csvImportState.provenanceContinueCallback = null;
        }

        function continueToColumnMapping() {
            // Capture edits
            const edits = captureProvenanceEdits();
            state.csvImportState.provenanceEdits = edits;

            // Close provenance modal
            closeModal('provenanceReviewModal');

            // Execute the continuation callback
            if (state.csvImportState.provenanceContinueCallback) {
                state.csvImportState.provenanceContinueCallback();
            }
        }

        function skipProvenanceReview() {
            // Use default/auto-detected values
            state.csvImportState.provenanceEdits = {};

            // Close provenance modal
            closeModal('provenanceReviewModal');

            // Execute the continuation callback
            if (state.csvImportState.provenanceContinueCallback) {
                state.csvImportState.provenanceContinueCallback();
            }
        }

        function previewCsvFromText() {
            const text = document.getElementById('csvTextInput')?.value || '';
            const targetSet = getCsvTargetSet();
            if (!targetSet) {
                showToast(' Choose a destination set first');
                return;
            }
            const { headers, rows } = parseCsvContent(text);
            handleCsvData(headers, rows);
        }

        function parseCsvContent(text) {
            if (!text || !text.trim()) return { headers: [], rows: [] };
            const rows = [];
            let current = '';
            let inQuotes = false;
            const result = [];
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    rowPush(current);
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    rowPush(current);
                    if (result.length) rows.push(result.splice(0));
                } else {
                    current += char;
                }
            }
            rowPush(current);
            if (result.length) rows.push(result);

            function rowPush(value) {
                result.push(value.trim());
                current = '';
            }

            const headers = rows.shift() || [];
            const normalizedRows = rows.filter(r => r.length && r.some(cell => cell !== '')).map(r => {
                const obj = {};
                headers.forEach((h, idx) => obj[h] = r[idx] || '');
                return obj;
            });
            return { headers, rows: normalizedRows };
        }

        function autoMapColumns(headers, set) {
            const mappings = {};
            const schema = set?.schema || [];
            headers.forEach(h => {
                const match = findBestFieldMatch(h, schema);
                if (match && match.score >= CSV_FIELD_MATCH_THRESHOLD) {
                    mappings[h] = match.field.id;
                } else {
                    mappings[h] = buildCreateFieldValue(h);
                }
            });
            return mappings;
        }

        function handleCsvData(headers, rows) {
            const set = getCsvTargetSet();
            if (state.csvImportState.targetMode === 'existing' && !set) {
                showToast(' Choose a destination set first');
                return;
            }
            state.csvImportState.headers = headers;
            state.csvImportState.rows = rows;
            state.csvImportState.mappings = autoMapColumns(headers, set);
            const badge = document.getElementById('csvRowCountBadge');
            if (badge) badge.textContent = `${rows.length} rows`;
            renderCsvMapping();
            renderCsvPreview();
            renderCsvMatches();
            populateSimplifiedProvenance();
        }

        function populateSimplifiedProvenance() {
            // Populate simplified provenance fields with auto-detected values
            const provenance = state.csvImportState.provenance;
            if (!provenance) return;

            const sourceInput = document.getElementById('csvProvenanceSource');
            const dataTypeInput = document.getElementById('csvProvenanceDataType');

            if (sourceInput && provenance.inferred?.sourceSystem) {
                sourceInput.value = provenance.inferred.sourceSystem.name || '';
                sourceInput.placeholder = `Auto-detected: ${provenance.inferred.sourceSystem.name || 'Unknown'}`;
            }

            if (dataTypeInput && provenance.inferred?.dataType) {
                dataTypeInput.value = provenance.inferred.dataType || '';
                dataTypeInput.placeholder = `Auto-detected: ${provenance.inferred.dataType || 'Unknown'}`;
            }
        }

        function renderCsvMapping() {
            const container = document.getElementById('csvMappingContainer');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            if (!state.csvImportState.headers.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No headers detected yet.</p>';
                return;
            }

            container.innerHTML = state.csvImportState.headers.map(header => {
                const mappedField = state.csvImportState.mappings[header] || '';
                const createValue = buildCreateFieldValue(header);
                const options = ['<option value="">Skip</option>']
                    .concat(`<option value="${createValue}" ${mappedField === createValue ? 'selected' : ''}> Create new field: "${header}"</option>`)
                    .concat(set.schema.map(f => `<option value="${f.id}" ${mappedField === f.id ? 'selected' : ''}>${f.name}</option>`))
                    .join('');
                return `
                    <div class="flex items-center gap-3">
                        <div class="w-1/3 font-medium">${header}</div>
                        <div class="flex-1">
                            <select data-csv-header="${header}" class="flex-1">${options}</select>
                            ${isCreateFieldValue(mappedField) ? `<p class="text-xs text-amber-600 mt-1">Will create a new text field named "${header}"</p>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('select').forEach(select => {
                select.onchange = (event) => {
                    const header = event.target.dataset.csvHeader;
                    state.csvImportState.mappings[header] = event.target.value;
                    renderCsvPreview();
                    renderCsvMatches();
                };
            });
        }

        function buildCsvPreviewRows(limit = 5) {
            const set = getCsvTargetSet();
            if (!set) return [];
            const mappedHeaders = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            return state.csvImportState.rows.slice(0, limit).map(row => {
                const preview = { __original: row };
                mappedHeaders.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header] || '';
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? '' : numeric;
                    }
                    preview[fieldId] = value;
                });
                return preview;
            });
        }

        function renderCsvPreview() {
            const container = document.getElementById('csvPreviewContainer');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            const mappedEntries = state.csvImportState.headers
                .map(header => [header, state.csvImportState.mappings[header]])
                .filter(([, fieldId]) => fieldId);
            if (!mappedEntries.length || !state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one column to preview records.</p>';
                return;
            }

            const previewRows = buildCsvPreviewRows();
            state.csvImportState.previewRows = previewRows;
            const headerCells = mappedEntries.map(([header, fieldId]) => {
                const field = set.schema.find(f => f.id === fieldId);
                const label = field?.name || header;
                const badge = field ? '' : '<span class="ml-2 text-xs font-semibold text-amber-600">(creates field)</span>';
                return `<th>${label}${badge}</th>`;
            }).join('');

            const bodyRows = previewRows.map(row => {
                const cells = mappedEntries.map(([, fieldId]) => `<td>${row[fieldId] ?? ''}</td>`).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="csv-preview-table">
                    <thead><tr>${headerCells}</tr></thead>
                    <tbody>${bodyRows}</tbody>
                </table>
            `;
        }

        function similarityScore(a, b) {
            const s1 = (a || '').toString().trim().toLowerCase();
            const s2 = (b || '').toString().trim().toLowerCase();
            if (!s1 || !s2) return 0;
            const distance = levenshteinDistance(s1, s2);
            return 1 - (distance / Math.max(s1.length, s2.length));
        }

        function levenshteinDistance(a, b) {
            const matrix = Array.from({ length: b.length + 1 }, () => []);
            for (let i = 0; i <= b.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function resolvePrimaryFieldFromMappings(set) {
            const nameField = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === 'name');
            if (nameField) return nameField[1];
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const mappedTextField = Object.entries(state.csvImportState.mappings)
                .map(([, fieldId]) => set.schema.find(f => f.id === fieldId))
                .find(f => f && ['TEXT', 'LONG_TEXT'].includes(f.type));
            return mappedTextField?.id || textFields[0]?.id || set.schema[0]?.id;
        }

        function renderCsvMatches() {
            const container = document.getElementById('csvMatchSuggestions');
            const set = getCsvTargetSet();
            if (!container || !set) return;
            if (!state.csvImportState.rows.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">Load rows to see suggestions.</p>';
                return;
            }

            const keyFieldId = resolvePrimaryFieldFromMappings(set);
            if (!keyFieldId) {
                container.innerHTML = '<p class="text-sm text-gray-500">Map at least one text column to find duplicates.</p>';
                return;
            }

            const existing = Array.from(set.records.values());
            const matches = [];
            state.csvImportState.rows.forEach(row => {
                const mappedValue = Object.entries(state.csvImportState.mappings).find(([, fieldId]) => fieldId === keyFieldId);
                const candidateValue = mappedValue ? row[mappedValue[0]] : '';
                let bestMatch = null;
                existing.forEach(rec => {
                    const score = similarityScore(candidateValue, rec[keyFieldId]);
                    if (score >= 0.6 && (!bestMatch || score > bestMatch.score)) {
                        bestMatch = { csvValue: candidateValue, record: rec, score };
                    }
                });
                if (bestMatch) matches.push(bestMatch);
            });

            state.csvImportState.matches = matches;
            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No close matches detected.</p>';
                return;
            }

            container.innerHTML = matches.slice(0, 10).map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">CSV Value</div>
                        <strong>${match.csvValue || '(blank)'}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Existing Record</div>
                        <strong>${match.record.name || match.record.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                </div>
            `).join('');
        }

        function importCsvRecords() {
            let set = null;
            if (state.csvImportState.targetMode === 'existing') {
                const setId = state.csvImportState.targetSetId || state.currentSetId;
                if (!setId) {
                    showToast(' Choose a destination set first');
                    return;
                }
                set = state.sets.get(setId);
            } else {
                const name = (state.csvImportState.newSetName || '').trim();
                if (!name) {
                    showToast(' Name your new set before importing');
                    return;
                }
                const setId = createSet(name, 'ph-squares-four', state.currentWorldId);
                createView(setId, 'All ' + name, { type: 'grid' });
                state.expandedSets.add(setId);
                renderSidebar();
                switchSet(setId, null);
                set = state.sets.get(setId);
                state.csvImportState.targetMode = 'existing';
                state.csvImportState.targetSetId = setId;
            }
            if (!set) return;
            const mappedHeaders = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);
            if (!mappedHeaders.length) {
                showToast(' Map at least one column');
                return;
            }
            if (!state.csvImportState.rows.length) {
                showToast(' No rows to import');
                return;
            }

            const existingFieldIds = new Set(set.schema.map(f => f.id));
            mappedHeaders
                .filter(([, fieldId]) => isCreateFieldValue(fieldId))
                .forEach(([header, fieldId]) => {
                    const suggestedId = fieldId.replace(CREATE_FIELD_PREFIX, '') || slugifyFieldId(header);
                    const fieldName = header?.trim() || 'New Field';
                    let uniqueId = suggestedId;
                    let counter = 1;
                    while (existingFieldIds.has(uniqueId)) {
                        uniqueId = `${suggestedId}_${counter++}`;
                    }

                    const newField = { id: uniqueId, name: fieldName, type: 'TEXT', width: '150px', config: {} };
                    set.schema.push(newField);
                    set.records.forEach(r => r[uniqueId] = FIELD_TYPES.TEXT.defaultValue);
                    existingFieldIds.add(uniqueId);
                    state.csvImportState.mappings[header] = uniqueId;
                });

            const finalizedMappings = Object.entries(state.csvImportState.mappings).filter(([, fieldId]) => fieldId);

            // Create ONE context template for the entire import (lean approach)
            // Enhanced with rich provenance from extraction
            let importTemplateId = null;
            if (state.leanContext) {
                const importFilename = state.csvImportState.filename || 'import.csv';
                const provenance = state.csvImportState.provenance || {};
                const provenanceEdits = state.csvImportState.provenanceEdits || {};
                const inferred = provenance.inferred || {};

                // Build rich context template
                const templateContext = {
                    // Basic context (with provenance enhancements)
                    method: provenanceEdits.method || inferred.method?.name || 'declared',
                    source: provenanceEdits.sourceSystem || inferred.sourceSystem?.name || 'csv_import',
                    agent: state.currentUser.id,
                    timeframe: provenanceEdits.timeframe?.start ? provenanceEdits.timeframe : (inferred.timeframe || {
                        start: new Date().toISOString().split('T')[0]
                    }),
                    scale: provenanceEdits.scale || inferred.scale?.name || 'individual',

                    // NEW: Rich provenance fields
                    frame: provenanceEdits.frame || inferred.frame?.name || null,
                    jurisdiction: provenanceEdits.jurisdiction !== 'auto' ? provenanceEdits.jurisdiction : (inferred.jurisdiction?.name || null),
                    ground: provenanceEdits.authority || null,
                    trustLevel: provenanceEdits.trustLevel || 'authoritative',

                    // File metadata
                    fileMetadata: provenance.file || {},
                    embeddedMetadata: provenance.embedded || {},

                    // External system linkage
                    externalLinks: inferred.externalLinks || [],

                    // Confidence scores (for transparency)
                    confidence: provenance.confidence || {}
                };

                // If external link is enabled, add connection info
                if (provenanceEdits.externalLink?.enabled && provenanceEdits.externalLink?.url) {
                    templateContext.externalSystemUrl = provenanceEdits.externalLink.url;
                }

                importTemplateId = state.leanContext.registerContextTemplate(templateContext);

                // Column-level definition detection and capture
                if (provenance.schema && provenance.schema.definitionColumns) {
                    state.csvImportState.fieldDefinitions = state.csvImportState.fieldDefinitions || {};

                    provenance.schema.definitionColumns.forEach(defColumn => {
                        // Find the base field name (e.g., "revenue" from "revenue_definition")
                        const baseFieldName = defColumn.replace(/_definition$|_definition_id$|_def$|_type$|_category$/i, '');

                        // Extract unique definitions from the data
                        const definitions = new Set();
                        state.csvImportState.rows.forEach(row => {
                            const defValue = row[defColumn];
                            if (defValue) definitions.add(defValue);
                        });

                        // Record as definitional events
                        definitions.forEach(defValue => {
                            state.csvImportState.fieldDefinitions[baseFieldName] = {
                                operator: 'DES',
                                definer: {
                                    type: 'system',
                                    source: templateContext.source,
                                    id: templateContext.agent
                                },
                                definition: defValue,
                                frame: templateContext.frame,
                                jurisdiction: templateContext.jurisdiction,
                                definitionColumn: defColumn,
                                timestamp: new Date().toISOString()
                            };
                        });
                    });
                }
            }

            state.csvImportState.rows.forEach(row => {
                const recordData = {};
                finalizedMappings.forEach(([header, fieldId]) => {
                    const field = set.schema.find(f => f.id === fieldId);
                    let value = row[header];
                    if (['NUMBER', 'CURRENCY'].includes(field?.type)) {
                        const numeric = parseFloat(value);
                        value = isNaN(numeric) ? 0 : numeric;
                    }
                    recordData[fieldId] = value;
                });

                // Use lean record creation if available
                if (state.leanContext && importTemplateId) {
                    const leanRecord = state.leanContext.createLeanRecord(set.id, recordData, importTemplateId);

                    // Apply field-level definition overrides if available
                    if (state.csvImportState.fieldDefinitions) {
                        Object.entries(state.csvImportState.fieldDefinitions).forEach(([baseFieldName, defInfo]) => {
                            // Find matching field in mappings
                            const matchingMapping = finalizedMappings.find(([header, fieldId]) => {
                                const normalized = header.toLowerCase().replace(/[^a-z0-9]/g, '_');
                                return normalized.includes(baseFieldName.toLowerCase());
                            });

                            if (matchingMapping) {
                                const [header, fieldId] = matchingMapping;
                                const definitionColumn = defInfo.definitionColumn;
                                const recordDefinition = row[definitionColumn];

                                // If this record has a specific definition value, apply field-level context
                                if (recordDefinition && state.leanContext.setFieldContext) {
                                    state.leanContext.setFieldContext(leanRecord, fieldId, {
                                        definition: recordDefinition,
                                        frame: defInfo.frame,
                                        jurisdiction: defInfo.jurisdiction
                                    });
                                }
                            }
                        });
                    }

                    set.records.set(leanRecord.id, leanRecord);
                    createEvent(
                        'Create Record',
                        'INS',
                        { type: 'Record', id: leanRecord.id, setId: set.id },
                        { setId: set.id, recordId: leanRecord.id, data: recordData, summary: 'Created record via import' }
                    );
                } else {
                    addRecord(set.id, recordData);
                }
            });

            // Create batch import event (compact)
            const importTimestamp = Date.now();
            if (state.leanContext && importTemplateId) {
                createEvent(
                    'Batch Import',
                    'INS',
                    { type: 'Set', id: set.id },
                    {
                        count: state.csvImportState.rows.length,
                        templateId: importTemplateId,
                        summary: `Imported ${state.csvImportState.rows.length} records`,
                        timestamp: importTimestamp
                    }
                );
            }

            // Auto-create a temporary view for this import
            const importFileName = state.csvImportState.filename || 'import.csv';
            const baseViewName = importFileName.replace(/\.[^/.]+$/, ''); // Remove extension
            const viewName = `Import: ${baseViewName}`;

            const importViewId = createView(set.id, viewName, {
                type: 'grid',
                icon: '',
                isTemporary: true,
                importMetadata: {
                    filename: importFileName,
                    timestamp: importTimestamp,
                    recordCount: state.csvImportState.rows.length,
                    templateId: importTemplateId,
                    expiresAt: importTimestamp + (7 * 24 * 60 * 60 * 1000) // 7 days from now
                }
            });

            // Track this as an import view in event stream
            createEvent(
                'Import View Created',
                'INS',
                { type: 'View', id: importViewId },
                {
                    setId: set.id,
                    viewName: viewName,
                    filename: importFileName,
                    recordCount: state.csvImportState.rows.length,
                    isTemporary: true,
                    expiresAt: importTimestamp + (7 * 24 * 60 * 60 * 1000)
                }
            );

            switchSet(set.id, importViewId);
            showToast(` Imported ${state.csvImportState.rows.length} records`);
            closeModal('csvImportModal');
        }

        function computeFuzzyMatchesForSet(set, threshold = state.fuzzyPanelState.threshold) {
            if (!set) return [];
            const candidates = Array.from(set.records.values());
            const textFields = set.schema.filter(f => ['TEXT', 'LONG_TEXT'].includes(f.type));
            const fieldId = textFields[0]?.id || set.schema[0]?.id;
            const matches = [];
            for (let i = 0; i < candidates.length; i++) {
                for (let j = i + 1; j < candidates.length; j++) {
                    const a = candidates[i];
                    const b = candidates[j];
                    const score = similarityScore(a[fieldId], b[fieldId]);
                    if (score >= threshold) {
                        matches.push({ a, b, score, fieldId });
                    }
                }
            }
            return matches.sort((x, y) => y.score - x.score).slice(0, 50);
        }

        function renderFuzzyPanel() {
            const container = document.getElementById('fuzzyMatchList');
            const thresholdInput = document.getElementById('fuzzyThresholdInput');
            if (!container || !thresholdInput) return;
            const set = getCurrentSet();
            if (!set) return;
            const threshold = parseFloat(thresholdInput.value) || state.fuzzyPanelState.threshold;
            state.fuzzyPanelState.threshold = threshold;
            const matches = computeFuzzyMatchesForSet(set, threshold);
            state.fuzzyPanelState.matches = matches;

            if (!matches.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No matches at this threshold.</p>';
                return;
            }

            container.innerHTML = matches.map(match => `
                <div class="fuzzy-match-row">
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record A</div>
                        <strong>${match.a.name || match.a.id}</strong>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm text-gray-500">Record B</div>
                        <strong>${match.b.name || match.b.id}</strong>
                        <div class="text-xs text-gray-500">Score: <span class="fuzzy-score">${match.score.toFixed(2)}</span></div>
                    </div>
                    <div class="flex items-center gap-2">
                        <button class="btn btn-secondary btn-sm" data-link="${match.a.id}|${match.b.id}" data-score="${match.score}">Link</button>
                        <button class="btn btn-secondary btn-sm" data-dismiss="${match.a.id}|${match.b.id}">Dismiss</button>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('[data-link]').forEach(btn => {
                btn.onclick = () => {
                    const [sourceId, targetId] = btn.dataset.link.split('|');
                    const score = parseFloat(btn.dataset.score || '0');
                    createConnection(sourceId, targetId, { reason: 'fuzzy-match', score });
                    showToast(' Linked records');
                };
            });

            container.querySelectorAll('[data-dismiss]').forEach(btn => {
                btn.onclick = () => {
                    btn.closest('.fuzzy-match-row').remove();
                };
            });
        }

        function openFuzzyPanel() {
            renderFuzzyPanel();
            document.getElementById('fuzzyMatchPanel').classList.add('open');
        }

        function closeFuzzyPanel() {
            document.getElementById('fuzzyMatchPanel').classList.remove('open');
        }

        function validateConnectionPayload(connection) {
            if (!connection?.relationId) {
                throw new Error('Connections must reference a connection relation');
            }

            const relation = findConnectionRelation(connection.relationId);
            if (!relation) {
                throw new Error('Referenced connection relation not found');
            }

            if (!connection?.subject || !connection?.operand) {
                throw new Error('Connections require both subject and operand');
            }
            const { subject, operand } = connection;
            if (!subject.type || !subject.id || !operand.type || !operand.id) {
                throw new Error('Connections require typed entity references');
            }

            const subjectWorld = deriveWorldIdForEntity(subject);
            const operandWorld = deriveWorldIdForEntity(operand);
            const worldMismatch = subjectWorld && operandWorld && subjectWorld !== operandWorld;
            if (worldMismatch) {
                throw new Error('Connections must stay within the same world');
            }

            const params = connection.params || {};
            if (params === null || typeof params !== 'object' || Array.isArray(params)) {
                throw new Error('Connection params must be an object');
            }

            relation.requiredParams.forEach(param => {
                if (!(param in params)) {
                    throw new Error(`Missing required param: ${param}`);
                }
            });

            const worldId = connection.worldId || subjectWorld || operandWorld || state.currentWorldId;
            if (relation.worldId && worldId && relation.worldId !== worldId) {
                throw new Error('Connection must use a relation from the same world');
            }

            return {
                ...connection,
                params,
                worldId,
                relationId: relation.id,
                operator: relation.operator,
                mode: relation.mode
            };
        }

        function addConnection(conn) {
            let normalized;
            try {
                normalized = validateConnectionPayload(conn);
            } catch (error) {
                console.error(error);
                showToast(` ${error.message || 'Unable to create connection'}`);
                return null;
            }

            const connectionId = conn.id || `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const payload = {
                ...normalized,
                id: connectionId,
                createdAt: normalized.createdAt || new Date().toISOString()
            };

            state.connections.set(connectionId, payload);
            registerEntity({ id: connectionId, type: 'Connection', worldId: payload.worldId, subject: payload.subject, operand: payload.operand });

            const summary = `Connected ${renderEntityLabel(payload.subject)} ${payload.mode || ''} ${renderEntityLabel(payload.operand)}`.trim();
            createEvent(
                'Create Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: payload,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return connectionId;
        }

        function updateConnection(connectionId, updates = {}) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            const merged = validateConnectionPayload({
                ...existing,
                ...updates,
                id: connectionId
            });

            const updated = {
                ...existing,
                ...merged,
                updatedAt: new Date().toISOString()
            };

            state.connections.set(connectionId, updated);

            const summary = `Updated connection ${connectionId} (${renderEntityLabel(updated.subject)} ${updated.mode || ''} ${renderEntityLabel(updated.operand)})`;
            createEvent(
                'Update Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: updated,
                    summary
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return updated;
        }

        function deleteConnection(connectionId) {
            const existing = state.connections.get(connectionId);
            if (!existing) throw new Error(`Connection ${connectionId} not found`);

            state.connections.delete(connectionId);

            const summary = `Removed connection ${renderEntityLabel(existing.subject)} ${existing.mode || ''} ${renderEntityLabel(existing.operand)}`;
            createEvent(
                'Delete Connection',
                'CON',
                { type: 'Connection', id: connectionId },
                {
                    edge: existing,
                    summary,
                    deleted: true
                },
                { frame: 'graph', scale: 'relationship' }
            );

            return existing;
        }

        function createConnection(sourceId, targetId, relationId = null, params = {}) {
            const resolvedRelationId = relationId || getDefaultConnectionRelationId('CON') || getDefaultConnectionRelationId();
            if (!resolvedRelationId) {
                showToast(' Add a connection relation before creating connections');
                return null;
            }

            return addConnection({
                subject: { type: 'Record', id: sourceId },
                operand: { type: 'Record', id: targetId },
                relationId: resolvedRelationId,
                params
            });
        }

        // SIDEBAR
        function toggleSidebar() {
            const isMobile = window.matchMedia('(max-width: 1024px)').matches;
            if (isMobile) {
                state.sidebarOpenMobile = !state.sidebarOpenMobile;
            } else {
                state.sidebarCollapsed = !state.sidebarCollapsed;
            }
            applyResponsiveLayout();
        }

        function closeMobileSidebar() {
            if (!state.sidebarOpenMobile) return;
            state.sidebarOpenMobile = false;
            applyResponsiveLayout();
        }

        function toggleSetExpansion(setId) {
            if (state.expandedSets.has(setId)) {
                state.expandedSets.delete(setId);
            } else {
                state.expandedSets.add(setId);
            }
            renderSidebar();
        }

        function toggleNavSection(sectionName) {
            const contentId = sectionName + 'NavContent';
            const chevronId = sectionName + 'SectionChevron';
            const content = document.getElementById(contentId);
            const chevron = document.getElementById(chevronId);

            if (!content || !chevron) return;

            if (state.collapsedNavSections.has(sectionName)) {
                state.collapsedNavSections.delete(sectionName);
                content.style.display = 'block';
                chevron.className = 'ph ph-caret-down';
            } else {
                state.collapsedNavSections.add(sectionName);
                content.style.display = 'none';
                chevron.className = 'ph ph-caret-right';
            }
        }

        function initializeNavSections() {
            // Initialize all nav sections based on the collapsedNavSections state
            const sections = ['world', 'explore', 'actions', 'sets'];
            sections.forEach(sectionName => {
                const contentId = sectionName + 'NavContent';
                const chevronId = sectionName + 'SectionChevron';
                const content = document.getElementById(contentId);
                const chevron = document.getElementById(chevronId);

                if (!content || !chevron) return;

                const isCollapsed = state.collapsedNavSections.has(sectionName);
                if (isCollapsed) {
                    content.style.display = 'none';
                    chevron.className = 'ph ph-caret-right';
                } else {
                    content.style.display = 'block';
                    chevron.className = 'ph ph-caret-down';
                }
            });
        }

        function filterSets(searchTerm) {
            const setsContainer = document.getElementById('navSetsContainer');
            if (!setsContainer) return;

            const normalizedSearch = searchTerm.toLowerCase().trim();

            // If search is empty, re-render normally
            if (!normalizedSearch) {
                renderSidebar();
                return;
            }

            // Get all sets for the current world
            const setsForWorld = getSetsForWorld();
            setsContainer.innerHTML = '';

            let hasResults = false;

            setsForWorld.forEach(set => {
                const setMatches = set.name.toLowerCase().includes(normalizedSearch);
                const matchingViews = [];

                // Check if any views match
                if (set.views && set.views.size > 0) {
                    set.views.forEach((view, viewId) => {
                        if (view.name.toLowerCase().includes(normalizedSearch)) {
                            matchingViews.push([viewId, view]);
                        }
                    });
                }

                // Show set if it matches or has matching views
                if (setMatches || matchingViews.length > 0) {
                    hasResults = true;

                    // Create set header
                    const setHeader = document.createElement('div');
                    setHeader.className = 'nav-item';
                    setHeader.style.display = 'flex';
                    setHeader.style.alignItems = 'center';
                    setHeader.style.justifyContent = 'space-between';

                    const setLabel = document.createElement('span');
                    setLabel.textContent = set.name;
                    setLabel.style.flex = '1';

                    if (set.id === state.currentSetId && !state.currentSpecialView && !state.currentViewId) {
                        setHeader.classList.add('active');
                    }

                    setHeader.appendChild(setLabel);

                    setHeader.onclick = (e) => {
                        e.stopPropagation();
                        state.currentSetId = set.id;
                        state.currentViewId = null;
                        state.currentSpecialView = null;
                        renderCurrentView();
                        renderSidebar();
                    };

                    setsContainer.appendChild(setHeader);

                    // Show matching views (or all views if set matched)
                    const viewsToShow = setMatches ? Array.from(set.views.entries()) : matchingViews;
                    if (viewsToShow.length > 0) {
                        const viewsContainer = document.createElement('div');
                        viewsContainer.style.paddingLeft = '0.5rem';
                        viewsContainer.style.marginTop = '0.25rem';
                        viewsContainer.style.marginBottom = '0.5rem';

                        viewsToShow.forEach(([viewId, view]) => {
                            const viewItem = document.createElement('div');
                            viewItem.className = `view-item ${viewId === state.currentViewId ? 'active' : ''}`;
                            viewItem.style.paddingLeft = '12px';
                            viewItem.innerHTML = `
                                <span class="view-item-icon">${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])}</span>
                                <span>${view.name}</span>
                            `;
                            viewItem.onclick = (e) => {
                                e.stopPropagation();
                                switchSet(set.id, viewId);
                            };
                            viewsContainer.appendChild(viewItem);
                        });

                        setsContainer.appendChild(viewsContainer);
                    }
                }
            });

            if (!hasResults) {
                setsContainer.innerHTML = '<div style="color: #9ca3af; font-size: 0.875rem; padding: 0.5rem 0;">No matching sets or views</div>';
            }
        }

        function renderWorldSelector() {
            const select = document.getElementById('worldSelect');
            const label = document.getElementById('currentWorldLabel');
            const headerLabel = document.getElementById('currentWorldHeaderLabel');

            // Update the select dropdown if it exists
            if (select) {
                select.innerHTML = '';
                state.worlds.forEach((world, id) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = world.name;
                    select.appendChild(opt);
                });

                if (!state.currentWorldId && select.options.length > 0) {
                    state.currentWorldId = select.options[0].value;
                }

                if (state.currentWorldId) {
                    select.value = state.currentWorldId;
                }
            } else {
                // If select doesn't exist, ensure we have a current world
                if (!state.currentWorldId && state.worlds.size > 0) {
                    state.currentWorldId = Array.from(state.worlds.keys())[0];
                }
            }

            // Always update labels
            if (label) {
                const world = getWorld();
                label.textContent = world?.name || 'No world selected';
            }

            if (headerLabel) {
                const world = getWorld();
                headerLabel.textContent = world?.name || 'No world selected';
            }
        }

        function pruneTabsForWorld(worldId) {
            if (!worldId) return;

            state.openTabs = state.openTabs.filter(tab => {
                const set = state.sets.get(tab.setId);
                return set?.worldId === worldId;
            });
        }

        function switchWorld(worldId) {
            if (!worldId || !state.worlds.has(worldId)) return;
            state.currentWorldId = worldId;
            pruneTabsForWorld(worldId);
            const sets = getSetsForWorld(worldId);
            if (!sets.some(set => set.id === state.currentSetId)) {
                state.currentSetId = sets[0]?.id || null;
                state.currentViewId = null;
            }
            renderWorldSelector();
            renderSidebar();
            renderViewTabs();
            if (state.currentSetId) {
                switchSet(state.currentSetId, state.currentViewId);
            }
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function loadGraphDemo() {
            createGraphDemo();
            renderWorldSelector();
            renderSidebar();
            renderViewTabs();
            if (state.currentSetId && state.currentViewId) {
                switchSet(state.currentSetId, state.currentViewId);
            }
            // syncUrlState(); // Commented out to prevent URL manipulation
            showToast('Graph demo loaded! Explore the visualization of projects, people, tasks, and concepts.');
        }

        function openAddWorldModal() {
            const input = document.getElementById('newWorldName');
            if (input) input.value = '';
            openModal('addWorldModal');
        }

        function openEntitiesPage() {
            state.currentSpecialView = 'entities';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function saveWorldFromModal() {
            const input = document.getElementById('newWorldName');
            const name = input?.value.trim();
            if (!name) { showConfirm('Please enter a world name', () => {}); return; }
            const worldId = createWorld(name);
            switchWorld(worldId);
            closeModal('addWorldModal');
            showToast(' World created');
        }

        function openDefinitionsPage() {
            state.currentSpecialView = 'definitions';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function openRelationsPage() {
            state.currentSpecialView = 'relations';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        // Alias for backwards compatibility
        function openConnectionsPage() { openRelationsPage(); }

        function openVisualizationsPage() {
            state.currentSpecialView = 'visualizations';
            state.currentSetId = null;
            state.currentViewId = null;
            closeMobileSidebar();
            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        // NEW NAVIGATION HELPER FUNCTION
        function navigateTo(page, filterType = null) {
            closeMobileSidebar();

            switch(page) {
                case 'dashboard':
                    state.currentSpecialView = 'dashboard';
                    state.currentSetId = null;
                    state.currentViewId = null;
                    break;
                case 'entities':
                    state.currentSpecialView = 'entities';
                    state.currentSetId = null;
                    state.currentViewId = null;
                    if (filterType) {
                        state.entityFormState = state.entityFormState || {};
                        state.entityFormState.selectedType = filterType;
                    }
                    break;
                case 'relations':
                    state.currentSpecialView = 'relations';
                    state.currentSetId = null;
                    state.currentViewId = null;
                    break;
                case 'definitions':
                    state.currentSpecialView = 'definitions';
                    state.currentSetId = null;
                    state.currentViewId = null;
                    break;
                case 'views':
                    state.currentSpecialView = 'views';
                    state.currentSetId = null;
                    state.currentViewId = null;
                    break;
                case 'search':
                    state.currentSpecialView = 'search';
                    state.currentSetId = null;
                    state.currentViewId = null;
                    // Open search modal
                    openSearchDataModal();
                    return; // Don't re-render for modal
                default:
                    console.warn('Unknown navigation target:', page);
                    return;
            }

            renderSidebar();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        // Helper functions for navigation actions
        function openAddRecordModal() {
            const setsForWorld = getSetsForWorld();
            if (setsForWorld.length === 0) {
                showToast('Please create a set first');
                return;
            }

            const viewSelect = document.getElementById('addRecordViewSelect');
            if (!viewSelect) return;

            viewSelect.innerHTML = '';

            // Populate with all views from all sets
            setsForWorld.forEach(set => {
                if (set.views && set.views.size > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = set.name;

                    Array.from(set.views.entries()).forEach(([viewId, view]) => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify({ setId: set.id, viewId });
                        option.textContent = view.name;
                        optgroup.appendChild(option);
                    });

                    viewSelect.appendChild(optgroup);
                }
            });

            if (viewSelect.options.length === 0) {
                showToast('Please create a view first');
                return;
            }

            // Pre-select current view if available
            if (state.currentSetId && state.currentViewId) {
                const currentValue = JSON.stringify({ setId: state.currentSetId, viewId: state.currentViewId });
                for (let i = 0; i < viewSelect.options.length; i++) {
                    if (viewSelect.options[i].value === currentValue) {
                        viewSelect.selectedIndex = i;
                        break;
                    }
                }
            }

            openModal('addRecordModal');
        }

        function importWorld() {
            document.getElementById('worldJsonInput')?.click();
        }

        function exportWorld() {
            exportJSON();
        }

        function handleAddViewClick() {
            // If a set is currently selected, use that
            if (state.currentSetId) {
                openAddViewModal(state.currentSetId);
                return;
            }

            // Otherwise, try to use the first available set
            const setsForWorld = getSetsForWorld();
            if (setsForWorld.length > 0) {
                openAddViewModal(setsForWorld[0].id);
            } else {
                showToast('Please create a set first');
            }
        }

        function toggleKnowledgeSection() {
            const titleEl = document.querySelector('.sidebar-section-title.collapsible');
            const contentEl = document.getElementById('knowledgeContent');
            if (titleEl && contentEl) {
                titleEl.classList.toggle('collapsed');
                contentEl.classList.toggle('collapsed');
            }
        }

        function getRecentImportViews() {
            // Get all views that are marked as import views and haven't expired
            const recentImports = [];
            const now = Date.now();

            if (state.views) {
                state.views.forEach((view) => {
                    if (view.isTemporary && view.importMetadata) {
                        // Check if it has expired (default 7 days)
                        const expiresAt = view.importMetadata.expiresAt;
                        if (!expiresAt || now < expiresAt) {
                            recentImports.push(view);
                        }
                    }
                });
            }

            // Sort by timestamp (most recent first)
            recentImports.sort((a, b) => {
                const timeA = a.importMetadata?.timestamp || 0;
                const timeB = b.importMetadata?.timestamp || 0;
                return timeB - timeA;
            });

            return recentImports;
        }

        function renderRecentImports() {
            const container = document.getElementById('navRecentImportsContainer');
            if (!container) return;

            const recentImports = getRecentImportViews();

            if (recentImports.length === 0) {
                container.innerHTML = '<div style="color: #9ca3af; font-size: 0.875rem; padding: 0.5rem 0;">No recent imports</div>';
                return;
            }

            container.innerHTML = '';
            recentImports.forEach(importView => {
                const importItem = document.createElement('div');
                importItem.className = `view-item ${importView.id === state.currentViewId ? 'active' : ''}`;
                importItem.style.display = 'flex';
                importItem.style.alignItems = 'center';
                importItem.style.justifyContent = 'space-between';
                importItem.style.gap = '0.5rem';

                const importLabel = document.createElement('div');
                importLabel.style.display = 'flex';
                importLabel.style.alignItems = 'center';
                importLabel.style.flex = '1';
                importLabel.style.minWidth = '0';
                importLabel.innerHTML = `
                    <span class="view-item-icon">${renderIcon(importView.icon || '')}</span>
                    <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${importView.name}</span>
                `;
                importLabel.onclick = () => {
                    switchSet(importView.setId, importView.id);
                };

                const actionsContainer = document.createElement('div');
                actionsContainer.style.display = 'flex';
                actionsContainer.style.gap = '4px';
                actionsContainer.style.opacity = '0.7';

                // Pin button
                const pinBtn = document.createElement('button');
                pinBtn.innerHTML = '<i class="ph ph-push-pin" style="font-size: 14px;"></i>';
                pinBtn.title = 'Pin to Views';
                pinBtn.style.cssText = 'background: none; border: none; color: #10b981; cursor: pointer; padding: 2px 4px;';
                pinBtn.onclick = (e) => {
                    e.stopPropagation();
                    pinImportToViews(importView.id);
                };

                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<i class="ph ph-x" style="font-size: 14px;"></i>';
                removeBtn.title = 'Remove';
                removeBtn.style.cssText = 'background: none; border: none; color: #ef4444; cursor: pointer; padding: 2px 4px;';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeImportView(importView.id);
                };

                actionsContainer.appendChild(pinBtn);
                actionsContainer.appendChild(removeBtn);

                importItem.appendChild(importLabel);
                importItem.appendChild(actionsContainer);
                container.appendChild(importItem);
            });
        }

        function pinImportToViews(viewId) {
            const view = state.views?.get(viewId);
            if (!view) return;

            // Remove temporary flag and import metadata
            view.isTemporary = false;
            delete view.importMetadata;

            // Update the view name to remove "Import: " prefix if present
            if (view.name.startsWith('Import: ')) {
                view.name = view.name.replace('Import: ', '');
            }

            // Log the pin event
            createEvent(
                'Import View Pinned',
                'UPD',
                { type: 'View', id: viewId },
                {
                    setId: view.setId,
                    viewName: view.name,
                    wasPinned: true
                }
            );

            showToast(' Import pinned to views');
            renderSidebar();
            renderCurrentView();
        }

        function removeImportView(viewId) {
            const view = state.views?.get(viewId);
            if (!view) return;

            if (!confirm(`Remove import "${view.name}"? The imported records will remain in the set.`)) {
                return;
            }

            // Remove the view
            const set = state.sets.get(view.setId);
            if (set && set.views) {
                set.views.delete(viewId);
            }
            state.views.delete(viewId);

            // Log the removal event
            createEvent(
                'Import View Removed',
                'DEL',
                { type: 'View', id: viewId },
                {
                    setId: view.setId,
                    viewName: view.name
                }
            );

            // If this was the current view, switch to the set default view
            if (state.currentViewId === viewId) {
                switchSet(view.setId, null);
            }

            showToast(' Import removed');
            renderSidebar();
        }

        function reifyImportView() {
            const view = getCurrentView();
            if (!view || !view.isTemporary || !view.importMetadata) return;

            const set = getCurrentSet();
            if (!set) return;

            // Mark all imported records as "reified" (permanent entities)
            const recordIds = Array.from(set.records.keys());
            let reifiedCount = 0;

            recordIds.forEach(recordId => {
                const record = set.records.get(recordId);
                if (record) {
                    // Add reified metadata to record
                    if (!record._metadata) {
                        record._metadata = {};
                    }
                    record._metadata.reified = true;
                    record._metadata.reifiedAt = Date.now();
                    record._metadata.reifiedBy = state.currentUser.id;
                    record._metadata.importSource = view.importMetadata.filename;
                    reifiedCount++;
                }
            });

            // Remove temporary flag and import metadata from view
            view.isTemporary = false;
            const importMetadata = view.importMetadata;
            delete view.importMetadata;

            // Update the view name to remove "Import: " prefix if present
            if (view.name.startsWith('Import: ')) {
                view.name = view.name.replace('Import: ', '');
            }

            // Log the reification event
            createEvent(
                'Import Reified',
                'UPD',
                { type: 'View', id: view.id },
                {
                    setId: view.setId,
                    viewName: view.name,
                    recordCount: reifiedCount,
                    originalFilename: importMetadata.filename,
                    wasReified: true
                }
            );

            showToast(` Import made permanent (${reifiedCount} records reified)`);
            renderSidebar();
            renderCurrentView();
        }

        function renderSidebar() {
            // Update world name in nav
            const worldNavName = document.getElementById('worldNavName');
            const world = getWorld();
            if (worldNavName && world) {
                worldNavName.textContent = world.name;
            }

            // Update active states for nav items
            const navItems = {
                'navDashboard': state.currentSpecialView === 'dashboard',
                'navEntities': state.currentSpecialView === 'entities',
                'navRelations': state.currentSpecialView === 'relations',
                'navDefinitions': state.currentSpecialView === 'definitions',
                'navViews': state.currentSpecialView === 'views',
                'navSearch': state.currentSpecialView === 'search',
                'navSuggestedViews': state.currentSpecialView === 'suggestedViews',
                'navSuggestedConcepts': state.currentSpecialView === 'suggestedConcepts'
            };

            Object.entries(navItems).forEach(([id, isActive]) => {
                const el = document.getElementById(id);
                if (el) {
                    el.classList.toggle('active', isActive);
                }
            });

            // Render recent imports
            renderRecentImports();

            // Populate sets in nav
            const setsContainer = document.getElementById('navSetsContainer');
            if (!setsContainer) return;

            setsContainer.innerHTML = '';
            const setsForWorld = getSetsForWorld();

            if (setsForWorld.length === 0) {
                setsContainer.innerHTML = '<div style="color: #9ca3af; font-size: 0.875rem; padding: 0.5rem 0;">No sets yet</div>';
            } else {
                setsForWorld.forEach(set => {
                    const isExpanded = state.expandedSets.has(set.id);
                    const hasViews = set.views && set.views.size > 0;

                    // Create set header with chevron
                    const setHeader = document.createElement('div');
                    setHeader.className = 'nav-item';
                    setHeader.style.display = 'flex';
                    setHeader.style.alignItems = 'center';
                    setHeader.style.justifyContent = 'space-between';

                    const setLabel = document.createElement('span');
                    setLabel.textContent = set.name;
                    setLabel.style.flex = '1';

                    const chevron = document.createElement('i');
                    chevron.className = `ph ${isExpanded ? 'ph-caret-down' : 'ph-caret-right'}`;
                    chevron.style.fontSize = '12px';
                    chevron.style.opacity = '0.7';
                    chevron.style.transition = 'transform 0.15s';

                    if (set.id === state.currentSetId && !state.currentSpecialView && !state.currentViewId) {
                        setHeader.classList.add('active');
                    }

                    setHeader.appendChild(setLabel);
                    if (hasViews) {
                        setHeader.appendChild(chevron);
                    }

                    setHeader.onclick = (e) => {
                        e.stopPropagation();
                        if (hasViews) {
                            toggleSetExpansion(set.id);
                        } else {
                            state.currentSetId = set.id;
                            state.currentViewId = null;
                            state.currentSpecialView = null;
                            renderCurrentView();
                            renderSidebar();
                        }
                    };

                    setsContainer.appendChild(setHeader);

                    // Render views under this set if expanded
                    if (isExpanded && hasViews) {
                        const viewsContainer = document.createElement('div');
                        viewsContainer.style.paddingLeft = '0.5rem';
                        viewsContainer.style.marginTop = '0.25rem';
                        viewsContainer.style.marginBottom = '0.5rem';

                        const orderedViews = Array.from(set.views.entries())
                            .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0));

                        renderViewTree(orderedViews, set.id, viewsContainer);
                        setsContainer.appendChild(viewsContainer);
                    }
                });
            }

            renderViewTabs();
        }

        function renderViewTree(orderedViews, setId, container, parentId = null, depth = 0) {
            const normalizedParent = parentId || null;
            const childViews = orderedViews.filter(([_, view]) => (view.parentId || null) === normalizedParent);

            childViews.forEach(([viewId, view]) => {
                const viewItem = document.createElement('div');
                viewItem.className = `view-item ${viewId === state.currentViewId ? 'active' : ''}`;
                viewItem.style.paddingLeft = `${12 + depth * 16}px`;
                viewItem.innerHTML = `
                    <span class="view-item-icon">${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])}</span>
                    <span>${view.name}</span>
                `;
                viewItem.onclick = (e) => {
                    e.stopPropagation();
                    switchSet(setId, viewId);
                };
                viewItem.ondblclick = (e) => { e.stopPropagation(); openAddViewModal(setId, viewId); };
                viewItem.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); openAddViewModal(setId, viewId); };

                container.appendChild(viewItem);
                renderViewTree(orderedViews, setId, container, viewId, depth + 1);
            });
        }

        function isViewDescendant(set, startId, potentialAncestorId) {
            let currentParent = set.views.get(startId)?.parentId || null;
            while (currentParent) {
                if (currentParent === potentialAncestorId) return true;
                currentParent = set.views.get(currentParent)?.parentId || null;
            }
            return false;
        }

        function populateViewParentOptions(setId, excludeViewId = null, selectedParentId = null) {
            const select = document.getElementById('newViewParent');
            if (!select) return;

            select.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'No parent';
            select.appendChild(defaultOption);

            const set = state.sets.get(setId);
            if (!set) return;

            const orderedViews = Array.from(set.views.entries());
            const renderOptions = (parentId = null, depth = 0) => {
                const children = orderedViews.filter(([id, view]) => (view.parentId || null) === (parentId || null));
                children.forEach(([id, view]) => {
                    if (excludeViewId && id === excludeViewId) return;
                    const option = document.createElement('option');
                    option.value = id;
                    option.innerHTML = `${' '.repeat(depth)}${renderIcon(view.icon || VIEW_TYPE_ICONS[view.type])} ${view.name}`;
                    select.appendChild(option);
                    renderOptions(id, depth + 1);
                });
            };

            renderOptions();
            select.value = selectedParentId || '';
        }

        function openAddViewModal(setId, viewId = null) {
            const set = state.sets.get(setId);
            if (!set) return;

            const titleEl = document.getElementById('addViewModalTitle');
            const saveBtn = document.getElementById('saveAddViewBtn');
            const nameInput = document.getElementById('newViewName');
            const iconInput = document.getElementById('newViewIcon');
            const keySelect = document.getElementById('keyCandidateSelect');
            const radioBlank = document.querySelector('input[name="viewCreationMode"][value="blank"]');
            const radioKey = document.querySelector('input[name="viewCreationMode"][value="key"]');

            state.currentSetId = setId;
            if (viewId) {
                const view = set.views.get(viewId);
                state.viewEditorContext = { setId, viewId };
                if (titleEl) titleEl.textContent = 'Edit View';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = view?.name || '';
                if (iconInput) iconInput.value = extractIconToken(view?.icon || VIEW_TYPE_ICONS[view?.type]);
                populateViewParentOptions(setId, viewId, view?.parentId || null);
                if (radioBlank && radioKey) {
                    radioBlank.checked = view?.type !== 'KEY_DERIVED';
                    radioKey.checked = view?.type === 'KEY_DERIVED';
                }
                if (keySelect && view?.type === 'KEY_DERIVED' && view.key) {
                    const optionValue = `${view.key.setId}:${view.key.fieldId}`;
                    keySelect.innerHTML = `<option value="${optionValue}">${view.key.fieldId}</option>`;
                    keySelect.disabled = true;
                }
            } else {
                state.viewEditorContext = { setId, viewId: null };
                if (titleEl) titleEl.textContent = 'Create View';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-table';
                populateViewParentOptions(setId);

                // Show modal immediately with loading state for key candidates
                if (keySelect) {
                    keySelect.disabled = true;
                    keySelect.innerHTML = '<option value="">Scanning for identity properties</option>';
                }
                if (radioBlank && radioKey) {
                    radioBlank.checked = true;
                    radioKey.checked = false;
                }

                // Find key candidates asynchronously to avoid blocking UI
                setTimeout(() => {
                    const candidates = findKeyCandidates();
                    if (keySelect) {
                        keySelect.disabled = candidates.length === 0;
                        keySelect.innerHTML = candidates.length === 0
                            ? '<option value="">No stable identity properties detected yet</option>'
                            : candidates.map(c => `<option value="${c.setId}:${c.fieldId}">${c.fieldName} (${state.sets.get(c.setId)?.name || 'Set'})</option>`).join('');

                        // Re-check if key mode is selected and update disabled state
                        const selectedMode = document.querySelector('input[name="viewCreationMode"]:checked')?.value;
                        if (selectedMode === 'key') {
                            keySelect.disabled = candidates.length === 0;
                        }
                    }
                }, 0);
            }

            syncIconSelector('newViewIcon');
            openModal('addViewModal');
        }

        function getTabKey(setId, viewId) {
            return `${setId || ''}::${viewId || ''}`;
        }

        function ensureOpenTab(setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;
            const key = getTabKey(setId, viewId);
            const exists = state.openTabs.some(tab => getTabKey(tab.setId, tab.viewId) === key);
            if (!exists) {
                state.openTabs.push({ setId, viewId });
            }
            renderViewTabs();
        }

        function closeViewTab(setId, viewId) {
            const key = getTabKey(setId, viewId);
            const index = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId) === key);
            if (index === -1) return;
            const closingActive = state.currentSetId === setId && state.currentViewId === viewId;
            const fallback = closingActive ? (state.openTabs[index + 1] || state.openTabs[index - 1]) : null;
            state.openTabs.splice(index, 1);
            renderViewTabs();

            if (closingActive) {
                if (fallback) {
                    switchSet(fallback.setId, fallback.viewId);
                } else {
                    state.currentSetId = null;
                    state.currentViewId = null;
                    renderSidebar();
                    renderCurrentView();
                    updateMobileChrome();
                }
            }
        }

        function showViewTabContextMenu(event, setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;

            // Remove any existing context menu
            document.querySelectorAll('.view-tab-context-menu').forEach(menu => menu.remove());

            const menu = document.createElement('div');
            menu.className = 'context-menu view-tab-context-menu';
            menu.innerHTML = `
                <div class="menu-item" data-action="edit">
                    <span class="icon"></span> Edit View
                </div>
                <div class="menu-item" data-action="duplicate">
                    <span class="icon"></span> Duplicate
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" data-action="close">
                    <span class="icon"></span> Close Tab
                </div>
                <div class="menu-item danger" data-action="delete">
                    <span class="icon"></span> Delete View
                </div>
            `;

            menu.style.position = 'fixed';
            menu.style.top = `${event.clientY}px`;
            menu.style.left = `${event.clientX}px`;
            menu.style.zIndex = '10000';

            document.body.appendChild(menu);

            // Handle menu item clicks
            menu.querySelectorAll('.menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const action = item.dataset.action;
                    menu.remove();

                    switch (action) {
                        case 'edit':
                            showEditViewDialog(setId, viewId);
                            break;
                        case 'duplicate':
                            const newName = `${view.name} (copy)`;
                            cloneView(state, viewId, newName);
                            renderSidebar();
                            renderViewTabs();
                            break;
                        case 'close':
                            closeViewTab(setId, viewId);
                            break;
                        case 'delete':
                            if (confirm(`Delete view "${view.name}"? This cannot be undone.`)) {
                                deleteView(state, viewId);
                                closeViewTab(setId, viewId);
                                renderSidebar();
                            }
                            break;
                    }
                });
            });

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 0);
        }

        function showEditViewDialog(setId, viewId) {
            const set = state.sets.get(setId);
            const view = set?.views.get(viewId);
            if (!set || !view) return;

            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay';
            dialog.innerHTML = `
                <div class="modal edit-view-modal">
                    <div class="modal-header">
                        <h2>Edit View</h2>
                        <button class="modal-close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label>View Name</label>
                            <input type="text" id="edit-view-name" placeholder="Untitled view" value="${view.name}">
                        </div>
                        <div class="form-group">
                            <label>Icon</label>
                            <div id="editViewIconSelector" class="icon-selector" role="button" tabindex="0">
                                <div id="editViewIconPreview" class="icon-selector-icon" aria-hidden="true">${view.icon || VIEW_TYPE_ICONS[view.type]}</div>
                                <div class="icon-selector-text">
                                    <div class="icon-selector-label">Choose an icon</div>
                                    <div id="editViewIconToken" class="icon-selector-token">${view.icon || VIEW_TYPE_ICONS[view.type]}</div>
                                </div>
                                <span class="icon-selector-chevron"></span>
                            </div>
                            <input type="hidden" id="edit-view-icon" value="${view.icon || VIEW_TYPE_ICONS[view.type]}">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-secondary modal-close">Cancel</button>
                        <button class="btn-primary" id="btn-save-view">Save Changes</button>
                    </div>
                </div>
            `;

            document.body.appendChild(dialog);

            // Setup icon selector for this dialog
            const iconSelectorId = 'edit-view-icon';
            ICON_SELECTOR_TARGETS[iconSelectorId] = {
                inputId: iconSelectorId,
                selectorId: 'editViewIconSelector',
                previewId: 'editViewIconPreview',
                tokenId: 'editViewIconToken'
            };
            bindIconSelector(iconSelectorId);

            // Event listeners
            dialog.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    delete ICON_SELECTOR_TARGETS[iconSelectorId];
                    dialog.remove();
                });
            });

            dialog.querySelector('#btn-save-view').addEventListener('click', () => {
                const name = dialog.querySelector('#edit-view-name').value.trim() || 'Untitled view';
                const icon = dialog.querySelector('#edit-view-icon').value;

                updateView(state, viewId, { name, icon });

                delete ICON_SELECTOR_TARGETS[iconSelectorId];
                dialog.remove();

                // Re-render everything to show the changes
                renderSidebar();
                renderViewTabs();
                renderCurrentView();
            });

            // Focus the name input
            setTimeout(() => {
                dialog.querySelector('#edit-view-name')?.focus();
            }, 100);
        }

        function reorderOpenTabs(dragKey, targetKey, position) {
            const fromIndex = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId) === dragKey);
            const targetIndex = state.openTabs.findIndex(tab => getTabKey(tab.setId, tab.viewId) === targetKey);
            if (fromIndex === -1 || targetIndex === -1 || dragKey === targetKey) return;

            const [dragged] = state.openTabs.splice(fromIndex, 1);
            const adjustedTarget = fromIndex < targetIndex ? targetIndex - 1 : targetIndex;
            const insertIndex = position === 'before' ? adjustedTarget : adjustedTarget + 1;
            state.openTabs.splice(insertIndex, 0, dragged);
            renderViewTabs();
        }

        function clearTabDropIndicators() {
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.remove('tab-drop-before', 'tab-drop-after', 'tab-being-dragged');
            });
        }

        function handleTabDragStart(event, tab) {
            const key = getTabKey(tab.setId, tab.viewId);
            tabDragState.draggingKey = key;
            tabDragState.dropKey = null;
            tabDragState.dropPosition = null;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', key);
            event.currentTarget.classList.add('tab-being-dragged');
        }

        function handleTabDragOver(event, targetTab) {
            if (!tabDragState.draggingKey) return;
            event.preventDefault();

            const targetKey = getTabKey(targetTab.setId, targetTab.viewId);
            if (targetKey === tabDragState.draggingKey) return;

            const rect = event.currentTarget.getBoundingClientRect();
            const position = event.clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            clearTabDropIndicators();
            event.currentTarget.classList.add(position === 'before' ? 'tab-drop-before' : 'tab-drop-after');
            tabDragState.dropKey = targetKey;
            tabDragState.dropPosition = position;
        }

        function finalizeTabDrag() {
            clearTabDropIndicators();
            tabDragState.draggingKey = null;
            tabDragState.dropKey = null;
            tabDragState.dropPosition = null;
        }

        function handleTabDrop(event, targetTab) {
            if (!tabDragState.draggingKey) return;
            event.preventDefault();
            const targetKey = getTabKey(targetTab.setId, targetTab.viewId);
            const position = tabDragState.dropPosition || 'after';
            reorderOpenTabs(tabDragState.draggingKey, targetKey, position);
            finalizeTabDrag();
        }

        function renderViewTabs() {
            const container = document.getElementById('viewTabs');
            const surface = document.getElementById('viewSurface');
            if (!container) return;

            const validatedTabs = [];
            state.openTabs.forEach(tab => {
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (set && view) validatedTabs.push(tab);
            });
            state.openTabs = validatedTabs;

            if (state.openTabs.length === 0) {
                container.innerHTML = '';
                container.classList.add('hidden');
                if (state.currentSpecialView) {
                    surface?.classList.remove('hidden');
                } else {
                    surface?.classList.add('hidden');
                }
                return;
            }

            container.classList.remove('hidden');
            surface?.classList.remove('hidden');
            container.innerHTML = '';

            state.openTabs.forEach((tab, index) => {
                const set = state.sets.get(tab.setId);
                const view = set?.views.get(tab.viewId);
                if (!set || !view) return;
                const isActive = state.currentSetId === tab.setId && state.currentViewId === tab.viewId;
                const tabKey = getTabKey(tab.setId, tab.viewId);

                const tabEl = document.createElement('div');
                tabEl.className = `view-tab ${isActive ? 'active' : ''}`;
                tabEl.dataset.tabKey = tabKey;
                tabEl.draggable = true;
                tabEl.onclick = () => switchSet(tab.setId, tab.viewId);
                tabEl.oncontextmenu = (e) => { e.preventDefault(); showViewTabContextMenu(e, tab.setId, tab.viewId); };
                tabEl.ondragstart = (e) => handleTabDragStart(e, tab);
                tabEl.ondragover = (e) => handleTabDragOver(e, tab);
                tabEl.ondragleave = () => clearTabDropIndicators();
                tabEl.ondrop = (e) => handleTabDrop(e, tab);
                tabEl.ondragend = finalizeTabDrag;

                const iconSpan = document.createElement('span');
                iconSpan.className = 'view-tab-icon';
                iconSpan.innerHTML = renderIcon(view.icon || VIEW_TYPE_ICONS[view.type]);

                const textWrap = document.createElement('div');
                textWrap.className = 'view-tab-text';
                textWrap.innerHTML = `
                    <span class="view-tab-name">${view.name}</span>
                    <span class="view-tab-meta">${set.name}</span>
                `;

                const actions = document.createElement('div');
                actions.className = 'view-tab-actions';

                const closeBtn = document.createElement('button');
                closeBtn.className = 'view-tab-btn';
                closeBtn.innerHTML = '<i class="ph ph-x"></i>';
                closeBtn.onclick = (e) => { e.stopPropagation(); closeViewTab(tab.setId, tab.viewId); };

                actions.appendChild(closeBtn);

                tabEl.appendChild(iconSpan);
                tabEl.appendChild(textWrap);
                tabEl.appendChild(actions);

                container.appendChild(tabEl);
            });
        }

        function switchSet(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set) return;
            if (set.worldId && state.currentWorldId !== set.worldId) {
                state.currentWorldId = set.worldId;
                renderWorldSelector();
            }
            state.currentSpecialView = null;
            state.currentSetId = setId;
            state.currentViewId = viewId;
            if (!viewId && set.views.size > 0) {
                state.currentViewId = Array.from(set.views.keys())[0];
            }
            if (state.currentViewId) ensureOpenTab(state.currentSetId, state.currentViewId);
            closeMobileSidebar();
            renderSidebar();
            renderViewTabs();
            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function getCurrentSet() { return state.sets.get(state.currentSetId); }
        function getCurrentView() { const set = getCurrentSet(); return set?.views.get(state.currentViewId); }
        function getCurrentProfile() { const set = getCurrentSet(); return set?.profiles.get(state.currentProfileId); }

        // VIEW SWITCHING
        function switchViewType(type) {
            const view = getCurrentView();
            if (!view) return;
            view.type = type;

            renderCurrentView();
            updateMobileChrome();
            // syncUrlState(); // Commented out to prevent URL manipulation
        }

        function renderCurrentView() {
            const container = document.getElementById('viewContainer');

            // Dashboard (new landing page)
            if (state.currentSpecialView === 'dashboard') {
                renderDashboardPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'entities') {
                renderEntitiesPage();
                updateMobileChrome();
                return;
            }
            if (state.currentSpecialView === 'definitions') {
                renderDefinitionsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'relations') {
                renderRelationsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'visualizations') {
                renderVisualizationsPage();
                updateMobileChrome();
                return;
            }

            if (state.currentSpecialView === 'views') {
                renderViewsPage();
                updateMobileChrome();
                return;
            }

            const view = getCurrentView();
            if (!view) {
                if (container) container.innerHTML = '<div class="p-6 text-sm text-gray-500">Select a view to get started.</div>';
                return;
            }

            ensureViewDefaults(view);

            updateMobileChrome();

            switch(view.type) {
                case 'grid':
                    renderGridView();
                    break;
                case 'card':
                    renderCardView();
                    break;
                case 'kanban':
                    renderKanbanView();
                    break;
                case 'graph':
                    renderGraphView();
                    break;
                case 'KEY_DERIVED':
                    renderKeyDerivedView();
                    break;
            }
        }

        function ensureViewDefaults(view) {
            if (!view.icon) view.icon = VIEW_TYPE_ICONS[view.type] || 'ph-note';
            if (!view.sorts) view.sorts = [];
            if (!view.columnRules) view.columnRules = {};
            if (typeof view.showRecordId === 'undefined') view.showRecordId = false;
            if (typeof view.showRowNumbers === 'undefined') view.showRowNumbers = true;
        }

        function syncSelectionState(visibleRecords = []) {
            const set = getCurrentSet();
            if (!set) return;

            const visibleIds = visibleRecords.map(r => r.id);
            const validIds = new Set(visibleIds.length ? visibleIds : Array.from(set.records.keys()));
            state.selectedRecordIds = new Set(
                [...(state.selectedRecordIds || new Set())].filter(id => validIds.has(id))
            );

            if (state.selectedRecordIds.size === 0) state.lastSelectedRecordId = null;
        }

        function handleRecordSelection(recordId, isRange, orderedRecords = []) {
            const visibleIds = orderedRecords.map(r => r.id);
            if (!state.selectedRecordIds) state.selectedRecordIds = new Set();

            if (isRange && state.lastSelectedRecordId && visibleIds.includes(state.lastSelectedRecordId)) {
                const startIndex = visibleIds.indexOf(state.lastSelectedRecordId);
                const endIndex = visibleIds.indexOf(recordId);
                if (startIndex >= 0 && endIndex >= 0) {
                    const [from, to] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
                    for (let i = from; i <= to; i++) {
                        state.selectedRecordIds.add(visibleIds[i]);
                    }
                }
            } else {
                if (state.selectedRecordIds.has(recordId)) state.selectedRecordIds.delete(recordId);
                else state.selectedRecordIds.add(recordId);
                state.lastSelectedRecordId = recordId;
            }

            updateSelectionUI(orderedRecords);
        }

        function updateSelectionUI(visibleRecords = []) {
            const rows = document.querySelectorAll('#tableBody tr');
            rows.forEach(row => {
                const id = row.dataset.recordId;
                const isSelected = state.selectedRecordIds?.has(id);
                row.classList.toggle('row-selected', !!isSelected);
                const checkbox = row.querySelector('input[data-row-select]');
                if (checkbox) checkbox.checked = !!isSelected;
            });

            const visibleIds = visibleRecords.map(r => r.id);
            const selectedVisibleCount = visibleIds.filter(id => state.selectedRecordIds?.has(id)).length;
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                const allSelected = visibleIds.length > 0 && selectedVisibleCount === visibleIds.length;
                selectAllCheckbox.checked = allSelected;
                selectAllCheckbox.indeterminate = selectedVisibleCount > 0 && !allSelected;
            }

            const indicator = document.getElementById('selectionIndicator');
            const countEl = document.getElementById('selectedCount');
            if (indicator && countEl) {
                const count = state.selectedRecordIds?.size || 0;
                indicator.classList.toggle('hidden', count === 0);
                countEl.textContent = count;
            }

            const deleteBtn = document.getElementById('deleteSelectedBtn');
            if (deleteBtn) deleteBtn.disabled = !state.selectedRecordIds || state.selectedRecordIds.size === 0;
        }

        function handleDeleteSelectedRecords() {
            const set = getCurrentSet();
            if (!set || !state.selectedRecordIds || state.selectedRecordIds.size === 0) return;

            const ids = [...state.selectedRecordIds].filter(id => set.records.has(id));
            if (ids.length === 0) return;

            const message = `Are you sure you want to delete ${ids.length} selected record${ids.length === 1 ? '' : 's'}? ` +
                'All changes are reversible while within your retention window (future thresholds may limit recovery).';

            showConfirm(message, () => {
                ids.forEach(recordId => {
                    set.records.delete(recordId);
                    createEvent(
                        'Delete Record',
                        'NUL',
                        { type: 'Record', id: recordId, setId: set.id },
                        { setId: set.id, recordId, summary: 'Record deleted' }
                    );
                });

                state.selectedRecordIds.clear();
                state.lastSelectedRecordId = null;
                renderCurrentView();
                showToast(' Selected records deleted (reversible while within retention)');
            });
        }

        function getRecordIdFieldDefinition() {
            return { id: '__recordId', name: 'Record ID', type: 'RECORD_ID', width: '200' };
        }

        function applyColumnWidth(fieldId, width) {
            const normalizedWidth = clampColumnWidth(width);
            const widthPx = `${normalizedWidth}px`;
            const set = getCurrentSet();
            const field = set?.schema.find(f => f.id === fieldId);
            if (field) field.width = widthPx;

            document.querySelectorAll(`[data-field-id="${fieldId}"]`).forEach(el => {
                el.style.width = widthPx;
            });

            const table = document.getElementById('dataTable');
            if (table && set) {
                const totalWidth = set.schema.reduce((sum, f) => sum + getFieldWidth(f), 0);
                table.style.minWidth = `${Math.max(totalWidth, 600)}px`;
            }
        }

        function addColumnResizer(element, field) {
            const existingResizer = element.querySelector('.column-resizer');
            if (existingResizer) return;

            const resizer = document.createElement('div');
            resizer.className = 'column-resizer';
            element.appendChild(resizer);

            let startX = 0;
            let startWidth = getFieldWidth(field);

            const onMouseMove = (event) => {
                const delta = event.clientX - startX;
                applyColumnWidth(field.id, startWidth + delta);
            };

            const onMouseUp = () => {
                document.body.classList.remove('resizing');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            resizer.addEventListener('mousedown', (event) => {
                event.stopPropagation();
                event.preventDefault();
                startX = event.clientX;
                startWidth = getFieldWidth(field);
                document.body.classList.add('resizing');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function getPointerPosition(event) {
            if (!event) return { clientX: 0, clientY: 0 };
            if (event.touches && event.touches.length > 0) {
                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
            }
            if (event.changedTouches && event.changedTouches.length > 0) {
                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
            }
            return { clientX: event.clientX, clientY: event.clientY };
        }

        function createColumnGhost(element, position) {
            const ghost = document.createElement('div');
            ghost.className = 'column-drag-ghost';
            ghost.style.width = `${element.offsetWidth}px`;
            ghost.innerHTML = element.innerHTML;
            ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            document.body.appendChild(ghost);
            return ghost;
        }

        function clearColumnDropIndicators() {
            document.querySelectorAll('#tableHeader .column-header').forEach(header => {
                header.classList.remove('column-drop-before', 'column-drop-after');
            });
        }

        function updateColumnDropTarget(clientX) {
            const headers = Array.from(document.querySelectorAll('#tableHeader .column-header'));
            clearColumnDropIndicators();

            const target = headers.find(h => {
                const rect = h.getBoundingClientRect();
                return clientX >= rect.left && clientX <= rect.right;
            });

            if (!target || target.dataset.fieldId === columnDragState.draggedFieldId) {
                columnDragState.dropFieldId = null;
                columnDragState.dropPosition = null;
                return;
            }

            const rect = target.getBoundingClientRect();
            const position = clientX < rect.left + rect.width / 2 ? 'before' : 'after';
            target.classList.add(position === 'before' ? 'column-drop-before' : 'column-drop-after');
            columnDragState.dropFieldId = target.dataset.fieldId;
            columnDragState.dropPosition = position;
        }

        function reorderSchemaField(draggedFieldId, targetFieldId, position) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const columnOrder = ensureViewColumnOrder(view, set.schema, view.showRecordId);
            const fromIndex = columnOrder.indexOf(draggedFieldId);
            let targetIndex = columnOrder.indexOf(targetFieldId);
            if (fromIndex === -1 || targetIndex === -1) return;

            const [moved] = columnOrder.splice(fromIndex, 1);
            if (fromIndex < targetIndex) targetIndex -= 1;
            const insertIndex = position === 'after' ? targetIndex + 1 : targetIndex;
            columnOrder.splice(insertIndex, 0, moved);
            view.columnOrder = columnOrder;

            if (draggedFieldId !== '__recordId' && targetFieldId !== '__recordId') {
                const schemaFrom = set.schema.findIndex(f => f.id === draggedFieldId);
                let schemaTarget = set.schema.findIndex(f => f.id === targetFieldId);
                if (schemaFrom === -1 || schemaTarget === -1) return;

                const [field] = set.schema.splice(schemaFrom, 1);
                if (schemaFrom < schemaTarget) schemaTarget -= 1;
                const schemaInsert = position === 'after' ? schemaTarget + 1 : schemaTarget;
                set.schema.splice(schemaInsert, 0, field);
            }
        }

        function endColumnDrag() {
            resetColumnGrabState(columnDragState.sourceElement);
            document.body.classList.remove('column-dragging');
            document.removeEventListener('mousemove', handleColumnDragMove);
            document.removeEventListener('touchmove', handleColumnDragMove);
            document.removeEventListener('mouseup', endColumnDrag);
            document.removeEventListener('touchend', endColumnDrag);
            document.removeEventListener('touchcancel', endColumnDrag);

            if (columnDragState.ghost) columnDragState.ghost.remove();
            if (columnDragState.sourceElement) columnDragState.sourceElement.classList.remove('column-being-dragged');
            clearColumnDropIndicators();

            if (columnDragState.draggedFieldId && columnDragState.dropFieldId) {
                reorderSchemaField(columnDragState.draggedFieldId, columnDragState.dropFieldId, columnDragState.dropPosition);
                renderCurrentView();
            }

            columnDragState.draggedFieldId = null;
            columnDragState.dropFieldId = null;
            columnDragState.dropPosition = null;
            columnDragState.ghost = null;
            columnDragState.sourceElement = null;

            setTimeout(() => { columnDragState.preventClick = false; }, 30);
        }

        function handleColumnDragMove(event) {
            if (!columnDragState.draggedFieldId || !columnDragState.ghost) return;
            if (event.cancelable) event.preventDefault();
            const position = getPointerPosition(event);
            columnDragState.ghost.style.left = `${position.clientX - columnDragState.offsetX}px`;
            columnDragState.ghost.style.top = `${position.clientY - columnDragState.offsetY}px`;
            updateColumnDropTarget(position.clientX);
        }

        function startColumnDrag(startPosition, element, field) {
            columnDragState.timer = null;
            columnDragState.holdReady = false;
            columnDragState.draggedFieldId = field.id;
            columnDragState.sourceElement = element;
            columnDragState.preventClick = true;

            const rect = element.getBoundingClientRect();
            columnDragState.offsetX = startPosition.clientX - rect.left;
            columnDragState.offsetY = startPosition.clientY - rect.top;

            columnDragState.ghost = createColumnGhost(element, startPosition);
            element.classList.add('column-being-dragged');
            document.body.classList.add('column-dragging');

            document.addEventListener('mousemove', handleColumnDragMove);
            document.addEventListener('touchmove', handleColumnDragMove, { passive: false });
            document.addEventListener('mouseup', endColumnDrag);
            document.addEventListener('touchend', endColumnDrag);
            document.addEventListener('touchcancel', endColumnDrag);
        }

        function resetColumnGrabState(element) {
            if (columnDragState.holdTimer) {
                clearTimeout(columnDragState.holdTimer);
                columnDragState.holdTimer = null;
            }
            columnDragState.holdReady = false;
            if (element) element.classList.remove('column-grab-ready');
            document.body.classList.remove('column-grab-ready');
        }

        function setupColumnDragInteractions(element, field) {
            let pointerActive = false;
            let dragStarted = false;
            let startPosition = null;

            const handlePointerDown = (event) => {
                if (event.button !== undefined && event.button !== 0) return;
                if (event.target.closest('.column-resizer')) return;
                pointerActive = true;
                dragStarted = false;
                startPosition = getPointerPosition(event);
                resetColumnGrabState(element);
                columnDragState.holdTimer = setTimeout(() => {
                    if (!pointerActive || dragStarted) return;
                    columnDragState.holdReady = true;
                    element.classList.add('column-grab-ready');
                    document.body.classList.add('column-grab-ready');
                }, 180);
            };

            const handlePointerMove = (event) => {
                if (!pointerActive || dragStarted) return;
                const position = getPointerPosition(event);
                const deltaX = Math.abs(position.clientX - startPosition.clientX);
                const deltaY = Math.abs(position.clientY - startPosition.clientY);
                if (!columnDragState.holdReady) {
                    if (deltaX > 6 || deltaY > 6) resetColumnGrabState(element);
                    return;
                }
                if (deltaX > 6 || deltaY > 6) {
                    dragStarted = true;
                    resetColumnGrabState(element);
                    startColumnDrag(position, element, field);
                }
            };

            const resetPointerState = () => {
                pointerActive = false;
                dragStarted = false;
                resetColumnGrabState(element);
                startPosition = null;
            };

            element.addEventListener('mousedown', handlePointerDown);
            element.addEventListener('touchstart', handlePointerDown);
            element.addEventListener('mousemove', handlePointerMove);
            element.addEventListener('touchmove', handlePointerMove, { passive: false });
            element.addEventListener('mouseup', resetPointerState);
            element.addEventListener('mouseleave', resetPointerState);
            element.addEventListener('touchend', resetPointerState);
            element.addEventListener('touchcancel', resetPointerState);
        }

        // GRID VIEW
        function renderGridView() {
            const set = getCurrentSet();
            if (!set) return;

            const previousSelection = state.selectedCell
                ? { recordId: state.selectedCell.recordId, fieldId: state.selectedCell.fieldId }
                : state.lastSelectedCell;
            state.selectedCell = null;
            state.editingCell = null;

            const view = getCurrentView();
            const profile = getCurrentProfile();
            if (view && !view.identifierField) view.identifierField = inferIdentifierFieldId(set);
            const schema = set.schema.filter(f =>
                !profile || profile.visibleFields.length === 0 || profile.visibleFields.includes(f.id)
            );

            const tableSchema = buildTableSchema(view, schema);

            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, tableSchema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            syncSelectionState(records);

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Grid view  ${recordCount} ${recordLabel}</div>
                        </div>
                    </div>
                    ${renderViewActions()}
                </div>
                <div class="view-stage-body">
                    <div class="view-table-shell">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${recordCount} ${recordLabel}</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');

            // Checkbox column comes first (leftmost)
            const selectAllHeader = document.createElement('th');
            selectAllHeader.className = 'column-header selection-header';
            selectAllHeader.innerHTML = `<input type="checkbox" id="selectAllRows" aria-label="Select all rows">`;
            headerRow.appendChild(selectAllHeader);

            // Row numbers come after checkbox
            if (view.showRowNumbers) {
                const rowNumberHeader = document.createElement('th');
                rowNumberHeader.className = 'column-header row-number-header';
                rowNumberHeader.innerHTML = '#';
                rowNumberHeader.oncontextmenu = (e) => {
                    e.preventDefault();
                    showContextMenu(e, [
                        { label: 'Hide Row Numbers', action: () => toggleRowNumbers(false) }
                    ]);
                };
                headerRow.appendChild(rowNumberHeader);
            }

            tableSchema.forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.type = field.type;
                th.dataset.fieldId = field.id;
                const width = `${getFieldWidth(field)}px`;
                th.style.width = width;
                const sortIndex = view?.sorts?.findIndex(s => s.fieldId === field.id) ?? -1;
                const sortConfig = sortIndex >= 0 ? view.sorts[sortIndex] : null;
                const directionIcon = sortConfig ? (sortConfig.direction === 'desc' ? '' : '') : '';
                const indicatorClass = sortConfig ? 'sort-indicator' : 'sort-indicator muted';
                const orderBadge = sortConfig ? `<span class="order-badge">${sortIndex + 1}</span>` : '';
                const isNameField = view?.identifierField === field.id;
                const headerTitle = `
                    <span class="column-title">
                        <span>${field.name}</span>
                        ${isNameField ? '<span class="column-badge">Name</span>' : ''}
                    </span>
                `;
                th.innerHTML = `${headerTitle}<span class="${indicatorClass}"><span class="direction-icon">${directionIcon}</span>${orderBadge}</span>`;
                th.title = isNameField ? 'This is the Name field (right-click for options)' : 'Click to sort, right-click to set as Name or for more options';
                th.onclick = () => {
                    if (columnDragState.preventClick) return;
                    toggleColumnSort(field.id);
                };
                addColumnResizer(th, field);
                setupColumnDragInteractions(th, field);
                th.oncontextmenu = (e) => { e.preventDefault(); showColumnMenu(e, field); };
                headerRow.appendChild(th);
            });

            const table = document.getElementById('dataTable');
            const minimumTableWidth = tableSchema.reduce((sum, field) => sum + getFieldWidth(field), 0);
            table.style.minWidth = `${Math.max(minimumTableWidth, 600)}px`;

            const tbody = document.getElementById('tableBody');
            records.forEach((record, index) => {
                const tr = document.createElement('tr');
                tr.dataset.recordId = record.id;

                tr.onclick = (event) => {
                    if (event.defaultPrevented) return;

                    const interactiveTarget = event.target.closest(
                        'button, a, input, select, textarea, label, [contenteditable="true"], .cell-editing'
                    );
                    if (interactiveTarget) return;

                    // Click on row background opens record modal (cells handle their own clicks)
                    openExpandedRecord(record.id);
                };

                // Checkbox cell comes first (leftmost)
                const selectTd = document.createElement('td');
                selectTd.className = 'row-select-cell';
                const checkboxId = `select-${record.id}`;
                selectTd.innerHTML = `<input type="checkbox" data-row-select id="${checkboxId}" aria-label="Select record ${record.id}">`;
                const rowCheckbox = selectTd.querySelector('input');
                rowCheckbox.checked = state.selectedRecordIds?.has(record.id);
                rowCheckbox.onchange = (event) => {
                    event.stopPropagation();
                    handleRecordSelection(record.id, event.shiftKey, records);
                };
                tr.appendChild(selectTd);

                // Row number cell comes after checkbox
                if (view.showRowNumbers) {
                    const rowNumberTd = document.createElement('td');
                    rowNumberTd.className = 'row-number-cell';
                    rowNumberTd.textContent = index + 1;
                    tr.appendChild(rowNumberTd);
                }

                tableSchema.forEach(field => {
                    const td = document.createElement('td');
                    const isRecordIdColumn = field.id === '__recordId';
                    td.className = isRecordIdColumn ? 'cell-static' : 'cell-editable';
                    td.dataset.recordId = record.id;
                    td.dataset.fieldId = field.id;
                    td.style.width = `${getFieldWidth(field)}px`;
                    const value = record[field.id];
                    td.innerHTML = renderCellValue(value, field, record);
                    addColumnResizer(td, field);
                    if (isRecordIdColumn) {
                        td.onclick = (e) => { e.stopPropagation(); openExpandedRecord(record.id); };
                    } else if (field.type === 'CHECKBOX') {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            const now = Date.now();
                            if (td._lastToggleTime && now - td._lastToggleTime < 250) return;
                            td._lastToggleTime = now;
                            toggleCheckbox(record.id, field.id);
                        };
                    } else {
                        td.onclick = (e) => {
                            e.stopPropagation();
                            handleCellClick(td, record.id, field);
                        };
                    }
                    if (!isRecordIdColumn) {
                        td.oncontextmenu = (e) => { e.preventDefault(); showCellMenu(e, record.id, field); };
                    }
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            // Focus on newly added record if it exists
            if (state.newlyAddedRecordId) {
                const newRecordRow = tbody.querySelector(`[data-record-id="${state.newlyAddedRecordId}"]`);
                if (newRecordRow) {
                    // Find the first editable cell in the new record
                    const firstEditableCell = newRecordRow.parentElement.querySelector(`[data-record-id="${state.newlyAddedRecordId}"].cell-editable`);
                    if (firstEditableCell) {
                        const fieldId = firstEditableCell.getAttribute('data-field-id');
                        selectCell(firstEditableCell, state.newlyAddedRecordId, fieldId);
                        // Scroll into view
                        firstEditableCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
                state.newlyAddedRecordId = null;
            } else if (previousSelection) {
                const match = tbody.querySelector(`[data-record-id="${previousSelection.recordId}"][data-field-id="${previousSelection.fieldId}"]`);
                if (match) {
                    selectCell(match, previousSelection.recordId, previousSelection.fieldId);
                }
            }

            wireViewStageActions();
            setupToolbarMenu();
        }

        function renderKeyDerivedView() {
            const view = getCurrentView();
            if (!view?.key) return renderGridView();

            const keyRef = view.key;
            const allItems = findAllItemsForKey(keyRef.setId, keyRef.fieldId);
            const grouped = groupByKeyValue(allItems, keyRef.fieldId);
            const rows = buildRowsFromGroups(grouped, view);

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${state.sets.get(keyRef.setId)?.name || 'Key set'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Generated key view  ${rows.length} collections</div>
                        </div>
                    </div>
                    ${renderViewActions()}
                </div>
                <div class="view-stage-body">
                    <div class="view-table-shell">
                        <div class="table-scroll">
                            <table id="dataTable" class="border-collapse">
                                <thead><tr id="tableHeader"></tr></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                        <div class="table-footer">
                            <span class="record-counter" id="recordCounter">${rows.length} collections</span>
                        </div>
                    </div>
                </div>
            `;

            const headerRow = document.getElementById('tableHeader');
            headerRow.innerHTML = '';
            const keyHeader = document.createElement('th');
            keyHeader.className = 'column-header';
            keyHeader.textContent = 'Identity Property';
            headerRow.appendChild(keyHeader);

            (view.schema || []).forEach(field => {
                const th = document.createElement('th');
                th.className = 'column-header';
                th.dataset.fieldId = field.id;
                th.textContent = field.name;
                th.style.cursor = 'context-menu';
                th.title = 'Right-click for field options';
                th.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showColumnMenu(e, field);
                };
                headerRow.appendChild(th);
            });

            const tbody = document.getElementById('tableBody');
            rows.forEach(row => {
                const tr = document.createElement('tr');
                const identityCell = document.createElement('td');
                identityCell.textContent = row.keyValue;
                tr.appendChild(identityCell);

                (view.schema || []).forEach(field => {
                    const td = document.createElement('td');
                    td.className = 'cell-editable';
                    const value = row[field.id];
                    td.innerHTML = renderCellValue(value, field, row);
                    td.onclick = () => openObservationModal({ keyValue: row.keyValue, field, items: row.__sourceItems });
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            finalizeViewStage();
            updateSelectionUI(rows);
        }

        function evaluateLinkedLookup(lookupConfig, record, state) {
            const {
                sourceFieldId,
                targetSetId,
                targetFieldId
            } = lookupConfig;

            // Get linked record ID from source field
            const linkedRecordId = record[sourceFieldId];

            if (!linkedRecordId) return '';

            // Handle array of IDs (take first one for lookup)
            const recordId = Array.isArray(linkedRecordId) ? linkedRecordId[0] : linkedRecordId;

            if (!recordId || typeof recordId !== 'string') return '';

            // Get target set
            const targetSet = state.sets.get(targetSetId);
            if (!targetSet) return '';

            // Get linked record
            const linkedRecord = targetSet.records.get(recordId);
            if (!linkedRecord) return '';

            // Get value from target field
            const value = linkedRecord[targetFieldId];

            // Format value based on target field type
            const targetField = targetSet.schema.find(f => f.id === targetFieldId);
            if (!targetField) return String(value || '');

            // Prevent recursion for linked field types
            if (targetField.type === 'LINKED_LOOKUP' || targetField.type === 'LINKED_ROLLUP') {
                return String(value || '');
            }

            // Use existing renderCellValue logic for proper formatting
            // Create a temporary element to extract text content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = renderCellValue(value, targetField, linkedRecord);
            return tempDiv.textContent || tempDiv.innerText || '';
        }

        function renderCellValue(value, field, record) {
            if (value && typeof value === 'object' && value._sup) {
                return renderSuperpositionCell(value.value || []);
            }

            // Get effective type and subtype (handle legacy fields)
            let effectiveType = field.type;
            let effectiveSubtype = field.subtype;

            // Map legacy types to new structure
            if (field.type === 'LONG_TEXT') {
                effectiveType = 'TEXT';
                effectiveSubtype = 'LONG';
            } else if (field.type === 'EMAIL' || field.type === 'URL' || field.type === 'PHONE') {
                effectiveType = 'CONTACT';
                effectiveSubtype = field.type;
            } else if (field.type === 'CURRENCY') {
                effectiveType = 'NUMBER';
                effectiveSubtype = 'CURRENCY';
            }

            // Handle TEXT with subtypes
            if (effectiveType === 'TEXT') {
                const subtype = effectiveSubtype || 'SHORT';
                if (subtype === 'RICH' && value) {
                    // Render rich text with markdown/HTML support
                    return renderRichText(value);
                } else if (subtype === 'LONG') {
                    return value ? `<div class="whitespace-pre-wrap">${value}</div>` : '';
                } else {
                    return value || '';
                }
            }

            // Handle NUMBER with subtypes
            if (effectiveType === 'NUMBER') {
                const subtype = effectiveSubtype || 'NUMBER';
                if (subtype === 'CURRENCY') {
                    return value ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value) : '';
                } else {
                    return value ? Number(value).toLocaleString() : '';
                }
            }

            // Handle CONTACT with subtypes
            if (effectiveType === 'CONTACT') {
                const subtype = effectiveSubtype || 'EMAIL';
                if (subtype === 'EMAIL' && value) {
                    return `<a href="mailto:${value}" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${value}</a>`;
                } else if (subtype === 'URL' && value) {
                    return `<a href="${value}" target="_blank" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${value}</a>`;
                } else if (subtype === 'PHONE' && value) {
                    return `<a href="tel:${value}" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${value}</a>`;
                }
                return value || '';
            }

            switch(effectiveType) {
                case 'DATE':
                    return value ? new Date(value).toLocaleDateString() : '';
                case 'CHECKBOX':
                    return value ? '' : '';
                case 'LINK_RECORD':
                    if (!value) return '';
                    const linkedName = getRecordDisplayName(value) || field.config?.linkedSetId && state.sets.get(field.config.linkedSetId)?.name || 'Linked Record';
                    return `<button class="text-blue-600 hover:underline" onclick="event.stopPropagation(); openLinkedRecord('${value}')">${linkedName}</button>`;
                case 'LOOKUP':
                    if (!value) return '';
                    const lookupName = getRecordDisplayName(value) || 'Record';
                    return `<span class="text-gray-700">${lookupName}</span>`;
                case 'SELECT':
                    if (!value) return '';
                    const color = field.config?.colors?.[value] || 'gray';
                    return `<span class="badge badge-${color}">${value}</span>`;
                case 'FORMULA':
                    if (!field.config?.formula) return '';
                    const set = getCurrentSet();
                    const formulaResult = FormulaEngine.evaluate(field.config.formula, record, set.schema);
                    if (formulaResult === '#ERROR') {
                        return '<span class="text-red-600" title="Formula error">#ERROR</span>';
                    }
                    const formatted = FormulaEngine.formatFormulaValue(
                        formulaResult,
                        field.config.format || 'number',
                        field.config.decimals || 2
                    );
                    return formatted;
                case 'RECORD_ID':
                    const displayName = getRecordDisplayName(record?.id) || 'Record';
                    return `<span class="font-mono text-xs text-gray-700">${displayName}</span>`;
                case 'LINKED_LOOKUP':
                    // Render linked lookup field
                    if (!field._linkedConfig) return '';
                    const lookupValue = evaluateLinkedLookup(field._linkedConfig, record, state);
                    if (!lookupValue) return '';
                    // Display as plain text or link depending on value type
                    return `<span class="text-gray-700">${lookupValue}</span>`;
                case 'LINKED_ROLLUP':
                    // Render linked rollup field
                    if (!field._linkedConfig) return '';
                    if (!window.EOCRollupEngine) return '<span class="text-red-600">Rollup engine not loaded</span>';
                    const rollupValue = window.EOCRollupEngine.evaluate(field._linkedConfig, record, state);
                    const targetSet = state.sets.get(field._linkedConfig.targetSetId);
                    const targetField = targetSet?.schema.find(f => f.id === field._linkedConfig.targetFieldId);
                    const formattedRollup = window.EOCRollupEngine.formatValue(rollupValue, field._linkedConfig.aggregation, targetField);
                    return `<span class="text-gray-700">${formattedRollup}</span>`;
                default:
                    return value || '';
            }
        }

        function renderRichText(text) {
            if (!text) return '';

            // Basic markdown to HTML conversion
            let html = text
                // Headers
                .replace(/^### (.*$)/gim, '<h3 class="text-lg font-semibold mt-2">$1</h3>')
                .replace(/^## (.*$)/gim, '<h2 class="text-xl font-semibold mt-2">$1</h2>')
                .replace(/^# (.*$)/gim, '<h1 class="text-2xl font-bold mt-2">$1</h1>')
                // Bold
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.*?)__/g, '<strong>$1</strong>')
                // Italic
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/_(.*?)_/g, '<em>$1</em>')
                // Links
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-600 hover:underline" target="_blank" onclick="event.stopPropagation()">$1</a>')
                // Line breaks
                .replace(/\n/g, '<br>');

            return `<div class="rich-text">${html}</div>`;
        }

        function openColumnRulesModal() {
            const modal = document.getElementById('columnRulesModal');
            const view = getCurrentView();
            if (!modal || !view) return;

            const fields = view.type === 'KEY_DERIVED' ? (view.schema || []) : getCurrentSet()?.schema || [];
            const fieldSelect = document.getElementById('columnRulesFieldSelect');
            fieldSelect.innerHTML = '';
            fields.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.id;
                opt.textContent = f.name;
                fieldSelect.appendChild(opt);
            });

            const ruleSelect = document.getElementById('columnRulesRuleSelect');
            const setPicker = document.getElementById('columnRulesSetPicker');
            const preferredSet = document.getElementById('columnRulesPreferredSet');
            preferredSet.innerHTML = '';
            getSetsForWorld().forEach(set => {
                const opt = document.createElement('option');
                opt.value = set.id;
                opt.textContent = set.name;
                preferredSet.appendChild(opt);
            });

            const currentRule = view.columnRules?.[fieldSelect.value] || { rule: 'sup_all' };
            ruleSelect.value = currentRule.rule || 'sup_all';
            preferredSet.value = currentRule.setId || '';
            setPicker.classList.toggle('hidden', ruleSelect.value !== 'prefer_set');

            const recordIdCheckbox = document.getElementById('recordIdVisibilityToggle');
            const recordIdToggle = document.getElementById('recordIdToggle');
            if (recordIdCheckbox) {
                recordIdCheckbox.checked = !!view.showRecordId;
                if (recordIdToggle) recordIdToggle.classList.toggle('active', !!view.showRecordId);
            }

            const rowNumbersCheckbox = document.getElementById('rowNumbersVisibilityToggle');
            const rowNumbersToggle = document.getElementById('rowNumbersToggle');
            if (rowNumbersCheckbox) {
                rowNumbersCheckbox.checked = !!view.showRowNumbers;
                if (rowNumbersToggle) rowNumbersToggle.classList.toggle('active', !!view.showRowNumbers);
            }

            updateColumnRulesSummary();
            openModal('columnRulesModal');
        }

        function updateColumnRulesSummary() {
            const view = getCurrentView();
            if (!view) return;
            const summary = document.getElementById('columnRulesSummary');
            const fieldSelect = document.getElementById('columnRulesFieldSelect');
            const ruleSelect = document.getElementById('columnRulesRuleSelect');
            const preferredSet = document.getElementById('columnRulesPreferredSet');
            const field = (view.schema || getCurrentSet()?.schema || []).find(f => f.id === fieldSelect.value);
            const ruleText = ruleSelect.options[ruleSelect.selectedIndex]?.textContent;
            const setName = preferredSet.value ? state.sets.get(preferredSet.value)?.name : null;
            summary.textContent = `${field?.name || 'Field'}  ${ruleText}${setName ? ` (${setName})` : ''}`;
        }

        function toggleRecordIdVisibility(isVisible) {
            const view = getCurrentView();
            if (!view) return;

            view.showRecordId = isVisible;
            if (isVisible) {
                view.hiddenFields = (view.hiddenFields || []).filter(id => id !== '__recordId');
            } else {
                view.hiddenFields = view.hiddenFields || [];
                if (!view.hiddenFields.includes('__recordId')) view.hiddenFields.push('__recordId');
            }
            ensureViewColumnOrder(view, getCurrentSet()?.schema || [], isVisible);
            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { showRecordId: isVisible }, summary: isVisible ? 'Enabled Record ID column' : 'Hid Record ID column' },
                { scale: 'collection' }
            );

            renderCurrentView();
        }

        function toggleRowNumbers(isVisible) {
            const view = getCurrentView();
            if (!view) return;

            view.showRowNumbers = isVisible;
            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { showRowNumbers: isVisible }, summary: isVisible ? 'Enabled row numbers' : 'Hid row numbers' },
                { scale: 'collection' }
            );

            renderCurrentView();
            showToast(isVisible ? ' Row numbers enabled' : ' Row numbers hidden');
        }

        function saveColumnRule() {
            const view = getCurrentView();
            if (!view) return;
            const fieldId = document.getElementById('columnRulesFieldSelect').value;
            const rule = document.getElementById('columnRulesRuleSelect').value;
            const setId = document.getElementById('columnRulesPreferredSet').value || null;

            view.columnRules = view.columnRules || {};
            view.columnRules[fieldId] = { rule, ...(rule === 'prefer_set' ? { setId } : {}) };

            createEvent(
                'View Schema Update',
                'SEG',
                { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                { viewId: view.id, changes: { columnRules: view.columnRules }, summary: 'Updated column rules' },
                { scale: 'collection' }
            );

            closeModal('columnRulesModal');
            renderCurrentView();
        }

        function deleteColumnRule() {
            const view = getCurrentView();
            if (!view) return;
            const fieldId = document.getElementById('columnRulesFieldSelect').value;
            if (view.columnRules?.[fieldId]) {
                delete view.columnRules[fieldId];
                createEvent(
                    'View Schema Update',
                    'SEG',
                    { type: 'View', id: view.id, setId: view.key?.setId || state.currentSetId },
                    { viewId: view.id, changes: { columnRules: view.columnRules }, summary: 'Cleared column rule' },
                    { scale: 'collection' }
                );
            }
            closeModal('columnRulesModal');
            renderCurrentView();
        }

        // FIELD MANAGER
        let fieldManagerDragState = {
            draggingFieldId: null,
            dropTargetFieldId: null,
            dropPosition: null
        };

        function openFieldManager() {
            const set = getCurrentSet();
            if (!set) {
                showToast(' No set selected');
                return;
            }

            // Render the field list
            renderFieldManagerList();

            // Setup event listeners
            setupFieldManagerEvents();

            // Open the modal
            openModal('fieldManagerModal');
        }

        function renderFieldManagerList() {
            const set = getCurrentSet();
            if (!set) return;

            const view = getCurrentView();
            const hiddenFields = view?.hiddenFields || [];

            const listContainer = document.getElementById('fieldManagerList');
            listContainer.innerHTML = '';

            // Split fields into visible and hidden
            const visibleFields = set.schema.filter(field => !hiddenFields.includes(field.id));
            const hiddenFieldsList = set.schema.filter(field => hiddenFields.includes(field.id));

            // Render visible fields
            if (visibleFields.length > 0) {
                const visibleHeader = document.createElement('div');
                visibleHeader.className = 'text-sm font-semibold text-gray-700 mb-2 mt-2';
                visibleHeader.textContent = 'Visible Fields';
                listContainer.appendChild(visibleHeader);

                visibleFields.forEach((field, index) => {
                    const fieldItem = createFieldManagerItem(field, index, false);
                    listContainer.appendChild(fieldItem);
                });
            }

            // Render hidden fields
            if (hiddenFieldsList.length > 0) {
                const hiddenHeader = document.createElement('div');
                hiddenHeader.className = 'text-sm font-semibold text-gray-500 mb-2 mt-4';
                hiddenHeader.textContent = 'Hidden Fields';
                listContainer.appendChild(hiddenHeader);

                hiddenFieldsList.forEach((field, index) => {
                    const fieldItem = createFieldManagerItem(field, index, true);
                    listContainer.appendChild(fieldItem);
                });
            }
        }

        function createFieldManagerItem(field, index, isHidden) {
            const fieldType = FIELD_TYPES[field.type] || { name: field.type, icon: 'ph-question' };

            // Get subtype info if available
            let displayName = fieldType.name;
            let displayIcon = fieldType.icon;

            if (field.subtype && fieldType.subtypes && fieldType.subtypes[field.subtype]) {
                const subtype = fieldType.subtypes[field.subtype];
                displayName = subtype.name;
                displayIcon = subtype.icon;
            }

            const div = document.createElement('div');
            div.className = 'field-manager-item';
            if (isHidden) {
                div.style.opacity = '0.6';
            }
            div.dataset.fieldId = field.id;
            div.draggable = true;

            const visibilityIcon = isHidden ? 'ph-eye-slash' : 'ph-eye';
            const visibilityTitle = isHidden ? 'Show field' : 'Hide field';
            const visibilityAction = isHidden ? `showField('${field.id}')` : `hideField('${field.id}')`;

            div.innerHTML = `
                <button class="field-manager-action-btn" title="${visibilityTitle}" onclick="${visibilityAction}">
                    <i class="ph ${visibilityIcon}"></i>
                </button>
                <i class="ph ph-dots-six-vertical field-drag-handle"></i>
                <div class="field-manager-icon">
                    <i class="ph ${displayIcon}"></i>
                </div>
                <div class="field-manager-info">
                    <div class="field-manager-name" data-field-id="${field.id}">
                        <span class="field-name-display">${field.name}</span>
                    </div>
                    <div class="field-manager-type-label">${displayName}</div>
                </div>
                <div class="field-manager-actions">
                    <button class="field-manager-action-btn" title="Rename field" onclick="enableFieldRename('${field.id}')">
                        <i class="ph ph-pencil-simple"></i>
                    </button>
                    <button class="field-manager-action-btn" title="Change field type" onclick="openFieldTypeChanger('${field.id}')">
                        <i class="ph ph-swap"></i>
                    </button>
                    <button class="field-manager-action-btn danger" title="Delete field" onclick="confirmDeleteFieldFromManager('${field.id}')">
                        <i class="ph ph-trash"></i>
                    </button>
                </div>
            `;

            // Setup drag and drop
            setupFieldDragAndDrop(div, field.id);

            return div;
        }

        function setupFieldDragAndDrop(element, fieldId) {
            element.addEventListener('dragstart', (e) => {
                fieldManagerDragState.draggingFieldId = fieldId;
                element.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', fieldId);
            });

            element.addEventListener('dragend', (e) => {
                element.classList.remove('dragging');
                clearFieldDragIndicators();
                fieldManagerDragState.draggingFieldId = null;
                fieldManagerDragState.dropTargetFieldId = null;
                fieldManagerDragState.dropPosition = null;
            });

            element.addEventListener('dragover', (e) => {
                if (!fieldManagerDragState.draggingFieldId || fieldManagerDragState.draggingFieldId === fieldId) {
                    return;
                }
                e.preventDefault();

                const rect = element.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                const position = e.clientY < midpoint ? 'before' : 'after';

                clearFieldDragIndicators();
                element.classList.add('drag-over');
                fieldManagerDragState.dropTargetFieldId = fieldId;
                fieldManagerDragState.dropPosition = position;
            });

            element.addEventListener('drop', (e) => {
                e.preventDefault();
                if (!fieldManagerDragState.draggingFieldId || !fieldManagerDragState.dropTargetFieldId) {
                    return;
                }

                reorderFieldInSchema(
                    fieldManagerDragState.draggingFieldId,
                    fieldManagerDragState.dropTargetFieldId,
                    fieldManagerDragState.dropPosition
                );

                clearFieldDragIndicators();
                renderFieldManagerList();
            });
        }

        function clearFieldDragIndicators() {
            document.querySelectorAll('.field-manager-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function reorderFieldInSchema(draggedFieldId, targetFieldId, position) {
            const set = getCurrentSet();
            if (!set) return;

            const schema = set.schema;
            const fromIndex = schema.findIndex(f => f.id === draggedFieldId);
            let toIndex = schema.findIndex(f => f.id === targetFieldId);

            if (fromIndex === -1 || toIndex === -1) return;

            // Remove from old position
            const [movedField] = schema.splice(fromIndex, 1);

            // Adjust toIndex if we removed an item before it
            if (fromIndex < toIndex) {
                toIndex -= 1;
            }

            // Insert at new position
            const insertIndex = position === 'after' ? toIndex + 1 : toIndex;
            schema.splice(insertIndex, 0, movedField);

            // Update view column order if exists
            const view = getCurrentView();
            if (view) {
                ensureViewColumnOrder(view, schema, view.showRecordId);
            }

            createEvent(
                'Reorder Fields',
                'SEG',
                { type: 'Set', id: set.id },
                { setId: set.id, fieldId: draggedFieldId, summary: `Reordered field ${movedField.name}` },
                { frame: 'schema', scale: 'collection' }
            );

            renderCurrentView();
            showToast(' Field reordered');
        }

        function enableFieldRename(fieldId) {
            const set = getCurrentSet();
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const nameDisplay = document.querySelector(`.field-manager-name[data-field-id="${fieldId}"] .field-name-display`);
            if (!nameDisplay) return;

            const currentName = field.name;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'w-full';

            const parent = nameDisplay.parentElement;
            parent.replaceChild(input, nameDisplay);
            input.focus();
            input.select();

            const saveRename = () => {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    field.name = newName;
                    createEvent(
                        'Rename Field',
                        'SEG',
                        { type: 'Field', id: fieldId, setId: set.id },
                        { setId: set.id, fieldId, oldName: currentName, newName, summary: `Renamed field from "${currentName}" to "${newName}"` },
                        { frame: 'schema', scale: 'collection' }
                    );
                    renderCurrentView();
                    showToast(` Field renamed to "${newName}"`);
                }
                renderFieldManagerList();
            };

            input.addEventListener('blur', saveRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    renderFieldManagerList();
                }
            });
        }

        function openFieldTypeChanger(fieldId) {
            const set = getCurrentSet();
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            // Close field manager and open the existing change field type modal
            closeModal('fieldManagerModal');
            openChangeFieldTypeModal(field);
        }

        function confirmDeleteFieldFromManager(fieldId) {
            const set = getCurrentSet();
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            showConfirm(
                `Are you sure you want to delete the field "${field.name}"? This will remove all data in this field from all records.`,
                () => {
                    deleteField(fieldId);
                    renderFieldManagerList();
                },
                () => {}
            );
        }

        function setupFieldManagerEvents() {
            // Close button
            const closeBtn = document.getElementById('closeFieldManagerBtn');
            const closeFooterBtn = document.getElementById('closeFieldManagerFooterBtn');

            if (closeBtn) {
                closeBtn.onclick = () => closeModal('fieldManagerModal');
            }
            if (closeFooterBtn) {
                closeFooterBtn.onclick = () => closeModal('fieldManagerModal');
            }

            // Add field trigger button
            const addFieldTrigger = document.getElementById('addFieldTriggerBtn');
            if (addFieldTrigger) {
                addFieldTrigger.onclick = showFieldManagerAddForm;
            }

            // Cancel add field button
            const cancelNewField = document.getElementById('cancelNewFieldBtn');
            if (cancelNewField) {
                cancelNewField.onclick = hideFieldManagerAddForm;
            }

            // Save new field button
            const saveNewField = document.getElementById('saveNewFieldBtn');
            if (saveNewField) {
                saveNewField.onclick = saveFieldFromManager;
            }

            // Set up field type trigger
            const fieldManagerTypeTrigger = document.getElementById('fieldManagerTypeTrigger');
            if (fieldManagerTypeTrigger) {
                fieldManagerTypeTrigger.onclick = (event) => {
                    event.preventDefault();
                    toggleFieldManagerTypeDropdown();
                };
            }
        }

        function showFieldManagerAddForm() {
            const form = document.getElementById('addFieldForm');
            const trigger = document.getElementById('addFieldTriggerBtn');

            if (form && trigger) {
                form.classList.remove('hidden');
                trigger.classList.add('hidden');

                // Initialize select options state
                state.fieldManagerSelectOptions = [{ value: 'Option 1', color: 'blue' }];

                // Clear form
                const nameInput = document.getElementById('fieldManagerNewName');
                if (nameInput) nameInput.value = '';

                // Set default field type to TEXT
                document.getElementById('fieldManagerNewType').value = 'TEXT';
                renderFieldManagerTypeGrid('TEXT');
                closeFieldManagerTypeDropdown();
                updateFieldManagerConfig('TEXT');

                // Populate link to set dropdown
                const linkSelect = document.getElementById('fieldManagerLinkToSet');
                if (linkSelect) {
                    linkSelect.innerHTML = '';
                    getSetsForWorld(state.currentWorldId).forEach(set => {
                        const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
                        linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
                    });
                    if (linkSelect.options.length === 0) {
                        linkSelect.innerHTML = '<option value="">No sets available</option>';
                        linkSelect.disabled = true;
                    } else {
                        linkSelect.disabled = false;
                        const defaultValue = state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value;
                        linkSelect.value = defaultValue;
                    }
                }

                // Focus name input
                if (nameInput) nameInput.focus();
            }
        }

        function hideFieldManagerAddForm() {
            const form = document.getElementById('addFieldForm');
            const trigger = document.getElementById('addFieldTriggerBtn');

            if (form && trigger) {
                form.classList.add('hidden');
                trigger.classList.remove('hidden');
            }
        }

        function updateFieldManagerConfig(typeId) {
            document.getElementById('fieldManagerSelectConfig').classList.remove('visible');
            document.getElementById('fieldManagerLinkToRecordConfig').classList.remove('visible');
            document.getElementById('fieldManagerFormulaConfig').classList.remove('visible');

            if (typeId === 'SELECT') {
                document.getElementById('fieldManagerSelectConfig').classList.add('visible');
                renderFieldManagerSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('fieldManagerLinkToRecordConfig').classList.add('visible');
            } else if (typeId === 'FORMULA') {
                document.getElementById('fieldManagerFormulaConfig').classList.add('visible');
                initFieldManagerFormulaAutocomplete();
            }
        }

        function renderFieldManagerTypeGrid(selectedType) {
            const trigger = document.getElementById('fieldManagerTypeTrigger');
            const dropdown = document.getElementById('fieldManagerTypeDropdown');
            const selectedName = document.getElementById('fieldManagerSelectedTypeName');
            const selectedDescription = document.getElementById('fieldManagerSelectedTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectFieldManagerType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function selectFieldManagerType(typeId) {
            document.getElementById('fieldManagerNewType').value = typeId;
            renderFieldManagerTypeGrid(typeId);
            updateFieldManagerConfig(typeId);
            closeFieldManagerTypeDropdown();
        }

        function toggleFieldManagerTypeDropdown() {
            if (state.fieldManagerTypeDropdownOpen) {
                closeFieldManagerTypeDropdown();
            } else {
                openFieldManagerTypeDropdown();
            }
        }

        function openFieldManagerTypeDropdown() {
            const dropdown = document.getElementById('fieldManagerTypeDropdown');
            const trigger = document.getElementById('fieldManagerTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.fieldManagerTypeDropdownOpen = true;
        }

        function closeFieldManagerTypeDropdown() {
            const dropdown = document.getElementById('fieldManagerTypeDropdown');
            const trigger = document.getElementById('fieldManagerTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.fieldManagerTypeDropdownOpen = false;
        }

        function renderFieldManagerSelectOptions() {
            const list = document.getElementById('fieldManagerSelectOptionsList');
            if (!list) return;

            list.innerHTML = '';
            if (!state.fieldManagerSelectOptions) {
                state.fieldManagerSelectOptions = [{ value: 'Option 1', color: 'blue' }];
            }

            state.fieldManagerSelectOptions.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'flex items-center gap-2';
                optionDiv.innerHTML = `
                    <input type="text" value="${option.value}" onchange="state.fieldManagerSelectOptions[${index}].value = this.value" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg">
                    <select onchange="state.fieldManagerSelectOptions[${index}].color = this.value" class="px-2 py-2 border border-gray-300 rounded-lg">
                        <option value="blue" ${option.color === 'blue' ? 'selected' : ''}> Blue</option>
                        <option value="green" ${option.color === 'green' ? 'selected' : ''}> Green</option>
                        <option value="red" ${option.color === 'red' ? 'selected' : ''}> Red</option>
                        <option value="yellow" ${option.color === 'yellow' ? 'selected' : ''}> Yellow</option>
                        <option value="purple" ${option.color === 'purple' ? 'selected' : ''}> Purple</option>
                        <option value="gray" ${option.color === 'gray' ? 'selected' : ''}> Gray</option>
                    </select>
                    <button onclick="removeFieldManagerSelectOption(${index})" class="text-red-500 hover:text-red-700 p-2" ${state.fieldManagerSelectOptions.length === 1 ? 'disabled' : ''}>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                `;
                list.appendChild(optionDiv);
            });
        }

        function addFieldManagerSelectOption() {
            if (!state.fieldManagerSelectOptions) {
                state.fieldManagerSelectOptions = [];
            }
            state.fieldManagerSelectOptions.push({ value: `Option ${state.fieldManagerSelectOptions.length + 1}`, color: 'blue' });
            renderFieldManagerSelectOptions();
        }

        function removeFieldManagerSelectOption(index) {
            if (state.fieldManagerSelectOptions && state.fieldManagerSelectOptions.length > 1) {
                state.fieldManagerSelectOptions.splice(index, 1);
                renderFieldManagerSelectOptions();
            }
        }

        function initFieldManagerFormulaAutocomplete() {
            const formulaInput = document.getElementById('fieldManagerFormulaInput');
            if (!formulaInput) return;

            // For now, just add a placeholder. Full autocomplete implementation would be more complex
            // and should match the main formula autocomplete functionality
            formulaInput.placeholder = 'e.g., {Price} * {Quantity}';
        }

        function saveFieldFromManager() {
            const set = getCurrentSet();
            if (!set) return;

            const name = document.getElementById('fieldManagerNewName').value.trim();
            if (!name) {
                showToast(' Field name is required');
                return;
            }

            const fieldId = name.toLowerCase().replace(/[^a-z0-9]/g, '_');

            // Check for duplicates
            if (set.schema.find(f => f.id === fieldId)) {
                showToast(' A field with this name already exists');
                return;
            }

            const type = document.getElementById('fieldManagerNewType').value;
            const subtype = document.getElementById('fieldManagerNewSubtype')?.value || null;

            const newField = {
                id: fieldId,
                name: name,
                type: type,
                subtype: subtype,
                width: '150',
                config: null
            };

            // Get type-specific config
            if (type === 'SELECT') {
                if (!state.fieldManagerSelectOptions || state.fieldManagerSelectOptions.length === 0) {
                    showToast(' Please add at least one option');
                    return;
                }
                const acceptNewOptions = document.getElementById('fieldManagerAcceptNewOptions')?.checked ?? true;
                const options = state.fieldManagerSelectOptions.map(opt => opt.value);
                const colors = Object.fromEntries(state.fieldManagerSelectOptions.map(opt => [opt.value, opt.color]));
                newField.config = { options, colors, acceptNewOptions };
            } else if (type === 'LINK_RECORD') {
                const linkedSetId = document.getElementById('fieldManagerLinkToSet')?.value;
                if (!linkedSetId) {
                    showToast(' Please select a set to link to');
                    return;
                }
                newField.config = { linkedSetId };
            } else if (type === 'FORMULA') {
                const formula = document.getElementById('fieldManagerFormulaInput')?.value.trim();
                if (!formula) {
                    showToast(' Please enter a formula');
                    return;
                }
                newField.config = {
                    formula: formula,
                    format: document.getElementById('fieldManagerFormulaFormat')?.value || 'text',
                    decimals: parseInt(document.getElementById('fieldManagerFormulaDecimals')?.value || '2')
                };
            }

            // Add field to schema
            set.schema.push(newField);

            // Initialize field values in all records
            const defaultValue = FIELD_TYPES[type]?.defaultValue ?? '';
            set.records.forEach(record => {
                record[fieldId] = defaultValue;
            });

            // Create event
            createEvent(
                'Add Field',
                'ADD',
                { type: 'Field', id: fieldId, setId: set.id },
                { setId: set.id, fieldId, fieldName: name, fieldType: type, summary: `Added field ${name} (${FIELD_TYPES[type]?.name})` },
                { frame: 'schema', scale: 'collection' }
            );

            // Re-render
            renderCurrentView();
            showToast(` Field "${name}" added`);

            // Update field manager
            hideFieldManagerAddForm();
            renderFieldManagerList();
        }

        function renderSuperpositionCell(entries) {
            if (!Array.isArray(entries) || entries.length === 0) return '';

            const maxVisible = 3; // Show max 3 values in cell
            const visibleEntries = entries.slice(0, maxVisible);
            const hiddenCount = Math.max(0, entries.length - maxVisible);

            // Create badge for each visible entry
            const badges = visibleEntries
                .map(e => e?.val ?? '')
                .filter(Boolean)
                .map(val => `<span class="sup-value-badge">${val}</span>`)
                .join('');

            // Add "+N more" badge if there are hidden values
            const moreBadge = hiddenCount > 0
                ? `<span class="sup-count-badge">+${hiddenCount} more</span>`
                : '';

            // Tooltip showing all values
            const tooltip = entries
                .map(e => `${e?.val ?? ''}  ${e?.context?.source || 'observation'}`)
                .join('\n');

            return `<div class="sup-chip-container" title="${tooltip}">${badges}${moreBadge}</div>`;
        }

        // LEAN CONTEXT COMPARISON (Phase 2)
        function showQuickDiff(recordId, fieldId, event) {
            event?.stopPropagation();

            const set = getCurrentSet();
            if (!set || !state.leanContext) return;

            const record = set.records.get(recordId);
            const value = record?.[fieldId];

            if (!value?._sup || !value.value || value.value.length < 2) return;

            // Get contexts for comparison
            const contexts = value.value.slice(0, 2).map(() => state.leanContext.getFieldContext(record, fieldId));
            const diff = state.leanContext.explainContextDifference(contexts[0], contexts[1]);

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-20 flex items-center justify-center z-50';
            modal.onclick = (e) => e.target === modal && modal.remove();

            modal.innerHTML = `
                <div class="bg-white rounded-lg shadow-xl max-w-md p-4" onclick="event.stopPropagation()">
                    <div class="flex justify-between items-start mb-3">
                        <h4 class="font-semibold">Why Different?</h4>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600"></button>
                    </div>
                    ${diff.diffs.length === 0 ? '<p class="text-gray-600">No significant differences found.</p>' : ''}
                    ${diff.diffs.map(d => `
                        <div class="text-sm mb-2">
                            <span class="font-medium">${d.label}:</span>
                            <div class="ml-4">
                                <div class="text-red-600">${d.a || '(not set)'}</div>
                                <div class="text-green-600">${d.b || '(not set)'}</div>
                            </div>
                        </div>
                    `).join('')}
                    <div class="mt-3 text-xs text-gray-600 border-t pt-2">
                        ${diff.compatible ? ' Can compare with caution' : ' Should not compare'}
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function getStabilityColor(tag) {
            const colors = {
                'emerging': 'yellow',
                'forming': 'gray',
                'stable': 'green'
            };
            return colors[tag] || 'gray';
        }

        // CARD VIEW
        function renderCardView() {
            const set = getCurrentSet();
            if (!set) return;

            const view = getCurrentView();
            let records = Array.from(set.records.values());
            if (view && view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const stabilityToggle = state.leanContext ? `
                <label class="flex items-center gap-2 text-sm text-gray-700 bg-gray-50 border border-gray-200 px-3 py-2 rounded-lg">
                    <input type="checkbox" id="showStabilityToggle" ${view?.showStability ? 'checked' : ''}
                           onchange="toggleStabilityDisplay()">
                    <span>Show stability</span>
                </label>
            ` : '';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Card view  ${records.length} ${records.length === 1 ? 'record' : 'records'}</div>
                        </div>
                    </div>
                    ${renderViewActions(stabilityToggle)}
                </div>
                <div class="view-stage-body">
                    <div class="cards-grid" id="cardsGrid"></div>
                </div>`;

            const grid = document.getElementById('cardsGrid');
            records.forEach(record => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => openExpandedRecord(record.id);

                // Use the identifier field set for this view, or infer one
                const identifierFieldId = view.identifierField || inferIdentifierFieldId(set);
                const identifierField = set.schema.find(f => f.id === identifierFieldId) || set.schema[0];

                // Get display fields (all fields except the identifier and recordId)
                const displayFields = set.schema.filter(f => f.id !== identifierField.id && f.id !== '__recordId').slice(0, 5);

                // Create card header
                const header = document.createElement('div');
                header.className = 'flex items-start justify-between mb-2';

                const titleDiv = document.createElement('div');
                titleDiv.className = 'card-title';
                titleDiv.textContent = record[identifierField.id] || 'Untitled';
                header.appendChild(titleDiv);

                if (view?.showStability && state.leanContext) {
                    const badge = document.createElement('span');
                    badge.className = `badge badge-${getStabilityColor(state.leanContext.getRecordStability(record.id))} text-xs`;
                    badge.textContent = state.leanContext.getRecordStability(record.id);
                    header.appendChild(badge);
                }

                card.appendChild(header);

                // Create field elements with context menus
                displayFields.forEach(field => {
                    const value = record[field.id];
                    if (!value && value !== 0 && value !== false) return;

                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'card-field';

                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'card-field-label';
                    labelDiv.textContent = field.name;
                    labelDiv.style.cursor = 'context-menu';
                    labelDiv.title = 'Right-click for field options';
                    labelDiv.oncontextmenu = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showColumnMenu(e, field);
                    };

                    const valueDiv = document.createElement('div');
                    valueDiv.className = 'card-field-value';
                    valueDiv.innerHTML = renderCellValue(value, field, record);

                    fieldDiv.appendChild(labelDiv);
                    fieldDiv.appendChild(valueDiv);
                    card.appendChild(fieldDiv);
                });

                grid.appendChild(card);
            });

            finalizeViewStage();
        }

        function toggleStabilityDisplay() {
            const view = getCurrentView();
            if (!view) return;
            view.showStability = document.getElementById('showStabilityToggle')?.checked || false;
            renderCurrentView();
        }

        // KANBAN VIEW
        function renderKanbanView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const pickGroupingAction = `<button onclick="openKanbanConfig()" class="btn btn-secondary btn-sm">Pick grouping</button>`;
            const changeGroupingAction = `<button onclick="openKanbanConfig()" class="btn btn-secondary btn-sm">Change grouping</button>`;

            if (!view.kanbanGroupField) {
                const container = document.getElementById('viewContainer');
                container.innerHTML = `
                    <div class="view-stage-header">
                        <div class="view-stage-title">
                            <span class="view-stage-pill">${set.name}</span>
                            <div class="min-w-0">
                                <div class="view-stage-name">${view.name}</div>
                                <div class="view-stage-sub">Kanban view  Choose a grouping</div>
                            </div>
                        </div>
                        ${renderViewActions(pickGroupingAction)}
                    </div>
                    <div class="view-stage-body">
                        <div class="kanban-empty-state">
                            <div class="text-4xl mb-4"></div>
                            <p class="text-lg font-semibold mb-2">Configure Kanban Board</p>
                            <p class="mb-4">Select a single-select field to group your records</p>
                            <button onclick="openKanbanConfig()" class="btn btn-primary">Configure Kanban</button>
                        </div>
                    </div>
                `;
                finalizeViewStage();
                return;
            }
            
            const groupField = set.schema.find(f => f.id === view.kanbanGroupField);
            if (!groupField || groupField.type !== 'SELECT') {
                showToast(' Invalid kanban configuration');
                return;
            }
            
            let records = Array.from(set.records.values());
            if (view.filters.length > 0) records = applyFilterGroups(records, view.filters, set.schema);
            if (view?.sorts?.length) records = applySorts(records, view.sorts, set.schema);

            const recordCount = records.length;
            const recordLabel = recordCount === 1 ? 'record' : 'records';

            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${set.name}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view.name}</div>
                            <div class="view-stage-sub">Kanban view  ${groupField.name}  ${recordCount} ${recordLabel}</div>
                        </div>
                    </div>
                    ${renderViewActions(changeGroupingAction)}
                </div>
                <div class="view-stage-body">
                    <div class="kanban-board" id="kanbanBoard"></div>
                </div>
            `;

            const board = document.getElementById('kanbanBoard');
            const options = groupField.config.options || [];
            
            options.forEach(option => {
                const columnRecords = records.filter(r => r[groupField.id] === option);
                const column = createKanbanColumn(option, columnRecords, groupField);
                board.appendChild(column);
            });
            
            // Uncategorized column
            const uncategorized = records.filter(r => !r[groupField.id]);
            if (uncategorized.length > 0) {
                const column = createKanbanColumn('Uncategorized', uncategorized, groupField);
                board.appendChild(column);
            }

            finalizeViewStage();
        }

        function createKanbanColumn(title, records, groupField) {
            const column = document.createElement('div');
            column.className = 'kanban-column';
            column.dataset.value = title;
            
            const color = groupField.config?.colors?.[title] || 'gray';
            
            column.innerHTML = `
                <div class="kanban-column-header">
                    <div class="kanban-column-title">
                        <span class="badge badge-${color}">${title}</span>
                    </div>
                    <span class="kanban-column-count">${records.length}</span>
                </div>
                <div class="kanban-cards" data-column="${title}"></div>
            `;
            
            const cardsContainer = column.querySelector('.kanban-cards');
            
            // Enable drop
            cardsContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                column.classList.add('drag-over');
            });
            
            cardsContainer.addEventListener('dragleave', () => {
                column.classList.remove('drag-over');
            });
            
            cardsContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                column.classList.remove('drag-over');
                
                if (state.draggedRecord) {
                    const newValue = title === 'Uncategorized' ? '' : title;
                    updateRecord(state.draggedRecord.id, groupField.id, newValue, state.draggedRecord[groupField.id]);
                    state.draggedRecord = null;
                    renderKanbanView();
                }
            });
            
            records.forEach(record => {
                const card = createKanbanCard(record);
                cardsContainer.appendChild(card);
            });
            
            return column;
        }

        function createKanbanCard(record) {
            const set = getCurrentSet();
            const view = getCurrentView();
            const card = document.createElement('div');
            card.className = 'kanban-card';
            card.draggable = true;
            card.dataset.recordId = record.id;

            // Use the identifier field set for this view, or infer one
            const identifierFieldId = view.identifierField || inferIdentifierFieldId(set);
            const identifierField = set.schema.find(f => f.id === identifierFieldId) || set.schema[0];

            // Get display fields (all fields except the identifier and recordId)
            const displayFields = set.schema.filter(f => f.id !== identifierField.id && f.id !== '__recordId').slice(0, 3);

            // Create card title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'font-semibold mb-2';
            titleDiv.textContent = record[identifierField.id] || 'Untitled';
            card.appendChild(titleDiv);

            // Create field elements with context menus
            displayFields.forEach(field => {
                const value = record[field.id];
                if (!value && value !== 0 && value !== false) return;

                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'text-sm text-gray-600 mb-1';

                const labelSpan = document.createElement('span');
                labelSpan.textContent = field.name + ': ';
                labelSpan.style.fontWeight = '500';
                labelSpan.style.cursor = 'context-menu';
                labelSpan.title = 'Right-click for field options';
                labelSpan.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showColumnMenu(e, field);
                };

                const valueSpan = document.createElement('span');
                valueSpan.innerHTML = renderCellValue(value, field, record);

                fieldDiv.appendChild(labelSpan);
                fieldDiv.appendChild(valueSpan);
                card.appendChild(fieldDiv);
            });

            card.addEventListener('dragstart', (e) => {
                state.draggedRecord = record;
                card.classList.add('dragging');
            });

            card.addEventListener('dragend', () => {
                card.classList.remove('dragging');
            });
            
            card.onclick = (e) => {
                if (!card.classList.contains('dragging')) {
                    openExpandedRecord(record.id);
                }
            };
            
            return card;
        }

        function openKanbanConfig() {
            const set = getCurrentSet();
            const select = document.getElementById('kanbanGroupField');
            select.innerHTML = '<option value="">Select a field...</option>';
            
            set.schema.forEach(field => {
                if (field.type === 'SELECT') {
                    select.innerHTML += `<option value="${field.id}">${field.name}</option>`;
                }
            });
            
            const view = getCurrentView();
            if (view.kanbanGroupField) {
                select.value = view.kanbanGroupField;
            }
            
            openModal('kanbanConfigModal');
        }

        function saveKanbanConfig() {
            const fieldId = document.getElementById('kanbanGroupField').value;
            if (!fieldId) {
                showConfirm('Please select a field to group by', () => {});
                return;
            }

            const view = getCurrentView();
            view.kanbanGroupField = fieldId;

            closeModal('kanbanConfigModal');
            renderKanbanView();
            showToast(' Kanban configured');
        }

        // ENTITIES
        // Helper functions to get child objects for each entity type
        function getChildrenForRecord(recordId) {
            const record = getRecordById(recordId);
            if (!record) return null;

            const set = record.set;
            const fields = set?.schema || [];
            const outgoingConnections = getConnectionView(c => c.subject?.id === recordId);
            const incomingConnections = getConnectionView(c => c.operand?.id === recordId);
            const definitions = getDefinitionView(d => d.entity?.type === 'Record' && d.entity?.id === recordId);
            const derivedViews = getEntityView(e => e.type === 'ViewEntity' && e.memberRefs?.some(ref => ref.id === recordId));

            return { fields, outgoingConnections, incomingConnections, definitions, derivedViews, record, set };
        }

        function getChildrenForSet(setId) {
            const set = state.sets.get(setId);
            if (!set) return null;

            const records = Array.from(set.records.values()).map(r => ({ ...r, setId, setName: set.name }));
            const fields = set.schema || [];
            const views = Array.from(set.views.values());
            const definitions = getDefinitionView(d => d.entity?.type === 'Set' && d.entity?.id === setId);
            const connections = getConnectionView(c =>
                (c.subject?.type === 'Set' && c.subject?.id === setId) ||
                (c.operand?.type === 'Set' && c.operand?.id === setId)
            );
            const viewEntities = getEntityView(e => e.type === 'ViewEntity' && e.viewRef?.setId === setId);

            return { records, fields, views, definitions, connections, viewEntities, set };
        }

        function getChildrenForField(fieldId, setId) {
            const set = state.sets.get(setId);
            if (!set) return null;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return null;

            const records = Array.from(set.records.values()).map(r => ({ id: r.id, value: r[fieldId] }));
            const definitions = getDefinitionView(d => d.entity?.type === 'Field' && d.entity?.id === fieldId);

            return { field, records, definitions, set };
        }

        function getChildrenForConnection(connectionId) {
            const connection = state.connections.get(connectionId);
            if (!connection) return null;

            const relation = connection.relationId ? state.connectionRelations.get(connection.relationId) : null;
            const subjectEntity = state.entities.get(connection.subject?.id);
            const operandEntity = state.entities.get(connection.operand?.id);
            const definitions = getDefinitionView(d => d.entity?.type === 'Connection' && d.entity?.id === connectionId);

            return { connection, relation, subjectEntity, operandEntity, definitions };
        }

        function getChildrenForViewEntity(viewEntityId) {
            const viewEntity = state.entities.get(viewEntityId);
            if (!viewEntity) return null;

            const viewRef = viewEntity.viewRef;
            const set = viewRef?.setId ? state.sets.get(viewRef.setId) : null;
            const view = set && viewRef?.viewId ? set.views.get(viewRef.viewId) : null;
            const memberRefs = viewEntity.memberRefs || [];
            const lineageConnections = getConnectionView(c => c.operand?.id === viewEntityId);
            const definitions = getDefinitionView(d => d.entity?.type === 'ViewEntity' && d.entity?.id === viewEntityId);

            return { viewEntity, set, view, memberRefs, lineageConnections, definitions };
        }

        function getChildrenForDefinition(definitionId) {
            const definition = state.definitions.get(definitionId);
            if (!definition) return null;

            const targetEntity = definition.entity ? state.entities.get(definition.entity.id) : null;

            return { definition, targetEntity };
        }

        function groupEntitiesByType(entities = []) {
            const groups = new Map();
            entities.forEach(entity => {
                const key = entity.entityType || entity.type || 'Unknown';
                if (!groups.has(key)) groups.set(key, []);
                groups.get(key).push(entity);
            });
            return groups;
        }

        function renderEntityMembership(entity) {
            if (!entity?.memberRefs?.length) return '';
            const preview = entity.memberRefs.slice(0, 3)
                .map(ref => renderEntityLabel(ref))
                .join(', ');
            const remaining = entity.memberRefs.length > 3 ? ` +${entity.memberRefs.length - 3} more` : '';
            return `
                <div class="mt-2 text-xs text-gray-600 bg-gray-50 border border-gray-200 rounded-md px-3 py-2">
                    <div class="font-semibold text-gray-800 flex items-center gap-1">
                        <i class="ph ph-tree-structure"></i>
                        Entity table  ${entity.memberRefs.length} items
                    </div>
                    <div class="mt-1 text-gray-500">${preview}${remaining}</div>
                </div>
            `;
        }

        // Render child tables for expanded entities
        function renderChildTable(title, icon, items, renderItem) {
            if (!items || items.length === 0) return '';
            return `
                <div class="mt-2 bg-white border border-gray-200 rounded-md overflow-hidden">
                    <div class="px-3 py-2 bg-gray-50 border-b border-gray-200 flex items-center gap-2">
                        <i class="ph ${icon} text-gray-600"></i>
                        <span class="text-xs font-semibold text-gray-700">${title} (${items.length})</span>
                    </div>
                    <div class="p-2 space-y-1 max-h-60 overflow-y-auto">
                        ${items.map(renderItem).join('')}
                    </div>
                </div>
            `;
        }

        function renderRecordChildren(recordId) {
            const children = getChildrenForRecord(recordId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Record not found</p>';

            const { fields, outgoingConnections, incomingConnections, definitions, derivedViews, set } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-blue-200">
                    ${set ? `<div class="text-xs text-gray-600"><strong>Set:</strong> ${set.name}</div>` : ''}
                    ${renderChildTable('Fields', 'ph-columns', fields, field => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded flex items-center justify-between">
                            <span><strong>${field.name}</strong></span>
                            <span class="text-gray-500">${field.type}</span>
                        </div>
                    `)}
                    ${renderChildTable('Outgoing Relationships', 'ph-arrow-right', outgoingConnections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('Incoming Relationships', 'ph-arrow-left', incomingConnections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                    ${renderChildTable('Derived Views', 'ph-eye', derivedViews, view => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(view)}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderSetChildren(setId) {
            const children = getChildrenForSet(setId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Set not found</p>';

            const { records, fields, views, definitions, connections, viewEntities } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-green-200">
                    ${renderChildTable('Records', 'ph-database', records.slice(0, 20), record => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${getRecordDisplayName(record.id) || 'Record'}
                        </div>
                    `)}
                    ${records.length > 20 ? `<div class="text-xs text-gray-500 px-2">... and ${records.length - 20} more records</div>` : ''}
                    ${renderChildTable('Fields', 'ph-columns', fields, field => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded flex items-center justify-between">
                            <span><strong>${field.name}</strong></span>
                            <span class="text-gray-500">${field.type}</span>
                        </div>
                    `)}
                    ${renderChildTable('Views', 'ph-stack', views, view => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded flex items-center justify-between">
                            <span>${view.name}</span>
                            <span class="text-gray-500">${view.type}</span>
                        </div>
                    `)}
                    ${renderChildTable('Relationships', 'ph-git-branch', connections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('View Entities', 'ph-eye', viewEntities, ve => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(ve)}
                        </div>
                    `)}
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderConnectionChildren(connectionId) {
            const children = getChildrenForConnection(connectionId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Connection not found</p>';

            const { connection, relation, subjectEntity, operandEntity, definitions } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-purple-200">
                    <div class="text-xs space-y-1">
                        ${relation ? `<div><strong>Relation:</strong> ${relation.name || relation.id}</div>` : ''}
                        <div><strong>Subject:</strong> ${renderEntityLabel(connection.subject)}</div>
                        <div><strong>Operator:</strong> ${connection.operator || connection.mode || ''}</div>
                        <div><strong>Operand:</strong> ${renderEntityLabel(connection.operand)}</div>
                        ${connection.params && Object.keys(connection.params).length > 0 ? `
                            <div class="mt-2">
                                <strong>Parameters:</strong>
                                <pre class="mt-1 p-2 bg-gray-50 rounded text-xs overflow-x-auto">${JSON.stringify(connection.params, null, 2)}</pre>
                            </div>
                        ` : ''}
                    </div>
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderViewEntityChildren(viewEntityId) {
            const children = getChildrenForViewEntity(viewEntityId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">View entity not found</p>';

            const { viewEntity, set, view, memberRefs, lineageConnections, definitions } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-indigo-200">
                    <div class="text-xs space-y-1">
                        ${set ? `<div><strong>Source Set:</strong> ${set.name}</div>` : ''}
                        ${view ? `<div><strong>Source View:</strong> ${view.name} (${view.type})</div>` : ''}
                        ${viewEntity.viewRef ? `<div class="text-gray-600">View Ref: ${viewEntity.viewRef.setId} / ${viewEntity.viewRef.viewId}</div>` : ''}
                    </div>
                    ${renderChildTable('Members', 'ph-users', memberRefs, ref => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(ref)}
                        </div>
                    `)}
                    ${renderChildTable('Lineage Relationships', 'ph-git-branch', lineageConnections, conn => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            ${renderEntityLabel(conn.subject)} ${conn.mode || ''} ${renderEntityLabel(conn.operand)}
                        </div>
                    `)}
                    ${renderChildTable('Definitions', 'ph-book-open', definitions, def => `
                        <div class="text-xs px-2 py-1 hover:bg-gray-50 rounded">
                            <strong>${def.term}:</strong> ${def.definition}
                        </div>
                    `)}
                </div>
            `;
        }

        function renderDefinitionChildren(definitionId) {
            const children = getChildrenForDefinition(definitionId);
            if (!children) return '<p class="text-xs text-gray-500 mt-2">Definition not found</p>';

            const { definition, targetEntity } = children;

            return `
                <div class="mt-3 space-y-2 pl-4 border-l-2 border-yellow-200">
                    <div class="text-xs space-y-1">
                        <div><strong>Term:</strong> ${definition.term}</div>
                        <div><strong>Definition:</strong> ${definition.definition}</div>
                        ${definition.notes ? `<div><strong>Notes:</strong> ${definition.notes}</div>` : ''}
                        ${definition.tags?.length > 0 ? `<div><strong>Tags:</strong> ${definition.tags.join(', ')}</div>` : ''}
                        ${targetEntity ? `<div class="mt-2"><strong>Target Entity:</strong> ${renderEntityLabel(targetEntity)}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function renderChildTables(entity) {
            const entityType = (entity.type || '').toLowerCase();

            switch (entityType) {
                case 'record':
                    return renderRecordChildren(entity.id);
                case 'set':
                    return renderSetChildren(entity.id);
                case 'connection':
                    return renderConnectionChildren(entity.id);
                case 'viewentity':
                    return renderViewEntityChildren(entity.id);
                case 'definition':
                    return renderDefinitionChildren(entity.id);
                default:
                    return '';
            }
        }

        function renderEntityGroups(groupMap) {
            if (!groupMap?.size) return '<p class="text-sm text-gray-500">No entities yet. Reify a view or add one manually.</p>';

            return Array.from(groupMap.entries()).map(([groupKey, entities]) => {
                const reifiedCount = entities.filter(e => e.origin === 'reified').length;
                const manualCount = entities.filter(e => e.origin === 'manual').length;
                return `
                    <div class="border border-gray-200 rounded-lg p-4 bg-white shadow-sm">
                        <div class="flex items-start justify-between gap-3">
                            <div>
                                <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">${groupKey}</div>
                                <div class="text-lg font-semibold text-gray-900">${entities.length} entr${entities.length === 1 ? 'y' : 'ies'}</div>
                                <div class="text-sm text-gray-500">${reifiedCount} reified  ${manualCount} direct</div>
                            </div>
                            <div class="text-right text-xs text-gray-500 leading-tight">
                                <div>Tracked in ${getWorld()?.name || 'world'}</div>
                                <div>Last updated ${new Date(Math.max(...entities.map(e => e.updatedAt || e.createdAt || Date.now()))).toLocaleString()}</div>
                            </div>
                        </div>
                        <div class="mt-3 space-y-2">
                            ${entities.map(entity => `
                                <div class="border border-gray-100 rounded-md p-3 bg-gray-50">
                                    <div class="flex items-center justify-between gap-2">
                                        <div class="min-w-0">
                                            <div class="text-sm font-semibold text-gray-800 truncate">${renderEntityLabel(entity)}</div>
                                            <div class="text-xs text-gray-500 flex flex-wrap items-center gap-2">
                                                <span class="inline-flex items-center gap-1"><i class="ph ph-tag"></i>${entity.type}</span>
                                                ${entity.origin ? `<span class="inline-flex items-center gap-1"><i class="ph ph-compass"></i>${entity.origin}</span>` : ''}
                                                ${entity.viewRef ? `<span class="inline-flex items-center gap-1 text-blue-600"><i class="ph ph-eye"></i>View: ${entity.viewRef.viewName || entity.viewRef.viewId}</span>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2 text-xs">
                                            ${entity.origin === 'manual' ? `<button class="text-red-500" data-entity-delete="${entity.id}">Delete</button>` : `<span class="text-gray-400" title="Reified entities are protected">Protected</span>`}
                                        </div>
                                    </div>
                                    ${renderEntityMembership(entity)}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function resetEntityForm() {
            const form = document.getElementById('entityForm');
            if (!form) return;
            form.reset();
            state.entityFormState.editingId = null;
        }

        function handleEntityFormSubmit() {
            const form = document.getElementById('entityForm');
            if (!form) return;

            const id = form.querySelector('#entityId')?.value.trim();
            const type = form.querySelector('#entityKind')?.value.trim();
            const entityType = form.querySelector('#entityType')?.value.trim();
            const label = form.querySelector('#entityLabel')?.value.trim();
            const notes = form.querySelector('#entityNotes')?.value.trim();

            if (!id || !type) {
                showToast('Please provide both an entity id and type');
                return;
            }

            registerEntity({
                id,
                type,
                entityType: entityType || type,
                name: label || undefined,
                notes,
                origin: 'manual',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                worldId: state.currentWorldId
            });

            showToast(' Entity captured');
            resetEntityForm();
            renderEntitiesPage(state.entityFormState.activeFilter || 'all');
        }

        function renderEntitiesPage(selectedType = null) {
            // Tier 1: Entity Type Selection with full class names for Tailwind
            const entityTypes = [
                {
                    key: 'set',
                    label: 'Sets',
                    icon: 'ph-squares-four',
                    iconClass: 'text-green-600',
                    activeBorder: 'border-green-500',
                    activeBg: 'bg-green-50',
                    activeText: 'text-green-900',
                    activeCount: 'text-green-700'
                },
                {
                    key: 'record',
                    label: 'Records',
                    icon: 'ph-database',
                    iconClass: 'text-blue-600',
                    activeBorder: 'border-blue-500',
                    activeBg: 'bg-blue-50',
                    activeText: 'text-blue-900',
                    activeCount: 'text-blue-700'
                },
                {
                    key: 'connection',
                    label: 'Relationships',
                    icon: 'ph-git-branch',
                    iconClass: 'text-purple-600',
                    activeBorder: 'border-purple-500',
                    activeBg: 'bg-purple-50',
                    activeText: 'text-purple-900',
                    activeCount: 'text-purple-700'
                },
                {
                    key: 'viewentity',
                    label: 'Views',
                    icon: 'ph-eye',
                    iconClass: 'text-indigo-600',
                    activeBorder: 'border-indigo-500',
                    activeBg: 'bg-indigo-50',
                    activeText: 'text-indigo-900',
                    activeCount: 'text-indigo-700'
                },
                {
                    key: 'definition',
                    label: 'Definitions',
                    icon: 'ph-book-open',
                    iconClass: 'text-yellow-600',
                    activeBorder: 'border-yellow-500',
                    activeBg: 'bg-yellow-50',
                    activeText: 'text-yellow-900',
                    activeCount: 'text-yellow-700'
                }
            ];

            // Set default selected type
            if (!selectedType) {
                selectedType = state.entityFormState.selectedType || 'set';
            }
            state.entityFormState.selectedType = selectedType;

            // Get all entities and filter by selected type
            const allEntities = getEntityView();
            const filteredEntities = allEntities.filter(e => (e.type || '').toLowerCase() === selectedType.toLowerCase());

            // Stats
            const totalCount = allEntities.length;
            const typeCount = filteredEntities.length;
            const reifiedCount = filteredEntities.filter(e => e.origin === 'reified').length;
            const manualCount = filteredEntities.filter(e => e.origin === 'manual').length;

            const container = document.getElementById('viewContainer');

            // Tier 2 & 3: Render entity list with expandable rows
            const renderEntityRow = (entity) => {
                const isExpanded = state.entityFormState.expandedEntities.has(entity.id);
                const entityTypeInfo = entityTypes.find(t => t.key === selectedType) || entityTypes[0];

                return `
                    <div class="border border-gray-200 rounded-lg bg-white shadow-sm hover:shadow-md transition-shadow">
                        <div class="p-4 cursor-pointer" data-entity-expand="${entity.id}">
                            <div class="flex items-center justify-between gap-3">
                                <div class="flex items-center gap-3 min-w-0 flex-1">
                                    <div class="flex-shrink-0">
                                        <i class="ph ${entityTypeInfo.icon} ${entityTypeInfo.iconClass} text-xl"></i>
                                    </div>
                                    <div class="min-w-0 flex-1">
                                        <div class="font-semibold text-gray-900 truncate">${renderEntityLabel(entity)}</div>
                                        <div class="text-xs text-gray-500 flex flex-wrap items-center gap-2 mt-1">
                                            <span class="inline-flex items-center gap-1">
                                                <i class="ph ph-fingerprint"></i>${entity.id}
                                            </span>
                                            ${entity.origin ? `
                                                <span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full ${entity.origin === 'reified' ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-700'}">
                                                    ${entity.origin}
                                                </span>
                                            ` : ''}
                                            ${entity.createdAt ? `
                                                <span class="inline-flex items-center gap-1">
                                                    <i class="ph ph-clock"></i>${new Date(entity.createdAt).toLocaleDateString()}
                                                </span>
                                            ` : ''}
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center gap-2 flex-shrink-0">
                                    ${entity.origin === 'manual' ? `
                                        <button class="btn btn-secondary btn-sm text-red-600 hover:bg-red-50" data-entity-delete="${entity.id}" onclick="event.stopPropagation()">
                                            <i class="ph ph-trash"></i>
                                        </button>
                                    ` : `
                                        <span class="text-xs text-gray-400 px-2 py-1 bg-gray-50 rounded" title="Reified entities are protected">
                                            <i class="ph ph-lock"></i>
                                        </span>
                                    `}
                                    <button class="text-gray-400 hover:text-gray-600 transition-transform ${isExpanded ? 'rotate-180' : ''}" onclick="event.stopPropagation()">
                                        <i class="ph ph-caret-down text-xl"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        ${isExpanded ? `
                            <div class="border-t border-gray-200 p-4 bg-gray-50">
                                ${renderChildTables(entity)}
                            </div>
                        ` : ''}
                    </div>
                `;
            };

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'Entities'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Entity Navigator</div>
                            <div class="view-stage-sub">${totalCount} total  ${typeCount} ${selectedType}${typeCount !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <!-- Tier 1: Entity Type Selector -->
                    <div class="space-y-3">
                        <div class="flex items-center justify-between gap-3">
                            <div class="space-y-1">
                                <div class="font-semibold text-gray-900">Entity Types</div>
                                <p class="text-sm text-gray-500">Browse entities organized by type</p>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                            ${entityTypes.map(type => {
                                const count = allEntities.filter(e => (e.type || '').toLowerCase() === type.key).length;
                                const isActive = selectedType === type.key;
                                return `
                                    <button
                                        class="p-4 rounded-lg border-2 ${isActive ? `${type.activeBorder} ${type.activeBg}` : 'border-gray-200 bg-white hover:border-gray-300'} transition-all"
                                        data-entity-type="${type.key}"
                                    >
                                        <div class="flex flex-col items-center gap-2">
                                            <i class="ph ${type.icon} text-2xl ${isActive ? type.iconClass : 'text-gray-600'}"></i>
                                            <div class="text-sm font-semibold ${isActive ? type.activeText : 'text-gray-900'}">${type.label}</div>
                                            <div class="text-xl font-bold ${isActive ? type.activeCount : 'text-gray-700'}">${count}</div>
                                        </div>
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <!-- Statistics Cards -->
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Total</div>
                            <div class="text-2xl font-bold text-gray-900">${typeCount}</div>
                            <div class="text-xs text-gray-500">${selectedType}${typeCount !== 1 ? 's' : ''} in this world</div>
                        </div>
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Reified</div>
                            <div class="text-2xl font-bold text-gray-900">${reifiedCount}</div>
                            <div class="text-xs text-gray-500">Made persistent from views</div>
                        </div>
                        <div class="p-4 rounded-lg border border-gray-200 bg-white shadow-sm">
                            <div class="text-xs font-semibold uppercase tracking-wide text-gray-500">Manual</div>
                            <div class="text-2xl font-bold text-gray-900">${manualCount}</div>
                            <div class="text-xs text-gray-500">Added directly</div>
                        </div>
                    </div>

                    <!-- Tier 2 & 3: Entity List with Expandable Rows -->
                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <div class="font-semibold text-gray-900">${entityTypes.find(t => t.key === selectedType)?.label || 'Entities'}</div>
                            <div class="text-sm text-gray-500">${typeCount} item${typeCount !== 1 ? 's' : ''}</div>
                        </div>
                        ${filteredEntities.length > 0 ? `
                            <div class="space-y-2">
                                ${filteredEntities.map(renderEntityRow).join('')}
                            </div>
                        ` : `
                            <div class="p-8 text-center border-2 border-dashed border-gray-300 rounded-lg">
                                <i class="ph ph-package text-4xl text-gray-400 mb-2"></i>
                                <p class="text-gray-500">No ${selectedType}s found</p>
                                <p class="text-sm text-gray-400 mt-1">Create one to get started</p>
                            </div>
                        `}
                    </div>
                </div>
            `;

            // Event handlers for type selection
            document.querySelectorAll('[data-entity-type]').forEach(btn => {
                btn.onclick = () => renderEntitiesPage(btn.dataset.entityType);
            });

            // Event handlers for expanding/collapsing entities
            document.querySelectorAll('[data-entity-expand]').forEach(elem => {
                elem.onclick = () => {
                    const entityId = elem.dataset.entityExpand;
                    if (state.entityFormState.expandedEntities.has(entityId)) {
                        state.entityFormState.expandedEntities.delete(entityId);
                    } else {
                        state.entityFormState.expandedEntities.add(entityId);
                    }
                    renderEntitiesPage(selectedType);
                };
            });

            // Event handlers for deleting entities
            document.querySelectorAll('[data-entity-delete]').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    deleteEntity(btn.dataset.entityDelete);
                    renderEntitiesPage(selectedType);
                    showToast(' Entity removed');
                };
            });
        }

        // GRAPH VIEW
        let graphNetwork = null;
        let graphConnectionState = {
            isConnecting: false,
            sourceNodeId: null,
            tempEdgeId: null
        };

        function renderGraphView() {
            const set = getCurrentSet();
            const view = getCurrentView();
            const definitions = getDefinitionView();
            const connections = getConnectionView();
            const entities = getEntityView();

            const container = document.getElementById('viewContainer');
            const nodeLabel = definitions.length === 1 ? 'node' : 'nodes';
            const edgeLabel = connections.length === 1 ? 'edge' : 'edges';

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'Graph'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">${view?.name || 'Graph View'}</div>
                            <div class="view-stage-sub">${definitions.length} ${nodeLabel}  ${connections.length} ${edgeLabel}</div>
                        </div>
                    </div>
                    ${set ? renderViewActions() : ''}
                </div>
                <div class="view-stage-body">
                    <div class="graph-container" id="graphContainer" style="position: relative;">
                        <div class="graph-nav-controls" style="position: absolute; top: 10px; right: 10px; z-index: 10; display: flex; flex-direction: column; gap: 8px;">
                            <button id="graphZoomIn" class="graph-nav-btn" title="Zoom In" style="width: 36px; height: 36px; border: 1px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 18px; font-weight: bold; color: #374151;">+</button>
                            <button id="graphZoomOut" class="graph-nav-btn" title="Zoom Out" style="width: 36px; height: 36px; border: 1px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 18px; font-weight: bold; color: #374151;"></button>
                            <button id="graphFit" class="graph-nav-btn" title="Fit to View" style="width: 36px; height: 36px; border: 1px solid #e5e7eb; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 14px; color: #374151;"></button>
                        </div>
                    </div>
                </div>
            `;

            renderGraph(definitions, connections, entities);

            finalizeViewStage();
        }

        function getEntityDisplayName(entityType, entityId) {
            if (!entityType || !entityId) return 'Unknown';

            if (entityType === 'Record') {
                const displayName = getRecordDisplayName(entityId);
                if (displayName) return displayName;
                // Fall back to set name if available
                const ref = getRecordById(entityId);
                return ref?.set?.name || 'Record';
            } else if (entityType === 'Set') {
                const set = state.sets.get(entityId);
                return set?.name || 'Set';
            } else if (entityType === 'World') {
                const world = state.worlds.get(entityId);
                return world?.name || 'World';
            } else if (entityType === 'View') {
                // Try to find the view in sets from the current world
                for (const set of getSetsForWorld()) {
                    if (set.views.has(entityId)) {
                        return set.views.get(entityId)?.name || 'View';
                    }
                }
                return 'View';
            }

            return entityType || 'Entity';
        }

        function renderGraph(definitions, connections, entities = []) {
            const container = document.getElementById('graphContainer');
            if (!container) return;

            // Clean up previous network instance
            if (graphNetwork) {
                graphNetwork.destroy();
                graphNetwork = null;
            }

            // Reset connection state
            graphConnectionState = {
                isConnecting: false,
                sourceNodeId: null,
                tempEdgeId: null
            };

            // Define color scheme based on tags
            const getNodeStyle = (def) => {
                const tags = def.tags || [];
                const term = (def.term || '').toLowerCase();

                // Color by tag/entity type
                if (tags.includes('project') || term.includes('project')) {
                    return { color: '#4F46E5', shape: 'box', font: { color: '#FFFFFF' } }; // Indigo
                } else if (tags.includes('person') || term.includes('dr.') || term.includes('alex') || term.includes('jordan')) {
                    return { color: '#059669', shape: 'dot', size: 25, font: { color: '#000000' } }; // Green
                } else if (tags.includes('concept') || term.includes('observability') || term.includes('graph')) {
                    return { color: '#DC2626', shape: 'diamond', font: { color: '#FFFFFF' } }; // Red
                } else if (term.includes('task') || term.includes('design') || term.includes('implement') || term.includes('build') || term.includes('add') || term.includes('research')) {
                    return { color: '#EA580C', shape: 'ellipse', font: { color: '#FFFFFF' } }; // Orange
                } else {
                    return { color: '#6B7280', shape: 'dot', font: { color: '#000000' } }; // Gray
                }
            };

            // Build nodes from definitions
            const nodes = [];
            const nodeMap = new Map();
            const defMap = new Map();

            definitions.forEach(def => {
                const key = `${def.entity?.type}:${def.entity?.id}`;
                defMap.set(key, def);
                if (!nodeMap.has(key)) {
                    const displayName = getEntityDisplayName(def.entity?.type, def.entity?.id);
                    const label = def.term || displayName;
                    const style = getNodeStyle(def);
                    nodes.push({
                        id: key,
                        label: label,
                        title: def.definition || def.notes || label,
                        entityType: def.entity?.type,
                        entityId: def.entity?.id,
                        ...style
                    });
                    nodeMap.set(key, true);
                }
            });

            // Build edges from connections
            const edges = [];
            const edgeColorMap = {
                'OWN': '#059669',   // Green for ownership
                'ASG': '#3B82F6',   // Blue for assignment
                'SUB': '#8B5CF6',   // Purple for part-of
                'IMP': '#EC4899',   // Pink for implements
                'DEP': '#F59E0B',   // Amber for dependencies
                'REL': '#6B7280'    // Gray for relates
            };

            connections.forEach((conn, idx) => {
                const fromKey = `${conn.subject?.type}:${conn.subject?.id}`;
                const toKey = `${conn.operand?.type}:${conn.operand?.id}`;

                // Add nodes if they don't exist
                if (!nodeMap.has(fromKey)) {
                    const def = defMap.get(fromKey);
                    const displayName = getEntityDisplayName(conn.subject?.type, conn.subject?.id);
                    const style = def ? getNodeStyle(def) : { color: '#6B7280', shape: 'dot' };
                    nodes.push({
                        id: fromKey,
                        label: displayName,
                        entityType: conn.subject?.type,
                        entityId: conn.subject?.id,
                        ...style
                    });
                    nodeMap.set(fromKey, true);
                }
                if (!nodeMap.has(toKey)) {
                    const def = defMap.get(toKey);
                    const displayName = getEntityDisplayName(conn.operand?.type, conn.operand?.id);
                    const style = def ? getNodeStyle(def) : { color: '#6B7280', shape: 'dot' };
                    nodes.push({
                        id: toKey,
                        label: displayName,
                        entityType: conn.operand?.type,
                        entityId: conn.operand?.id,
                        ...style
                    });
                    nodeMap.set(toKey, true);
                }

                const edgeColor = edgeColorMap[conn.operator] || '#999999';
                edges.push({
                    id: `edge-${idx}`,
                    from: fromKey,
                    to: toKey,
                    label: conn.mode || conn.operator || '',
                    arrows: { to: { enabled: true, scaleFactor: 0.5 } },
                    color: { color: edgeColor, highlight: edgeColor },
                    font: { size: 12, align: 'middle', color: '#666666', background: '#FFFFFFCC' },
                    smooth: { type: 'continuous' }
                });
            });

            if (nodes.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999;">No graph data available</div>';
                return;
            }

            // Create network with enhanced options
            const data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };

            const options = {
                autoResize: true,
                height: '100%',
                width: '100%',
                physics: {
                    enabled: true,
                    stabilization: {
                        enabled: true,
                        iterations: 200,
                        updateInterval: 25
                    },
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 150,
                        springConstant: 0.04,
                        damping: 0.09,
                        avoidOverlap: 0.5
                    }
                },
                layout: {
                    improvedLayout: true,
                    hierarchical: false
                },
                nodes: {
                    borderWidth: 2,
                    borderWidthSelected: 3,
                    font: {
                        size: 14,
                        face: 'system-ui, -apple-system, sans-serif'
                    },
                    shadow: {
                        enabled: true,
                        color: 'rgba(0,0,0,0.2)',
                        size: 10,
                        x: 2,
                        y: 2
                    }
                },
                edges: {
                    width: 2,
                    selectionWidth: 3
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 200,
                    navigationButtons: false,
                    keyboard: true
                },
                manipulation: {
                    enabled: false
                }
            };

            graphNetwork = new vis.Network(container, data, options);

            // Setup navigation controls
            const zoomInBtn = document.getElementById('graphZoomIn');
            const zoomOutBtn = document.getElementById('graphZoomOut');
            const fitBtn = document.getElementById('graphFit');

            if (zoomInBtn) {
                zoomInBtn.onclick = () => {
                    const scale = graphNetwork.getScale();
                    graphNetwork.moveTo({ scale: scale * 1.2 });
                };
            }

            if (zoomOutBtn) {
                zoomOutBtn.onclick = () => {
                    const scale = graphNetwork.getScale();
                    graphNetwork.moveTo({ scale: scale * 0.8 });
                };
            }

            if (fitBtn) {
                fitBtn.onclick = () => {
                    graphNetwork.fit({ padding: 50, animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
                };
            }

            // Click to open record detail or connect nodes
            graphNetwork.on('click', (params) => {
                if (params.nodes.length > 0) {
                    const clickedNodeId = params.nodes[0];
                    const clickedNode = data.nodes.get(clickedNodeId);

                    // If clicking on a Record node and not in connection mode, open record detail
                    if (clickedNode?.entityType === 'Record' && !graphConnectionState.isConnecting) {
                        openExpandedRecord(clickedNode.entityId);
                        return;
                    }

                    if (!graphConnectionState.isConnecting) {
                        // Start connection
                        graphConnectionState.isConnecting = true;
                        graphConnectionState.sourceNodeId = clickedNodeId;

                        // Highlight source node
                        graphNetwork.selectNodes([clickedNodeId]);
                        showToast('Click on another node to connect');
                    } else {
                        // Complete connection
                        const targetNodeId = clickedNodeId;

                        if (graphConnectionState.sourceNodeId === targetNodeId) {
                            showToast('Cannot connect a node to itself');
                            graphConnectionState.isConnecting = false;
                            graphConnectionState.sourceNodeId = null;
                            graphNetwork.unselectAll();
                            return;
                        }

                        // Get node data
                        const sourceNode = data.nodes.get(graphConnectionState.sourceNodeId);
                        const targetNode = data.nodes.get(targetNodeId);

                        if (sourceNode && targetNode) {
                            openGraphConnectionModal(sourceNode, targetNode);
                        }

                        // Reset state
                        graphConnectionState.isConnecting = false;
                        graphConnectionState.sourceNodeId = null;
                        graphNetwork.unselectAll();
                    }
                } else if (graphConnectionState.isConnecting) {
                    // Cancel connection if clicking on empty space
                    graphConnectionState.isConnecting = false;
                    graphConnectionState.sourceNodeId = null;
                    graphNetwork.unselectAll();
                    showToast('Cancelled');
                }
            });

            // Disable physics after stabilization
            graphNetwork.once('stabilizationIterationsDone', () => {
                graphNetwork.setOptions({ physics: false });
            });

            // Fit to view after stabilization
            graphNetwork.once('stabilizationIterationsDone', () => {
                setTimeout(() => {
                    graphNetwork.fit({ padding: 50, animation: { duration: 1000, easingFunction: 'easeInOutQuad' } });
                }, 100);
            });
        }

        function openGraphConnectionModal(sourceNode, targetNode) {
            const formats = getConnectionRelationView();

            // Pre-populate the connection modal with source and target
            resetConnectionForm();

            // Open a custom modal for selecting connection type
            const modalHtml = `
                <div id="graphConnectionModal" class="fixed inset-0 bg-black bg-opacity-20 modal-overlay flex items-center justify-center p-6 z-50">
                    <div class="bg-white rounded-lg shadow-xl max-w-md w-full modal-container">
                        <div class="modal-header">
                            <h2 class="text-xl font-bold text-gray-900">Create Connection</h2>
                            <button class="text-gray-400 hover:text-gray-600 transition" onclick="closeGraphConnectionModal()" aria-label="Close">
                                <i class="ph ph-x text-xl"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-4">
                                <p class="text-sm text-gray-600 mb-2">From:</p>
                                <p class="font-semibold text-gray-900">${sourceNode.label}</p>
                                <p class="text-xs text-gray-500">${sourceNode.entityType}: ${sourceNode.entityId}</p>
                            </div>
                            <div class="mb-4">
                                <p class="text-sm text-gray-600 mb-2">To:</p>
                                <p class="font-semibold text-gray-900">${targetNode.label}</p>
                                <p class="text-xs text-gray-500">${targetNode.entityType}: ${targetNode.entityId}</p>
                            </div>
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Connection Type</label>
                                <select id="graphConnectionRelation" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="">Select a connection type...</option>
                                    ${formats.map(fmt => `<option value="${fmt.id}">${fmt.operator} - ${fmt.mode || 'No mode'}</option>`).join('')}
                                </select>
                            </div>
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Description (optional)</label>
                                <textarea id="graphConnectionDescription" rows="2" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                            </div>
                        </div>
                        <div class="modal-footer flex gap-2 justify-end">
                            <button class="btn btn-secondary" type="button" onclick="closeGraphConnectionModal()">Cancel</button>
                            <button class="btn btn-primary" type="button" onclick="handleGraphConnectionSubmit('${sourceNode.entityType}', '${sourceNode.entityId}', '${targetNode.entityType}', '${targetNode.entityId}')">Create Connection</button>
                        </div>
                    </div>
                </div>
            `;

            // Remove any existing modal
            const existingModal = document.getElementById('graphConnectionModal');
            if (existingModal) existingModal.remove();

            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function closeGraphConnectionModal() {
            const modal = document.getElementById('graphConnectionModal');
            if (modal) modal.remove();
        }

        function handleGraphConnectionSubmit(sourceType, sourceId, targetType, targetId) {
            const formatId = document.getElementById('graphConnectionRelation')?.value;
            const description = document.getElementById('graphConnectionDescription')?.value?.trim() || '';

            if (!formatId) {
                showToast('Please select a connection type');
                return;
            }

            const payload = {
                formatId,
                subject: { type: sourceType, id: sourceId },
                operand: { type: targetType, id: targetId },
                description,
                params: {}
            };

            try {
                addConnection(payload);
                showToast('Relationship created');
                closeGraphConnectionModal();

                // Refresh the graph view
                const definitions = getDefinitionView();
                const connections = getConnectionView();
                renderGraph(definitions, connections);
            } catch (error) {
                showToast(` ${error.message || 'Failed to create connection'}`);
            }
        }

        function serializeTagsInput(value) {
            return (value || '')
                .split(',')
                .map(tag => tag.trim())
                .filter(Boolean);
        }

        function parseDefinitionGridRows(text) {
            const lines = (text || '').split('\n').map(line => line.trim()).filter(Boolean);
            if (!lines.length) return [];

            const delimiter = lines.some(line => line.includes('\t')) ? '\t' : ',';
            const splitLine = (line) => line.split(delimiter).map(cell => cell.trim());
            const headerCells = splitLine(lines[0]).map(cell => cell.toLowerCase());
            const headerKeywords = ['entity type', 'entity id', 'term', 'definition'];
            const hasHeader = headerKeywords.some(keyword => headerCells.some(cell => cell.includes(keyword.replace(' ', '_')) || cell.includes(keyword)));
            const startIndex = hasHeader ? 1 : 0;

            const rows = [];
            for (let i = startIndex; i < lines.length; i++) {
                const cells = splitLine(lines[i]);
                if (!cells.length || cells.every(cell => !cell)) continue;
                const [entityType, entityId, term, definitionText, notes = '', tags = ''] = cells;
                rows.push({
                    entityType: entityType || '',
                    entityId: entityId || '',
                    term: term || '',
                    definition: definitionText || '',
                    notes: notes || '',
                    tags: serializeTagsInput(tags)
                });
            }

            return rows;
        }

        function handleDefinitionImportSubmit() {
            const textarea = document.getElementById('definitionImportText');
            if (!textarea) return;

            const rows = parseDefinitionGridRows(textarea.value);
            if (!rows.length) {
                showToast('Please paste at least one row');
                return;
            }

            let added = 0;
            let updated = 0;
            let skipped = 0;

            rows.forEach(row => {
                const entityType = row.entityType?.trim();
                const entityId = row.entityId?.trim();
                const term = row.term?.trim();
                const definitionText = row.definition?.trim();

                if (!entityType || !entityId || !term || !definitionText) {
                    skipped += 1;
                    return;
                }

                const payload = {
                    entity: { type: entityType, id: entityId },
                    term,
                    definition: definitionText,
                    notes: row.notes?.trim() || '',
                    tags: row.tags || []
                };

                const existing = findDefinitionByEntity(payload.entity);
                if (existing) {
                    updateDefinition(existing.id, payload);
                    updated += 1;
                } else {
                    addDefinition(payload);
                    added += 1;
                }
            });

            renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
            showToast(` Imported ${added + updated} definitions${updated ? ` (${updated} updated)` : ''}${skipped ? `  ${skipped} skipped` : ''}`);
        }

        function openDefinitionModal(definitionId = null) {
            resetDefinitionForm();
            if (definitionId) populateDefinitionForm(definitionId);
            openModal('definitionModal');
            const entityTypeSelect = document.getElementById('definitionEntityType');
            if (entityTypeSelect) entityTypeSelect.focus();
        }

        function closeDefinitionModal() {
            closeModal('definitionModal');
        }

        function resetDefinitionForm() {
            state.definitionFormState.editingId = null;
            const form = document.getElementById('definitionForm');
            if (!form) return;
            form.reset();
            const submit = document.getElementById('definitionSubmit');
            if (submit) submit.textContent = 'Add Definition';
            const title = document.getElementById('definitionModalTitle');
            if (title) title.textContent = 'Add Definition';
        }

        function populateDefinitionForm(definitionId) {
            const def = state.definitions.get(definitionId);
            if (!def) return;
            const form = document.getElementById('definitionForm');
            if (!form) return;
            form.querySelector('#definitionEntityType').value = def.entity?.type || '';
            form.querySelector('#definitionEntityId').value = def.entity?.id || '';
            form.querySelector('#definitionTerm').value = def.term || '';
            form.querySelector('#definitionDefinition').value = def.definition || '';
            form.querySelector('#definitionNotes').value = def.notes || '';
            form.querySelector('#definitionTags').value = (def.tags || []).join(', ');
            const submit = document.getElementById('definitionSubmit');
            if (submit) submit.textContent = 'Save Definition';
            const title = document.getElementById('definitionModalTitle');
            if (title) title.textContent = 'Edit Definition';
            state.definitionFormState.editingId = def.id;
            openModal('definitionModal');
        }

        function handleDefinitionFormSubmit() {
            const form = document.getElementById('definitionForm');
            if (!form) return;
            const entityType = form.querySelector('#definitionEntityType').value;
            const entityId = form.querySelector('#definitionEntityId').value.trim();
            const term = form.querySelector('#definitionTerm').value.trim();
            const definitionText = form.querySelector('#definitionDefinition').value.trim();
            const notes = form.querySelector('#definitionNotes').value.trim();
            const tags = serializeTagsInput(form.querySelector('#definitionTags').value);

            if (!entityType || !entityId || !term || !definitionText) {
                showToast('Please complete entity, term, and definition');
                return;
            }

            const payload = {
                id: state.definitionFormState.editingId,
                entity: { type: entityType, id: entityId },
                term,
                definition: definitionText,
                notes,
                tags
            };

            if (state.definitionFormState.editingId) {
                updateDefinition(payload.id, payload);
                showToast(' Definition updated');
            } else {
                addDefinition(payload);
                showToast(' Definition added');
            }

            resetDefinitionForm();
            closeDefinitionModal();
            renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
        }

        function attachDefinitionInlineEditing() {
            document.querySelectorAll('[data-def-inline]').forEach(cell => {
                const [field, defId] = (cell.dataset.defInline || '').split(':');
                if (!field || !defId) return;

                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;

                    const def = state.definitions.get(defId);
                    if (!def) return;
                    const updates = { ...def };
                    if (field === 'tags') {
                        updates.tags = current ? current.split(',').map(t => t.trim()).filter(Boolean) : [];
                    } else {
                        updates[field] = current;
                    }

                    updateDefinition(defId, updates);
                    showToast(' Definition updated');
                    renderDefinitionsPage(state.definitionFormState.activeFilter || 'all');
                };
            });
        }

        function renderDefinitionsTable(definitions) {
            if (!definitions.length) return '<p class="text-sm text-gray-500">No definitions yet.</p>';
            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Entity</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Term</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Definition</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Notes</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Tags</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${definitions.map(def => `
                                <tr>
                                    <td class="px-4 py-3 whitespace-nowrap text-gray-800">${def.entity.type}: ${renderEntityLabel(def.entity)}</td>
                                    <td class="px-4 py-3 font-semibold text-gray-900" data-def-inline="term:${def.id}">${def.term}</td>
                                    <td class="px-4 py-3 text-gray-700" data-def-inline="definition:${def.id}">${def.definition}</td>
                                    <td class="px-4 py-3 text-gray-500" data-def-inline="notes:${def.id}">${def.notes || ''}</td>
                                    <td class="px-4 py-3 text-gray-500" data-def-inline="tags:${def.id}">${(def.tags || []).join(', ')}</td>
                                    <td class="px-4 py-3 whitespace-nowrap space-x-3">
                                        <button class="text-blue-600" data-def-edit="${def.id}">Edit</button>
                                        <button class="text-red-500" data-def-delete="${def.id}">Delete</button>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderDefinitionsPage(filterKey = 'all') {
            state.definitionFormState.activeFilter = filterKey;
            const filters = {
                all: () => true,
                records: def => def.entity?.type === 'Record',
                fields: def => def.entity?.type === 'Field',
                connections: def => def.entity?.type === 'Connection',
                viewEntities: def => def.entity?.type === 'ViewEntity',
                core: def => (def.tags || []).includes('core'),
                demo: def => (def.tags || []).includes('demo')
            };

            const definitions = getDefinitionView(filters[filterKey]);
            const container = document.getElementById('viewContainer');
            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Definitions</div>
                            <div class="view-stage-sub">${definitions.length} entries</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-4">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex flex-wrap gap-2">
                            ${Object.keys(filters).map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-def-filter="${key}">${key === 'all' ? 'All' : key.charAt(0).toUpperCase() + key.slice(1)}</button>`).join('')}
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-secondary btn-sm" id="toggleDefinitionImport">${state.definitionFormState.showImportPanel ? 'Hide Import' : 'Import Definitions'}</button>
                            <button class="btn btn-primary btn-sm" id="openDefinitionModalBtn">Add Definition</button>
                        </div>
                    </div>
                    ${state.definitionFormState.showImportPanel ? `
                    <div class="border border-gray-200 rounded-lg bg-white p-4 space-y-3">
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="font-semibold">Import definitions</div>
                                <p class="text-sm text-gray-500">Paste tab or comma separated rows: Entity Type, Entity ID, Term, Definition, Notes, Tags.</p>
                            </div>
                            <button class="btn btn-secondary btn-sm" id="closeDefinitionImport">Close</button>
                        </div>
                        <textarea id="definitionImportText" class="w-full border rounded px-3 py-2 text-sm font-mono" rows="5" placeholder="Record\tobs_123\tSnow depth\tDepth of snow in cm\tMetric reference\twinter, core"></textarea>
                        <div class="text-xs text-gray-500">Existing rows update matching entities; missing fields are skipped.</div>
                        <div class="flex justify-end">
                            <button class="btn btn-primary btn-sm" id="runDefinitionImport">Import pasted rows</button>
                        </div>
                    </div>
                    ` : ''}
                    ${renderDefinitionsTable(definitions)}
                </div>
            `;

            document.querySelectorAll('[data-def-filter]').forEach(btn => {
                btn.onclick = () => renderDefinitionsPage(btn.dataset.defFilter);
            });

            document.querySelectorAll('[data-def-edit]').forEach(btn => {
                btn.onclick = () => openDefinitionModal(btn.dataset.defEdit);
            });

            document.querySelectorAll('[data-def-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteDefinition(btn.dataset.defDelete);
                    renderDefinitionsPage(filterKey);
                    showToast(' Definition removed');
                };
            });

            const importToggleBtn = document.getElementById('toggleDefinitionImport');
            if (importToggleBtn) {
                importToggleBtn.onclick = () => {
                    state.definitionFormState.showImportPanel = !state.definitionFormState.showImportPanel;
                    renderDefinitionsPage(filterKey);
                };
            }

            const importCloseBtn = document.getElementById('closeDefinitionImport');
            if (importCloseBtn) {
                importCloseBtn.onclick = () => {
                    state.definitionFormState.showImportPanel = false;
                    renderDefinitionsPage(filterKey);
                };
            }

            const importRunBtn = document.getElementById('runDefinitionImport');
            if (importRunBtn) importRunBtn.onclick = handleDefinitionImportSubmit;

            const openModalBtn = document.getElementById('openDefinitionModalBtn');
            if (openModalBtn) openModalBtn.onclick = () => openDefinitionModal();

            const form = document.getElementById('definitionForm');
            if (form) form.onsubmit = (event) => { event.preventDefault(); handleDefinitionFormSubmit(); };

            attachDefinitionInlineEditing();
        }

        // ============================================================================
        // VIEWS PAGE
        // ============================================================================

        function renderViewsPage(filterType = 'all') {
            state.viewsPageState = state.viewsPageState || { activeFilter: 'all' };
            state.viewsPageState.activeFilter = filterType;

            const container = document.getElementById('viewContainer');
            if (!container) return;

            // Collect all views from all sets
            const allViews = [];
            const setsForWorld = getSetsForWorld();

            setsForWorld.forEach(set => {
                if (set.views && set.views.size > 0) {
                    set.views.forEach((viewRef, viewId) => {
                        // Get full view from global state if available
                        const fullView = state.views?.get(viewId) || viewRef;
                        allViews.push({
                            ...fullView,
                            id: viewId,
                            setId: set.id,
                            setName: set.name,
                            recordCount: set.records ? set.records.size : 0
                        });
                    });
                }
            });

            // Apply filter
            const filters = {
                all: () => true,
                grid: v => v.type === 'grid',
                card: v => v.type === 'card',
                kanban: v => v.type === 'kanban',
                graph: v => v.type === 'graph',
                KEY_DERIVED: v => v.type === 'KEY_DERIVED'
            };

            const filteredViews = allViews.filter(filters[filterType] || filters.all);

            // Sort by set name, then view name
            filteredViews.sort((a, b) => {
                if (a.setName !== b.setName) return a.setName.localeCompare(b.setName);
                return (a.name || '').localeCompare(b.name || '');
            });

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Views</div>
                            <div class="view-stage-sub">${filteredViews.length} view${filteredViews.length !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-4">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex flex-wrap gap-2">
                            <button class="btn btn-secondary btn-sm ${filterType === 'all' ? 'btn-primary' : ''}" data-view-filter="all">All</button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'grid' ? 'btn-primary' : ''}" data-view-filter="grid">
                                <i class="ph ph-table"></i> Grid
                            </button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'card' ? 'btn-primary' : ''}" data-view-filter="card">
                                <i class="ph ph-cards-three"></i> Gallery
                            </button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'kanban' ? 'btn-primary' : ''}" data-view-filter="kanban">
                                <i class="ph ph-kanban"></i> Kanban
                            </button>
                            <button class="btn btn-secondary btn-sm ${filterType === 'graph' ? 'btn-primary' : ''}" data-view-filter="graph">
                                <i class="ph ph-graph"></i> Graph
                            </button>
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-primary btn-sm" onclick="handleAddViewClick()">
                                <i class="ph ph-plus"></i> New View
                            </button>
                        </div>
                    </div>
                    ${renderViewsTable(filteredViews)}
                </div>
            `;

            // Attach filter button handlers
            document.querySelectorAll('[data-view-filter]').forEach(btn => {
                btn.onclick = () => renderViewsPage(btn.dataset.viewFilter);
            });

            // Attach action handlers
            document.querySelectorAll('[data-view-open]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewOpen.split(':');
                    switchSet(setId, viewId);
                };
            });

            document.querySelectorAll('[data-view-edit]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewEdit.split(':');
                    openEditViewModal(setId, viewId);
                };
            });

            document.querySelectorAll('[data-view-duplicate]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewDuplicate.split(':');
                    duplicateView(setId, viewId);
                };
            });

            document.querySelectorAll('[data-view-delete]').forEach(btn => {
                btn.onclick = () => {
                    const [setId, viewId] = btn.dataset.viewDelete.split(':');
                    if (confirm('Are you sure you want to delete this view?')) {
                        deleteViewFromSet(setId, viewId);
                        renderViewsPage(filterType);
                        showToast('View deleted');
                    }
                };
            });
        }

        function renderViewsTable(views) {
            if (!views.length) {
                return `
                    <div class="text-center py-12 text-gray-500">
                        <i class="ph ph-layout text-4xl mb-3 block opacity-50"></i>
                        <p class="text-sm">No views found</p>
                        <p class="text-xs mt-1">Create a view to organize and visualize your data</p>
                    </div>
                `;
            }

            return `
                <div class="overflow-auto border border-gray-200 rounded-lg bg-white">
                    <table class="min-w-full text-sm">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">View</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Type</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Set</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Records</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Filters</th>
                                <th class="px-4 py-3 text-left text-xs font-semibold text-gray-500">Created</th>
                                <th class="px-4 py-3 text-right text-xs font-semibold text-gray-500">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200">
                            ${views.map(view => {
                                const viewIcon = view.icon || VIEW_TYPE_ICONS[view.type] || 'ph-table';
                                const viewType = formatViewType(view.type);
                                const filterCount = (view.filters || []).length;
                                const createdAt = view.provenance?.createdAt
                                    ? new Date(view.provenance.createdAt).toLocaleDateString()
                                    : (view.createdAt ? new Date(view.createdAt).toLocaleDateString() : '');

                                return `
                                    <tr class="hover:bg-gray-50 transition-colors cursor-pointer" data-view-row="${view.setId}:${view.id}">
                                        <td class="px-4 py-3">
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-400">${renderIcon(viewIcon)}</span>
                                                <span class="font-medium text-gray-900">${escapeHtml(view.name || 'Untitled')}</span>
                                            </div>
                                        </td>
                                        <td class="px-4 py-3">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-700">
                                                ${viewType}
                                            </span>
                                        </td>
                                        <td class="px-4 py-3 text-gray-600">${escapeHtml(view.setName || '')}</td>
                                        <td class="px-4 py-3 text-gray-600">${view.recordCount}</td>
                                        <td class="px-4 py-3">
                                            ${filterCount > 0
                                                ? `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-50 text-blue-700">${filterCount} filter${filterCount !== 1 ? 's' : ''}</span>`
                                                : '<span class="text-gray-400"></span>'
                                            }
                                        </td>
                                        <td class="px-4 py-3 text-gray-500 text-xs">${createdAt}</td>
                                        <td class="px-4 py-3 text-right">
                                            <div class="flex items-center justify-end gap-1">
                                                <button class="p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-view-open="${view.setId}:${view.id}" title="Open view">
                                                    <i class="ph ph-arrow-square-out text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded transition-colors" data-view-edit="${view.setId}:${view.id}" title="Edit view">
                                                    <i class="ph ph-pencil-simple text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded transition-colors" data-view-duplicate="${view.setId}:${view.id}" title="Duplicate view">
                                                    <i class="ph ph-copy text-sm"></i>
                                                </button>
                                                <button class="p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition-colors" data-view-delete="${view.setId}:${view.id}" title="Delete view">
                                                    <i class="ph ph-trash text-sm"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function formatViewType(type) {
            const typeLabels = {
                grid: 'Grid',
                card: 'Gallery',
                kanban: 'Kanban',
                graph: 'Graph',
                KEY_DERIVED: 'Key Derived'
            };
            return typeLabels[type] || type || 'Grid';
        }

        function duplicateView(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set || !set.views) return;

            const originalView = state.views?.get(viewId) || set.views.get(viewId);
            if (!originalView) return;

            const newViewId = `view_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
            const newView = {
                ...originalView,
                id: newViewId,
                name: `${originalView.name || 'Untitled'} (copy)`,
                provenance: {
                    ...originalView.provenance,
                    createdAt: Date.now(),
                    updatedAt: null,
                    derivedFromViewIds: [viewId],
                    notes: `Duplicated from ${originalView.name}`
                }
            };

            // Add to global views
            if (!state.views) state.views = new Map();
            state.views.set(newViewId, newView);

            // Add to set
            set.views.set(newViewId, { id: newViewId });

            showToast('View duplicated');
            renderViewsPage(state.viewsPageState?.activeFilter || 'all');
        }

        function deleteViewFromSet(setId, viewId) {
            const set = state.sets.get(setId);
            if (!set || !set.views) return;

            // Remove from set
            set.views.delete(viewId);

            // Remove from global views
            if (state.views) {
                state.views.delete(viewId);
            }

            // If this was the current view, clear selection
            if (state.currentViewId === viewId) {
                state.currentViewId = null;
            }
        }

        function renderModeOptions(operator, selectedMode = '') {
            const modes = getModesForOperator(operator);
            return modes.map(mode => `<option value="${mode}" ${mode === selectedMode ? 'selected' : ''}>${mode}</option>`).join('');
        }

        function populateConnectionRelationOptions(selectedOperator = '') {
            const operatorSelect = document.getElementById('connectionRelationOperator');
            if (!operatorSelect) return;
            const operatorOptions = Object.keys(state.connectionModes || {});
            operatorSelect.innerHTML = ['<option value="">Select operator</option>', ...operatorOptions.map(op => `<option value="${op}">${op}</option>`)].join('');
            operatorSelect.value = selectedOperator || operatorOptions[0] || '';

            const modeSelect = document.getElementById('connectionRelationMode');
            if (modeSelect) {
                modeSelect.innerHTML = renderModeOptions(operatorSelect.value || selectedOperator, '');
            }
        }

        function populateConnectionRelationForm(relationId) {
            const relation = state.connectionRelations.get(relationId);
            if (!relation) return;
            const form = document.getElementById('connectionRelationForm');
            if (!form) return;

            populateConnectionRelationOptions(relation.operator);

            form.querySelector('#connectionRelationOperator').value = relation.operator;
            const modeSelect = form.querySelector('#connectionRelationMode');
            if (modeSelect) {
                modeSelect.innerHTML = renderModeOptions(relation.operator, relation.mode);
            }

            form.querySelector('#connectionRelationName').value = relation.name || '';
            form.querySelector('#connectionRelationDescription').value = relation.description || '';
            state.connectionRelationFormState.editingId = relation.id;

            const submit = document.getElementById('connectionRelationSubmit');
            if (submit) submit.textContent = 'Save';
            const title = document.getElementById('connectionRelationModalTitle');
            if (title) title.textContent = 'Edit Relation Type';
            openModal('connectionRelationModal');
        }

        function resetConnectionRelationForm() {
            state.connectionRelationFormState.editingId = null;
            const form = document.getElementById('connectionRelationForm');
            if (!form) return;
            form.reset();
            populateConnectionRelationOptions();
            const submit = document.getElementById('connectionRelationSubmit');
            if (submit) submit.textContent = 'Add';
            const title = document.getElementById('connectionRelationModalTitle');
            if (title) title.textContent = 'Add Relation Type';
        }

        function openConnectionRelationModal(relationId = null) {
            resetConnectionRelationForm();
            if (relationId) populateConnectionRelationForm(relationId);
            openModal('connectionRelationModal');
        }

        function handleConnectionRelationSubmit() {
            const form = document.getElementById('connectionRelationForm');
            if (!form) return;

            const operator = form.querySelector('#connectionRelationOperator')?.value;
            const mode = form.querySelector('#connectionRelationMode')?.value;
            const name = form.querySelector('#connectionRelationName')?.value || '';
            const description = form.querySelector('#connectionRelationDescription')?.value || '';

            const payload = {
                id: state.connectionRelationFormState.editingId,
                operator,
                mode,
                name,
                description,
                worldId: state.currentWorldId
            };

            const isEdit = Boolean(state.connectionRelationFormState.editingId);
            try {
                if (isEdit) {
                    updateConnectionRelation(payload.id, payload);
                    showToast('Relation type updated');
                } else {
                    addConnectionRelation(payload);
                    showToast('Relation type added');
                }
            } catch (error) {
                showToast(error.message);
                return;
            }

            resetConnectionRelationForm();
            closeModal('connectionRelationModal');
            renderRelationsPage(state.connectionFormState.activeFilter || 'all');
        }

        function renderConnectionParamFields(containerId, relationId, params = {}) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const relation = findConnectionRelation(relationId);
            if (!relation) {
                container.innerHTML = '<p class="text-sm text-gray-500">Select a relation to enter parameters.</p>';
                return;
            }

            const allParams = [...relation.requiredParams, ...relation.optionalParams];
            if (!allParams.length) {
                container.innerHTML = '<p class="text-sm text-gray-500">No parameters required for this relation.</p>';
                return;
            }

            container.innerHTML = allParams.map(name => {
                const required = relation.requiredParams.includes(name);
                const value = params[name] !== undefined ? params[name] : '';
                const safeValue = typeof value === 'object' ? JSON.stringify(value) : String(value || '');
                const escapedValue = safeValue
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');
                return `
                    <div>
                        <label class="form-label">${name}${required ? ' *' : ''}</label>
                        <input
                            type="text"
                            class="border rounded px-3 py-2 w-full"
                            data-param-name="${name}"
                            data-param-required="${required ? 'true' : 'false'}"
                            value="${escapedValue}"
                        />
                    </div>
                `;
            }).join('');
        }

        function populateConnectionForm(connId) {
            const conn = state.connections.get(connId);
            if (!conn) return;
            const form = document.getElementById('connectionForm');
            if (!form) return;
            populateConnectionSelectOptions(conn.relationId, conn.params || {});
            form.querySelector('#connectionSubjectType').value = conn.subject?.type || '';
            form.querySelector('#connectionSubjectId').value = conn.subject?.id || '';
            form.querySelector('#connectionOperandType').value = conn.operand?.type || '';
            form.querySelector('#connectionOperandId').value = conn.operand?.id || '';
            form.querySelector('#connectionDescription').value = conn.description || '';
            state.connectionFormState.editingId = conn.id;

            const submit = document.getElementById('connectionSubmit');
            if (submit) submit.textContent = 'Save';
            const title = document.getElementById('connectionModalTitle');
            if (title) title.textContent = 'Edit Relationship';
        }

        function resetConnectionForm() {
            state.connectionFormState.editingId = null;
            const form = document.getElementById('connectionForm');
            if (!form) return;
            form.reset();
            const defaultRelation = getDefaultConnectionRelationId();
            populateConnectionSelectOptions(defaultRelation, {});
            const submit = document.getElementById('connectionSubmit');
            if (submit) submit.textContent = 'Add';
            const title = document.getElementById('connectionModalTitle');
            if (title) title.textContent = 'Add Relationship';
        }

        function populateConnectionSelectOptions(selectedRelationId, params = {}) {
            const select = document.getElementById('connectionRelationSelect');
            if (!select) return;
            const relations = getConnectionRelationView();
            select.innerHTML = ['<option value="">Select a relation</option>', ...relations.map(rel => `<option value="${rel.id}">${rel.mode}</option>`)].join('');
            const resolved = selectedRelationId || getDefaultConnectionRelationId();
            state.connectionFormState.selectedRelationId = resolved;
            if (resolved) select.value = resolved;
            renderConnectionParamFields('connectionParamFields', resolved, params);
            updateConnectionRelationSummary(resolved);
        }

        function updateConnectionRelationSummary(relationId) {
            const summary = document.getElementById('connectionRelationSummary');
            const relation = relationId ? findConnectionRelation(relationId) : null;
            if (!summary) return;
            summary.textContent = relation?.description || '';
        }

        function openConnectionModal(connId = null) {
            resetConnectionForm();
            if (connId) populateConnectionForm(connId);
            openModal('connectionModal');
            const typeSelect = document.getElementById('connectionSubjectType');
            if (typeSelect) typeSelect.focus();
        }

        function collectParamsFromInputs(containerId, relation) {
            const container = document.getElementById(containerId);
            const params = {};
            if (!container || !relation) return params;

            const inputs = container.querySelectorAll('[data-param-name]');
            for (const input of inputs) {
                const name = input.dataset.paramName;
                const required = input.dataset.paramRequired === 'true';
                const rawValue = (input.value || '').trim();
                if (!rawValue) {
                    if (required) throw new Error(`Missing required param: ${name}`);
                    continue;
                }

                try {
                    params[name] = JSON.parse(rawValue);
                } catch (err) {
                    params[name] = rawValue;
                }
            }

            return params;
        }

        function handleConnectionFormSubmit() {
            const form = document.getElementById('connectionForm');
            if (!form) return;

            const relationId = form.querySelector('#connectionRelationSelect')?.value;
            if (!relationId) {
                showToast('Select a connection relation');
                return;
            }

            const relation = findConnectionRelation(relationId);
            if (!relation) {
                showToast('Selected connection relation not found');
                return;
            }

            let params = {};
            try {
                params = collectParamsFromInputs('connectionParamFields', relation);
            } catch (error) {
                showToast(error.message);
                return;
            }

            const payload = {
                id: state.connectionFormState.editingId,
                relationId,
                subject: { type: form.querySelector('#connectionSubjectType').value, id: form.querySelector('#connectionSubjectId').value.trim() },
                operand: { type: form.querySelector('#connectionOperandType').value, id: form.querySelector('#connectionOperandId').value.trim() },
                description: form.querySelector('#connectionDescription').value.trim(),
                params
            };

            if (!payload.subject.type || !payload.subject.id || !payload.operand.type || !payload.operand.id) {
                showToast('Please provide subject and operand details');
                return;
            }

            if (state.connectionFormState.editingId) {
                updateConnection(payload.id, payload);
                showToast('Relationship updated');
            } else {
                addConnection(payload);
                showToast('Relationship added');
            }

            resetConnectionForm();
            closeModal('connectionModal');
            renderRelationsPage(state.connectionFormState.activeFilter || 'all');
        }

        function renderRelationTypesList(relations) {
            if (!relations.length) return '<p class="text-sm text-gray-500">No relation types defined yet.</p>';
            return `
                <div class="space-y-2">
                    ${relations.map(rel => `
                        <div class="flex items-center justify-between py-2 px-3 bg-gray-50 rounded-lg">
                            <div class="flex items-center gap-3">
                                <span class="text-sm font-medium text-gray-900">${rel.mode}</span>
                                <span class="text-xs px-2 py-0.5 bg-gray-200 text-gray-600 rounded">${rel.operator}</span>
                                ${rel.description ? `<span class="text-xs text-gray-500">${rel.description}</span>` : ''}
                            </div>
                            <div class="flex items-center gap-2">
                                <button class="text-xs text-blue-600 hover:text-blue-800" data-relation-edit="${rel.id}">Edit</button>
                                <button class="text-xs text-red-500 hover:text-red-700" data-relation-delete="${rel.id}">Delete</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderRelationshipCards(relationships) {
            if (!relationships.length) return '<p class="text-sm text-gray-500 py-8 text-center">No relationships yet. Click "Add" to create one.</p>';
            return `
                <div class="space-y-3">
                    ${relationships.map(conn => {
                        const relation = findConnectionRelation(conn.relationId);
                        const mode = relation?.mode || conn.mode || 'relates to';
                        return `
                            <div class="border border-gray-200 rounded-lg p-4 bg-white hover:border-gray-300 transition-colors">
                                <div class="flex items-start justify-between gap-4">
                                    <div class="flex-1 min-w-0">
                                        <div class="flex items-center gap-2 flex-wrap">
                                            <span class="font-medium text-gray-900">${renderEntityLabel(conn.subject)}</span>
                                            <span class="text-gray-400"></span>
                                            <span class="text-sm text-blue-600 font-medium">${mode}</span>
                                            <span class="text-gray-400"></span>
                                            <span class="font-medium text-gray-900">${renderEntityLabel(conn.operand)}</span>
                                        </div>
                                        ${conn.description ? `<p class="text-sm text-gray-500 mt-1">${conn.description}</p>` : ''}
                                    </div>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <button class="text-sm text-blue-600 hover:text-blue-800" data-conn-edit="${conn.id}">Edit</button>
                                        <button class="text-sm text-red-500 hover:text-red-700" data-conn-delete="${conn.id}">Delete</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function renderRelationsPage(filterKey = 'all') {
            state.connectionFormState.activeFilter = filterKey;
            const filters = {
                all: () => true,
                con: conn => conn.operator === 'CON',
                seg: conn => conn.operator === 'SEG'
            };

            const relationTypes = getConnectionRelationView();
            const relationships = getConnectionView(filters[filterKey]);
            const container = document.getElementById('viewContainer');

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Relations</div>
                            <div class="view-stage-sub">${relationships.length} relationship${relationships.length !== 1 ? 's' : ''}</div>
                        </div>
                    </div>
                    <button class="btn btn-primary btn-sm" id="openRelationshipModalBtn">+ Add</button>
                </div>
                <div class="view-stage-body space-y-4">
                    ${Object.keys(filters).length > 1 ? `
                        <div class="flex flex-wrap gap-2">
                            ${Object.keys(filters).map(key => `<button class="btn btn-secondary btn-sm ${filterKey === key ? 'btn-primary' : ''}" data-conn-filter="${key}">${key === 'all' ? 'All' : key.toUpperCase()}</button>`).join('')}
                        </div>
                    ` : ''}

                    ${renderRelationshipCards(relationships)}

                    <details class="border border-gray-200 rounded-lg bg-white">
                        <summary class="px-4 py-3 cursor-pointer text-sm font-medium text-gray-700 hover:bg-gray-50">
                            Manage relation types (${relationTypes.length})
                        </summary>
                        <div class="px-4 pb-4 pt-2 border-t border-gray-100">
                            <div class="flex items-center justify-between mb-3">
                                <p class="text-xs text-gray-500">Define reusable relation types like "is linked to" or "filters by"</p>
                                <button class="btn btn-secondary btn-sm" id="openRelationTypeModalBtn">+ Add Type</button>
                            </div>
                            ${renderRelationTypesList(relationTypes)}
                        </div>
                    </details>
                </div>
            `;

            document.querySelectorAll('[data-conn-filter]').forEach(btn => {
                btn.onclick = () => renderRelationsPage(btn.dataset.connFilter);
            });

            document.querySelectorAll('[data-conn-edit]').forEach(btn => {
                btn.onclick = () => openConnectionModal(btn.dataset.connEdit);
            });

            document.querySelectorAll('[data-conn-delete]').forEach(btn => {
                btn.onclick = () => {
                    deleteConnection(btn.dataset.connDelete);
                    renderRelationsPage(filterKey);
                    showToast('Relationship removed');
                };
            });

            document.querySelectorAll('[data-relation-edit]').forEach(btn => {
                btn.onclick = () => openConnectionRelationModal(btn.dataset.relationEdit);
            });

            document.querySelectorAll('[data-relation-delete]').forEach(btn => {
                btn.onclick = () => {
                    try {
                        deleteConnectionRelation(btn.dataset.relationDelete);
                        renderRelationsPage(filterKey);
                        showToast('Relation type removed');
                    } catch (error) {
                        showToast(error.message);
                    }
                };
            });

            const openRelationshipBtn = document.getElementById('openRelationshipModalBtn');
            if (openRelationshipBtn) openRelationshipBtn.onclick = () => openConnectionModal();

            const openRelationTypeBtn = document.getElementById('openRelationTypeModalBtn');
            if (openRelationTypeBtn) openRelationTypeBtn.onclick = () => openConnectionRelationModal();

            const formatOperatorSelect = document.getElementById('connectionRelationOperator');
            if (formatOperatorSelect) {
                formatOperatorSelect.onchange = (event) => {
                    const nextModes = renderModeOptions(event.target.value);
                    const modeSelect = document.getElementById('connectionRelationMode');
                    if (modeSelect) modeSelect.innerHTML = nextModes;
                };
            }

            const connFormatSelect = document.getElementById('connectionRelationSelect');
            if (connFormatSelect) {
                connFormatSelect.onchange = (event) => {
                    state.connectionFormState.selectedRelationId = event.target.value;
                    renderConnectionParamFields('connectionParamFields', event.target.value, {});
                    updateConnectionRelationSummary(event.target.value);
                };
            }

            const connForm = document.getElementById('connectionForm');
            if (connForm) connForm.onsubmit = (event) => { event.preventDefault(); handleConnectionFormSubmit(); };

            const formatForm = document.getElementById('connectionRelationForm');
            if (formatForm) formatForm.onsubmit = (event) => { event.preventDefault(); handleConnectionRelationSubmit(); };
        }

        function renderVisualizationsPage() {
            const container = document.getElementById('viewContainer');
            const setsForWorld = getSetsForWorld();

            container.innerHTML = `
                <div class="view-stage-header">
                    <div class="view-stage-title">
                        <span class="view-stage-pill">${getWorld()?.name || 'World'}</span>
                        <div class="min-w-0">
                            <div class="view-stage-name">Visualizations</div>
                            <div class="view-stage-sub">Interactive charts and data insights</div>
                        </div>
                    </div>
                </div>
                <div class="view-stage-body space-y-6">
                    <div class="border border-gray-200 rounded-lg bg-white p-6 space-y-4">
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-semibold mb-2">Select Set</label>
                                <select id="vizSetSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                    <option value="">Choose a set...</option>
                                    ${setsForWorld.map(set => `<option value="${set.id}">${set.name}</option>`).join('')}
                                </select>
                            </div>
                            <div id="vizViewSelectContainer" class="hidden">
                                <label class="block text-sm font-semibold mb-2">Select View</label>
                                <select id="vizViewSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                                    <option value="">Choose a view...</option>
                                </select>
                            </div>
                            <div id="vizChartTypeContainer" class="hidden">
                                <label class="block text-sm font-semibold mb-2">Chart Type</label>
                                <div class="flex gap-2 flex-wrap">
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="bar">Bar Chart</button>
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="line">Line Chart</button>
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="pie">Pie Chart</button>
                                    <button class="btn btn-secondary btn-sm viz-chart-btn" data-chart-type="area">Area Chart</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="vizChartContainer" class="border border-gray-200 rounded-lg bg-white p-6">
                        <div class="text-center text-gray-500 py-12">
                            Select a set and view to visualize data
                        </div>
                    </div>
                </div>
            `;

            const setSelect = document.getElementById('vizSetSelect');
            const viewSelect = document.getElementById('vizViewSelect');
            const viewSelectContainer = document.getElementById('vizViewSelectContainer');
            const chartTypeContainer = document.getElementById('vizChartTypeContainer');

            if (setSelect) {
                setSelect.onchange = () => {
                    const setId = setSelect.value;
                    if (!setId) {
                        viewSelectContainer.classList.add('hidden');
                        chartTypeContainer.classList.add('hidden');
                        return;
                    }

                    const set = state.sets.get(setId);
                    if (set && set.views.size > 0) {
                        viewSelect.innerHTML = '<option value="">Choose a view...</option>' +
                            Array.from(set.views.values()).map(view =>
                                `<option value="${view.id}">${view.name}</option>`
                            ).join('');
                        viewSelectContainer.classList.remove('hidden');
                    }
                };
            }

            if (viewSelect) {
                viewSelect.onchange = () => {
                    if (viewSelect.value) {
                        chartTypeContainer.classList.remove('hidden');
                    } else {
                        chartTypeContainer.classList.add('hidden');
                    }
                };
            }

            document.querySelectorAll('.viz-chart-btn').forEach(btn => {
                btn.onclick = () => {
                    const chartType = btn.dataset.chartType;
                    const setId = setSelect.value;
                    const viewId = viewSelect.value;

                    if (setId && viewId) {
                        renderVisualizationChart(setId, viewId, chartType);
                    }
                };
            });
        }

        function renderVisualizationChart(setId, viewId, chartType) {
            const set = state.sets.get(setId);
            if (!set) return;

            const view = set.views.get(viewId);
            if (!view) return;

            // Get and filter records
            let records = Array.from(set.records.values());
            const schema = Array.from(set.fields.values());
            if (view && view.filters && view.filters.length > 0) {
                records = applyFilterGroups(records, view.filters, schema);
            }
            if (view?.sorts?.length) {
                records = applySorts(records, view.sorts, schema);
            }

            if (records.length === 0) {
                document.getElementById('vizChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">No data available to visualize</div>';
                return;
            }

            // Prepare data for charts
            const fields = Array.from(set.fields.values());
            const numericFields = fields.filter(f =>
                f.type === 'number' || f.type === 'currency' || f.type === 'percent'
            );

            // Use first text field as label, first numeric field as value
            const labelField = fields.find(f => f.type === 'text' || f.type === 'singleSelect');
            const valueField = numericFields[0];

            if (!labelField || !valueField) {
                document.getElementById('vizChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">View needs at least one text field and one numeric field for visualization</div>';
                return;
            }

            const chartData = records.slice(0, 10).map(record => ({
                name: String(record.data[labelField.id] || 'Untitled'),
                value: Number(record.data[valueField.id] || 0)
            }));

            const chartContainer = document.getElementById('vizChartContainer');
            chartContainer.innerHTML = '<div id="rechartRoot" style="width: 100%; height: 400px;"></div>';

            renderRechartsVisualization(chartType, chartData);
        }

        function renderRechartsVisualization(chartType, data) {
            const { BarChart, LineChart, PieChart, AreaChart, Bar, Line, Pie, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, Cell, ResponsiveContainer } = window.Recharts;
            const React = window.React;
            const ReactDOM = window.ReactDOM;

            const COLORS = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4', '#6366f1', '#f97316'];

            let chart;
            switch(chartType) {
                case 'bar':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(BarChart, { data },
                            React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                            React.createElement(XAxis, { dataKey: 'name' }),
                            React.createElement(YAxis, null),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null),
                            React.createElement(Bar, { dataKey: 'value', fill: '#3b82f6' })
                        )
                    );
                    break;
                case 'line':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(LineChart, { data },
                            React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                            React.createElement(XAxis, { dataKey: 'name' }),
                            React.createElement(YAxis, null),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null),
                            React.createElement(Line, { type: 'monotone', dataKey: 'value', stroke: '#3b82f6', strokeWidth: 2 })
                        )
                    );
                    break;
                case 'pie':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(PieChart, null,
                            React.createElement(Pie, {
                                data,
                                dataKey: 'value',
                                nameKey: 'name',
                                cx: '50%',
                                cy: '50%',
                                outerRadius: 120,
                                label: true
                            }, data.map((entry, index) =>
                                React.createElement(Cell, { key: `cell-${index}`, fill: COLORS[index % COLORS.length] })
                            )),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null)
                        )
                    );
                    break;
                case 'area':
                    chart = React.createElement(ResponsiveContainer, { width: '100%', height: 400 },
                        React.createElement(AreaChart, { data },
                            React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                            React.createElement(XAxis, { dataKey: 'name' }),
                            React.createElement(YAxis, null),
                            React.createElement(Tooltip, null),
                            React.createElement(Legend, null),
                            React.createElement(Area, { type: 'monotone', dataKey: 'value', stroke: '#3b82f6', fill: '#93c5fd' })
                        )
                    );
                    break;
            }

            const root = document.getElementById('rechartRoot');
            if (root && ReactDOM && React) {
                ReactDOM.render(chart, root);
            }
        }

        // NEW COMPONENT FUNCTIONS FOR DASHBOARD
        function createSummaryCard(title, count, onClick) {
            return `
                <div class="summary-card" onclick="${onClick}">
                    <div class="summary-card-count">${count}</div>
                    <div class="summary-card-title">${title}</div>
                </div>
            `;
        }

        function createEntityTypeCard(label, count, onClick) {
            return `
                <div class="entity-type-card" onclick="${onClick}">
                    <div class="entity-type-card-label">${label}</div>
                    <div class="entity-type-card-count">${count} items</div>
                </div>
            `;
        }

        function renderDashboardPage() {
            const container = document.getElementById('viewContainer');
            const world = getWorld();
            const setsForWorld = getSetsForWorld();

            // Calculate counts (filtered by current world)
            const entityCount = getEntityView().length;
            const connectionCount = getConnectionView().length;
            const definitionCount = getDefinitionView().length;

            let totalRecords = 0;
            let totalFields = 0;
            let totalViews = 0;

            setsForWorld.forEach(set => {
                totalRecords += set.records ? set.records.size : 0;
                totalFields += set.fields ? set.fields.size : 0;
                totalViews += set.views ? set.views.size : 0;
            });

            const setCount = setsForWorld.length;

            // Get recent changes from event stream (last 10)
            const recentChanges = (state.eventStream || []).slice(-10).reverse().map(event => {
                const timestamp = new Date(event.timestamp).toLocaleString();
                return `${timestamp} - ${event.type || 'Change'} - ${event.description || 'System update'}`;
            });

            container.innerHTML = `
                <div style="padding: 2rem; display: flex; flex-direction: column; gap: 2.5rem;">

                    <!-- HEADER -->
                    <div class="dashboard-header">
                        <h1>${world?.name || 'World'}</h1>
                        <div class="dashboard-actions">
                            <button class="btn btn-primary btn-sm" onclick="openCsvImportModal()">
                                <i class="ph ph-file-csv"></i>
                                Import CSV
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="document.getElementById('historyPanel').classList.add('open'); renderHistory();">
                                <i class="ph ph-clock-counter-clockwise"></i>
                                Global Changes
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="openJsonViewer()">
                                <i class="ph ph-code"></i>
                                View JSON
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="document.getElementById('worldJsonInput').click()">
                                <i class="ph ph-upload-simple"></i>
                                Import World
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="exportJSON()">
                                <i class="ph ph-download-simple"></i>
                                Download World
                            </button>
                        </div>
                    </div>

                    <!-- SUMMARY CARDS -->
                    <div class="summary-grid">
                        ${createSummaryCard('Entities', entityCount, "navigateTo('entities')")}
                        ${createSummaryCard('Relations', connectionCount, "navigateTo('relations')")}
                        ${createSummaryCard('Definitions', definitionCount, "navigateTo('definitions')")}
                        ${createSummaryCard('Views', totalViews, "navigateTo('views')")}
                    </div>

                    <!-- QUICK START -->
                    <div class="dashboard-section">
                        <h2>Quick Start</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem;">
                            <div class="dashboard-card" style="background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%); border: 1px solid #3b82f6; border-radius: 12px; padding: 1.5rem; cursor: pointer;" onclick="openCsvImportModal()">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.75rem;">
                                    <i class="ph ph-file-csv" style="font-size: 32px; color: #60a5fa;"></i>
                                    <div>
                                        <h3 style="margin: 0; font-size: 1.1rem; color: #f1f5f9;">Import Your Data</h3>
                                        <p style="margin: 0.25rem 0 0; font-size: 0.875rem; color: #94a3b8;">Upload a CSV file to get started</p>
                                    </div>
                                </div>
                            </div>
                            ${setsForWorld.length > 0 ? `
                            <div class="dashboard-card" style="background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%); border: 1px solid #10b981; border-radius: 12px; padding: 1.5rem; cursor: pointer;" onclick="switchSet('${setsForWorld[0].id}', Array.from(setsForWorld[0].views.keys())[0])">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.75rem;">
                                    <i class="ph ph-table" style="font-size: 32px; color: #34d399;"></i>
                                    <div>
                                        <h3 style="margin: 0; font-size: 1.1rem; color: #f1f5f9;">Explore Sample Data</h3>
                                        <p style="margin: 0.25rem 0 0; font-size: 0.875rem; color: #94a3b8;">View ${setsForWorld[0].name} (${setsForWorld[0].records.size} records)</p>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                            <div class="dashboard-card" style="background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%); border: 1px solid #8b5cf6; border-radius: 12px; padding: 1.5rem; cursor: pointer;" onclick="openAddSetModal()">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.75rem;">
                                    <i class="ph ph-plus-circle" style="font-size: 32px; color: #a78bfa;"></i>
                                    <div>
                                        <h3 style="margin: 0; font-size: 1.1rem; color: #f1f5f9;">Create New Set</h3>
                                        <p style="margin: 0.25rem 0 0; font-size: 0.875rem; color: #94a3b8;">Start with an empty data set</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- DATA SETS -->
                    ${setsForWorld.length > 0 ? `
                    <div class="dashboard-section">
                        <h2>Your Data Sets</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                            ${setsForWorld.map(set => `
                                <div class="dashboard-card" style="background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; cursor: pointer;" onclick="switchSet('${set.id}', Array.from(set.views.keys())[0])">
                                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                                        ${renderIcon(set.icon || 'ph-squares-four')}
                                        <div>
                                            <div style="font-weight: 600;">${set.name}</div>
                                            <div style="font-size: 0.75rem; color: var(--text-muted);">${set.records.size} records, ${set.schema.length} fields</div>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- ENTITY TYPES -->
                    <div class="dashboard-section">
                        <h2>Entity Types</h2>
                        <div class="entity-type-grid">
                            ${createEntityTypeCard('Sets', setCount, "navigateTo('entities', 'set')")}
                            ${createEntityTypeCard('Records', totalRecords, "navigateTo('entities', 'record')")}
                            ${createEntityTypeCard('Fields', totalFields, "navigateTo('entities', 'field')")}
                            ${createEntityTypeCard('Relationships', connectionCount, "navigateTo('relations')")}
                            ${createEntityTypeCard('Definitions', definitionCount, "navigateTo('definitions')")}
                            ${createEntityTypeCard('Views', totalViews, "navigateTo('views')")}
                        </div>
                    </div>

                    <!-- RECENT ACTIVITY -->
                    ${recentChanges.length > 0 ? `
                        <div class="dashboard-section">
                            <h2>Recent Changes</h2>
                            <ul class="recent-changes-list">
                                ${recentChanges.map(change => `<li>${change}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}

                </div>
            `;
        }

        function attachConnectionRelationInlineEditing() {
            document.querySelectorAll('[data-relation-inline]').forEach(cell => {
                const [field, relationId] = (cell.dataset.relationInline || '').split(':');
                if (!field || !relationId) return;
                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;
                    const updates = { [field]: current };

                    updateConnectionRelation(relationId, updates);
                    showToast('Relation type updated');
                    renderRelationsPage(state.connectionFormState.activeFilter || 'all');
                };
            });
        }

        function attachConnectionInlineEditing() {
            document.querySelectorAll('[data-conn-inline]').forEach(cell => {
                const [field, connId] = (cell.dataset.connInline || '').split(':');
                if (!field || !connId) return;
                const original = cell.textContent.trim();
                cell.contentEditable = 'true';
                cell.onfocus = () => cell.dataset.originalValue = cell.textContent.trim();
                cell.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        cell.blur();
                    }
                };
                cell.onblur = () => {
                    const current = (cell.textContent || '').trim();
                    const baseline = cell.dataset.originalValue !== undefined ? cell.dataset.originalValue : original;
                    if (current === baseline) return;

                    try {
                        if (field === 'params') {
                            const parsed = current ? JSON.parse(current) : {};
                            updateConnection(connId, { params: parsed });
                        } else {
                            updateConnection(connId, { [field]: current });
                        }
                        showToast('Relationship updated');
                        renderRelationsPage(state.connectionFormState.activeFilter || 'all');
                    } catch (error) {
                        showToast('Params must be valid JSON');
                        renderRelationsPage(state.connectionFormState.activeFilter || 'all');
                    }
                };
            });
        }

        // CELL EDITING
        function handleCellClick(td, recordId, field) {
            if (state.editingCell && state.editingCell.td !== td) {
                exitEditMode();
            }

            if (state.selectedCell?.td === td && state.selectedCell?.recordId === recordId) {
                enterEditMode(td, recordId, field);
                return;
            }

            selectCell(td, recordId, field.id);
        }

        function selectCell(td, recordId, fieldId) {
            if (state.editingCell) exitEditMode();

            if (state.selectedCell?.td) {
                state.selectedCell.td.classList.remove('cell-selected');
                state.selectedCell.td.tabIndex = -1;
            }

            td.classList.add('cell-selected');
            td.tabIndex = 0;
            td.focus();

            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };

            const set = getCurrentSet();
            const record = set?.records.get(recordId);
            const value = record ? record[fieldId] : null;
            if (value && value._sup) {
                openObservationModal({ recordId, fieldId, setId: set?.id });
            }
        }

        function enterEditMode(td, recordId, field) {
            exitEditMode(false);

            td.classList.remove('cell-selected');
            td.classList.add('cell-editing');
            state.editingCell = { td, recordId, fieldId: field.id };

            if (field.type === 'DATE') {
                showDatePicker(td, recordId, field);
            } else if (field.type === 'SELECT') {
                showSelectDropdown(td, recordId, field);
            } else if (field.type === 'LINK_RECORD') {
                showLinkedRecordDropdown(td, recordId, field);
            } else if (field.type === 'FORMULA' || field.type === 'RECORD_ID') {
                // Formula and Record ID fields are read-only, exit edit mode
                exitEditMode(false);
                return;
            } else {
                makeContentEditable(td, recordId, field);
            }
        }

        function exitEditMode(save = true) {
            if (!state.editingCell) return;

            const { td, recordId, fieldId } = state.editingCell;

            if (td.contentEditable === 'true') {
                td.contentEditable = false;
                if (save) {
                    finalizeContentEdit(td, recordId, fieldId);
                }
            }

            td.classList.remove('cell-editing');
            td.classList.add('cell-selected');
            td.tabIndex = 0;

            state.editingCell = null;
            state.selectedCell = { td, recordId, fieldId };
            state.lastSelectedCell = { recordId, fieldId };
        }

        function makeContentEditable(td, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            td.contentEditable = true;
            td.textContent = currentValue || '';
            td.focus();

            const range = document.createRange();
            range.selectNodeContents(td);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function finalizeContentEdit(td, recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const field = set.schema.find(f => f.id === fieldId);
            const currentValue = record[fieldId];

            let newValue = td.textContent.trim();
            if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                newValue = parseFloat(newValue) || 0;
            }

            if (String(newValue) !== String(currentValue)) {
                updateRecord(recordId, fieldId, newValue, currentValue);
            } else {
                renderCurrentView();
            }
        }

        function toggleCheckbox(recordId, fieldId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[fieldId];
            updateRecord(recordId, fieldId, !currentValue, currentValue);
        }

        function showDatePicker(cell, recordId, field) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            const input = document.createElement('input');
            input.type = 'date';
            input.value = currentValue || '';
            input.className = 'w-full px-2 py-1';
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.onblur = () => {
                exitEditMode(false);
                const newValue = input.value;
                if (newValue !== currentValue) updateRecord(recordId, field.id, newValue, currentValue);
                else renderCurrentView();
            };
        }

        function showSelectDropdown(td, recordId, field) {
            const options = field.config.options.map(opt => ({
                value: opt,
                label: opt,
                color: field.config.colors?.[opt] || '#f3f4f6',
                icon: ''
            }));

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function showEnhancedSelectDropdown(td, recordId, field, options) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const currentValue = record[field.id];

            document.querySelectorAll('.custom-select-dropdown').forEach(d => d.remove());

            const dropdown = document.createElement('div');
            dropdown.className = 'custom-select-dropdown';

            const rect = td.getBoundingClientRect();
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceAbove = rect.top;
            const dropdownHeight = Math.min(400, options.length * 40 + 100);

            if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
                dropdown.style.top = `${rect.bottom + 4}px`;
            } else {
                dropdown.style.bottom = `${window.innerHeight - rect.top + 4}px`;
            }
            dropdown.style.left = `${rect.left}px`;
            dropdown.style.minWidth = `${rect.width}px`;

            dropdown.innerHTML = `
                <input 
                    type="text" 
                    class="custom-select-search" 
                    placeholder="Search or type to filter..."
                    autocomplete="off"
                    spellcheck="false"
                >
                <div class="custom-select-options"></div>
                <div class="custom-select-footer">
                    <button class="clear-btn">Clear</button>
                </div>
            `;

            document.body.appendChild(dropdown);

            const searchInput = dropdown.querySelector('.custom-select-search');
            const optionsContainer = dropdown.querySelector('.custom-select-options');
            const clearBtn = dropdown.querySelector('.clear-btn');

            let highlightedIndex = -1;
            let filteredOptions = [...options];

            function updateHighlight() {
                optionsContainer.querySelectorAll('.custom-select-option').forEach((el, i) => {
                    el.classList.toggle('highlighted', i === highlightedIndex);
                });
            }

            function scrollToHighlighted() {
                const highlighted = optionsContainer.querySelector('.highlighted');
                if (highlighted) {
                    highlighted.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }

            function selectOption(value) {
                if (value !== currentValue) {
                    updateRecord(recordId, field.id, value, currentValue);
                }
                dropdown.remove();
                exitEditMode();
            }

            function renderOptions(query = '') {
                filteredOptions = query.trim() === ''
                    ? [...options]
                    : options.filter(opt => opt.label.toLowerCase().includes(query.toLowerCase()));

                if (filteredOptions.length === 0) {
                    optionsContainer.innerHTML = `
                        <div class="custom-select-empty">
                            <div class="custom-select-empty-icon"></div>
                            <div>No matches found</div>
                            <div style="font-size: 12px; margin-top: 4px;">Try a different search term</div>
                        </div>
                    `;
                    return;
                }

                optionsContainer.innerHTML = filteredOptions.map((opt, index) => {
                    const isSelected = opt.value === currentValue;
                    const isHighlighted = index === highlightedIndex;

                    let displayLabel = opt.label;
                    if (query.trim() !== '') {
                        const regex = new RegExp(`(${query})`, 'gi');
                        displayLabel = opt.label.replace(regex, '<span class="search-match">$1</span>');
                    }

                    return `
                        <div 
                            class="custom-select-option ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}"
                            data-value="${opt.value}"
                            data-index="${index}"
                        >
                            <div class="custom-select-option-icon" style="background: ${opt.color || '#f3f4f6'}">
                                ${opt.icon || ''}
                            </div>
                            <div class="custom-select-option-text">${displayLabel}</div>
                            ${isSelected ? '<span class="custom-select-option-badge">Current</span>' : ''}
                        </div>
                    `;
                }).join('');

                optionsContainer.querySelectorAll('.custom-select-option').forEach(el => {
                    el.onclick = () => selectOption(el.dataset.value);
                    el.onmouseenter = () => {
                        highlightedIndex = parseInt(el.dataset.index);
                        updateHighlight();
                    };
                });
            }

            searchInput.oninput = (e) => {
                highlightedIndex = 0;
                renderOptions(e.target.value);
            };

            searchInput.onkeydown = (e) => {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    highlightedIndex = Math.min(highlightedIndex + 1, filteredOptions.length - 1);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    highlightedIndex = Math.max(highlightedIndex - 1, 0);
                    updateHighlight();
                    scrollToHighlighted();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (highlightedIndex >= 0 && highlightedIndex < filteredOptions.length) {
                        selectOption(filteredOptions[highlightedIndex].value);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    dropdown.remove();
                    exitEditMode(false);
                }
            };

            clearBtn.onclick = () => {
                selectOption('');
            };

            setTimeout(() => {
                document.addEventListener('click', function closeDropdown(e) {
                    if (!dropdown.contains(e.target) && e.target !== td) {
                        dropdown.remove();
                        exitEditMode(false);
                        document.removeEventListener('click', closeDropdown);
                    }
                });
            }, 0);

            renderOptions();
            searchInput.focus();
        }

        function showLinkedRecordDropdown(td, recordId, field) {
            const linkedSet = getLinkedSet(field);
            if (!linkedSet) {
                showToast(' Configure linked set first');
                exitEditMode(false);
                return;
            }

            const options = Array.from(linkedSet.records.values()).map(rec => ({
                value: rec.id,
                label: getRecordDisplayName(rec.id) || linkedSet.name || 'Record',
                icon: '',
                color: '#e0f2fe'
            }));

            if (options.length === 0) {
                showToast(' No records in linked set');
                exitEditMode(false);
                return;
            }

            showEnhancedSelectDropdown(td, recordId, field, options);
        }

        function filterLinkedRecordSelect(selectId, query) {
            const select = document.getElementById(selectId);
            if (!select) return;

            const optionsData = select.dataset.options
                ? JSON.parse(decodeURIComponent(select.dataset.options))
                : [];
            const normalizedQuery = query.trim().toLowerCase();
            const filtered = optionsData.filter(opt => opt.label.toLowerCase().includes(normalizedQuery));
            const previousValue = select.value;

            select.innerHTML = '<option value="">Select a record</option>';

            if (filtered.length === 0) {
                const placeholder = document.createElement('option');
                placeholder.disabled = true;
                placeholder.textContent = 'No matches';
                select.appendChild(placeholder);
                select.value = '';
                select.disabled = true;
                return;
            }

            filtered.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.id;
                option.textContent = opt.label;
                select.appendChild(option);
            });

            const stillExists = filtered.some(opt => opt.id === previousValue);
            select.value = stillExists ? previousValue : '';
            select.disabled = false;
        }

      function updateRecord(recordId, fieldId, newValue, oldValue) {
          const set = getCurrentSet();
          const record = set.records.get(recordId);
          const field = set.schema.find(f => f.id === fieldId);
          record[fieldId] = newValue;
            createEvent(
                'Update Cell',
                'SEG',
                { type: 'Record', id: recordId, setId: set.id },
                {
                    fieldId: fieldId,
                    fieldName: field.name,
                    oldValue: oldValue,
                    newValue: newValue,
                    setId: set.id,
                    recordId: recordId,
                    summary: `Updated ${field.name}`
                }
            );
            renderCurrentView();
          showToast(` Updated ${field.name}`);
      }

        function buildDefaultConfigForType(type) {
            switch(type) {
                case 'SELECT':
                    return { options: [{ value: 'Option 1', color: 'blue' }], acceptNewOptions: true };
                case 'LINK_RECORD':
                    return { linkedSetId: state.currentSetId };
                default:
                    return null;
            }
        }

        function snapshotFieldValues(set, fieldId) {
            const values = new Map();
            set.records.forEach((record, recordId) => {
                values.set(recordId, record[fieldId]);
            });
            return values;
        }

        function restoreFieldValues(set, fieldId, values) {
            values.forEach((value, recordId) => {
                const record = set.records.get(recordId);
                if (record) record[fieldId] = value;
            });
        }

        function convertValueForType(value, fromType, toType, targetConfig = {}) {
            const defaults = FIELD_TYPES[toType]?.defaultValue;
            if (value === undefined || value === null) return defaults;

            switch(toType) {
                case 'TEXT':
                case 'LONG_TEXT':
                    return value === '' ? '' : String(value);
                case 'NUMBER':
                case 'CURRENCY': {
                    if (value === '') return 0;
                    if (value instanceof Date) return value.getTime();
                    if (typeof value === 'boolean') return value ? 1 : 0;
                    const cleaned = String(value).replace(/[$,]/g, '');
                    const parsed = Number(cleaned);
                    return Number.isNaN(parsed) ? 0 : parsed;
                }
                case 'DATE': {
                    if (value instanceof Date) return value;
                    if (typeof value === 'number') {
                        const date = new Date(value);
                        return Number.isNaN(date.getTime()) ? '' : date;
                    }
                    const parsed = new Date(value);
                    return Number.isNaN(parsed.getTime()) ? '' : parsed;
                }
                case 'EMAIL':
                case 'URL':
                case 'PHONE':
                    return String(value ?? '').trim();
                case 'CHECKBOX':
                    if (typeof value === 'string') {
                        return ['true', '1', 'yes', 'y', 'checked', 'on'].includes(value.trim().toLowerCase());
                    }
                    return Boolean(value);
                case 'SELECT': {
                    const str = String(value ?? '').trim();
                    if (!str) return '';
                    const options = targetConfig.options || [];
                    const acceptNewOptions = targetConfig.acceptNewOptions ?? true;
                    if (!options.some(opt => opt.value === str) && acceptNewOptions) {
                        options.push({ value: str, color: 'gray' });
                        targetConfig.options = options;
                    }
                    return str;
                }
                case 'LINK_RECORD':
                    return typeof value === 'string' ? value : '';
                default:
                    return value;
            }
        }

      // FIELD MANAGEMENT
      function resetFieldNameValidation() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          if (nameInput) {
              nameInput.classList.remove('input-error');
              nameInput.removeAttribute('aria-invalid');
          }
          if (nameError) {
              nameError.classList.add('hidden');
              nameError.textContent = '';
          }
      }

      function openAddFieldModal() {
          // Reset select options
          state.selectOptions = [{ value: 'Option 1', color: 'blue' }];

          // Generate auto-name for the field
          const set = getCurrentSet();
          let fieldNumber = 1;
          let autoName = `New Field ${fieldNumber}`;

          // Find the next available "New Field N" name
          if (set && set.schema) {
              while (set.schema.some(f => f.name === autoName)) {
                  fieldNumber++;
                  autoName = `New Field ${fieldNumber}`;
              }
          }

          // Set the auto-generated name
          const nameInput = document.getElementById('newFieldName');
          if (nameInput) {
              nameInput.value = autoName;
              // Select the text so user can easily replace it
              setTimeout(() => nameInput.select(), 100);
          }

          resetFieldNameValidation();

          // Reset field type to TEXT
          document.getElementById('newFieldType').value = 'TEXT';
          renderFieldTypeGrid('TEXT');
          closeFieldTypeDropdown();

          // Clear formula input
          const formulaInput = document.getElementById('formulaInput');
          if (formulaInput) formulaInput.value = '';

          // Reset formula format and decimals
          const formulaFormat = document.getElementById('formulaFormat');
          if (formulaFormat) formulaFormat.value = 'number';

          const formulaDecimals = document.getElementById('formulaDecimals');
          if (formulaDecimals) formulaDecimals.value = '2';

          // Update field config to show correct section
          updateFieldConfig('TEXT');

          // Populate link to set dropdown
          const linkSelect = document.getElementById('linkToSet');
          linkSelect.innerHTML = '';
          getSetsForWorld(state.currentWorldId).forEach(set => {
              const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
              linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
          });
          if (linkSelect.options.length === 0) {
              linkSelect.innerHTML = '<option value="">No sets available</option>';
              linkSelect.disabled = true;
          } else {
              linkSelect.disabled = false;
              const defaultValue = state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value;
              linkSelect.value = defaultValue;
          }

          openModal('addFieldModal');
      }

        function openLinkedFieldsModal() {
            const view = getCurrentView();
            const set = getCurrentSet();

            if (!view || !set) {
                showToast(' No active view or set');
                return;
            }

            // Check if EOLinkedFieldsModal is loaded
            if (!window.EOLinkedFieldsModal) {
                showToast(' Linked Fields Modal not loaded');
                console.error('EOLinkedFieldsModal class not found. Check if demo/eo_linked_fields_modal.js is loaded.');
                return;
            }

            // Create and show modal
            const modal = new window.EOLinkedFieldsModal();
            modal.show(view, set, state);
        }

        function renderFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('fieldTypeTrigger');
            const dropdown = document.getElementById('fieldTypeDropdown');
            const selectedName = document.getElementById('selectedFieldTypeName');
            const selectedDescription = document.getElementById('selectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function selectFieldType(typeId) {
            document.getElementById('newFieldType').value = typeId;
            renderFieldTypeGrid(typeId);
            updateFieldConfig(typeId);
            closeFieldTypeDropdown();
        }

        function renderChangeFieldTypeGrid(selectedType) {
            const trigger = document.getElementById('changeFieldTypeTrigger');
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const selectedName = document.getElementById('changeSelectedFieldTypeName');
            const selectedDescription = document.getElementById('changeSelectedFieldTypeDescription');

            if (!trigger || !dropdown) return;

            const fieldType = FIELD_TYPES[selectedType] || Object.values(FIELD_TYPES)[0];
            const iconTarget = trigger.querySelector('.field-type-trigger-icon');
            if (iconTarget) iconTarget.innerHTML = renderIcon(fieldType.icon);
            if (selectedName) selectedName.textContent = fieldType.name;
            if (selectedDescription) selectedDescription.textContent = fieldType.description || fieldType.id.replace(/_/g, ' ');

            dropdown.innerHTML = '';
            Object.values(FIELD_TYPES).forEach(optionType => {
                const option = document.createElement('div');
                option.className = `field-type-option ${optionType.id === selectedType ? 'selected' : ''}`;
                option.dataset.typeId = optionType.id;
                option.innerHTML = `
                    <div class="field-type-icon">${renderIcon(optionType.icon)}</div>
                    <div class="field-type-info">
                        <div class="field-type-name">${optionType.name}</div>
                        <div class="field-type-description">${optionType.description || optionType.id.replace(/_/g, ' ')}</div>
                    </div>
                    <span class="field-type-check">${optionType.id === selectedType ? '' : ''}</span>
                `;
                option.onclick = () => selectChangeFieldType(optionType.id);
                dropdown.appendChild(option);
            });
        }

        function describeFieldType(typeId) {
            return FIELD_TYPES[typeId]?.name || typeId || '';
        }

        function updateChangeFieldTypeSummary(selectedType) {
            const summary = document.getElementById('changeFieldTypeSummary');
            if (!summary) return;

            const originalType = state.changeFieldOriginalType;
            const currentLabel = describeFieldType(selectedType);

            if (!originalType) {
                summary.textContent = currentLabel ? `Type: ${currentLabel}` : '';
                return;
            }

            const originalLabel = describeFieldType(originalType);
            if (selectedType === originalType) {
                summary.textContent = `Type: ${originalLabel}`;
            } else {
                summary.textContent = `Type: ${originalLabel}  ${currentLabel}`;
            }
        }

        function selectChangeFieldType(typeId) {
            const input = document.getElementById('changeFieldTypeInput');
            if (input) input.value = typeId;
            renderChangeFieldTypeGrid(typeId);
            resetChangeFieldConfig(typeId);
            renderChangeFieldConfig(typeId);
            if (typeId === 'LINK_RECORD') {
                renderChangeLinkSelect();
            }
            updateChangeFieldTypeSummary(typeId);
            closeChangeFieldTypeDropdown();
        }

        function toggleFieldTypeDropdown() {
            if (state.fieldTypeDropdownOpen) {
                closeFieldTypeDropdown();
            } else {
                openFieldTypeDropdown();
            }
        }

        function toggleChangeFieldTypeDropdown() {
            if (state.changeFieldTypeDropdownOpen) {
                closeChangeFieldTypeDropdown();
            } else {
                openChangeFieldTypeDropdown();
            }
        }

        function openFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.fieldTypeDropdownOpen = true;
        }

        function openChangeFieldTypeDropdown() {
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const trigger = document.getElementById('changeFieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.remove('hidden');
            trigger.classList.add('active');
            state.changeFieldTypeDropdownOpen = true;
        }

        function closeFieldTypeDropdown() {
            const dropdown = document.getElementById('fieldTypeDropdown');
            const trigger = document.getElementById('fieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.fieldTypeDropdownOpen = false;
        }

        function closeChangeFieldTypeDropdown() {
            const dropdown = document.getElementById('changeFieldTypeDropdown');
            const trigger = document.getElementById('changeFieldTypeTrigger');
            if (!dropdown || !trigger) return;
            dropdown.classList.add('hidden');
            trigger.classList.remove('active');
            state.changeFieldTypeDropdownOpen = false;
        }

        function hasFieldHistory(setId, fieldId) {
            const key = `${setId}:${fieldId}`;
            const stack = state.fieldTypeHistory.get(key);
            return Array.isArray(stack) && stack.length > 0;
        }

        function buildChangeFieldConfig(typeId) {
            if (typeId === 'SELECT') {
                const acceptNewOptions = document.getElementById('changeAcceptNewOptions')?.checked ?? true;
                return {
                    options: state.changeSelectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.changeSelectOptions.map(o => [o.value, o.color])),
                    acceptNewOptions: acceptNewOptions
                };
            }
            if (typeId === 'LINK_RECORD') {
                return { linkedSetId: state.changeLinkedSetId || state.currentSetId };
            }
            if (typeId === 'LOOKUP') {
                return { lookupSetId: state.changeLinkedSetId || state.currentSetId };
            }
            if (typeId === 'FORMULA') {
                const formula = document.getElementById('changeFormulaInput').value.trim();
                const format = document.getElementById('changeFormulaFormat').value;
                const decimals = parseInt(document.getElementById('changeFormulaDecimals').value) || 2;
                return { formula, format, decimals };
            }
            return null;
        }

        function changeFieldType(fieldId, newType, newSubtype = null, newConfig = null) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);
            if (!field || !FIELD_TYPES[newType]) return;

            const previousType = field.type;
            const previousSubtype = field.subtype;
            const previousConfig = cloneConfig(field.config);
            const targetConfig = cloneConfig(newConfig ?? buildDefaultConfigForType(newType));
            const typeChanged = previousType !== newType;
            const subtypeChanged = previousSubtype !== newSubtype;
            const configChanged = JSON.stringify(previousConfig || null) !== JSON.stringify(targetConfig || null);

            if (!typeChanged && !subtypeChanged && !configChanged) return;

            const historyKey = `${set.id}:${fieldId}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            const historyEntry = {
                type: previousType,
                subtype: previousSubtype,
                config: cloneConfig(field.config)
            };
            if (typeChanged) {
                historyEntry.values = snapshotFieldValues(set, fieldId);
            }
            historyStack.push(historyEntry);
            state.fieldTypeHistory.set(historyKey, historyStack);

            if (typeChanged) {
                set.records.forEach((record, recordId) => {
                    const oldValue = record[fieldId];
                    record[fieldId] = convertValueForType(oldValue, previousType, newType, targetConfig || {});
                });
            }

            field.type = newType;
            field.subtype = newSubtype;
            field.config = targetConfig;

            createEvent(
                'Change Field Type',
                'SEG',
                { type: 'Field', id: fieldId, setId: set.id },
                { previousType, newType, fieldId, fieldName: field.name, setId: set.id, summary: typeChanged ? `Changed ${field.name} to ${FIELD_TYPES[newType].name}` : `Updated ${field.name}` }
            );

            renderCurrentView();
            showToast(typeChanged ? ` ${field.name} is now ${FIELD_TYPES[newType].name}` : ` ${field.name} updated`);
        }

        function saveChangeFieldType() {
            const context = state.changeFieldContext;
            const input = document.getElementById('changeFieldTypeInput');
            const subtypeSelect = document.getElementById('changeFieldSubtypeSelect');
            const newType = input?.value;
            const newSubtype = subtypeSelect?.value || null;
            if (!context || !newType) return;
            const newConfig = buildChangeFieldConfig(newType);
            changeFieldType(context.id, newType, newSubtype, newConfig);
            closeChangeFieldTypeModal();
        }

        function closeChangeFieldTypeModal() {
            state.changeFieldContext = null;
            state.changeFieldOriginalType = null;
            closeModal('changeFieldTypeModal');
        }

        function revertFieldType(fieldId) {
            const set = getCurrentSet();
            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const historyKey = `${set.id}:${fieldId}`;
            const historyStack = state.fieldTypeHistory.get(historyKey) || [];
            const last = historyStack.pop();

            if (!last) {
                showToast('No previous type to restore');
                return;
            }

            field.type = last.type;
            field.subtype = last.subtype;
            field.config = cloneConfig(last.config);
            if (last.values) {
                restoreFieldValues(set, fieldId, last.values);
            }
            if (historyStack.length === 0) {
                state.fieldTypeHistory.delete(historyKey);
            } else {
                state.fieldTypeHistory.set(historyKey, historyStack);
            }

            createEvent(
                'Revert Field Type',
                'SEG',
                { type: 'Field', id: fieldId, setId: set.id },
                { restoredType: last.type, fieldId, fieldName: field.name, setId: set.id, summary: `Reverted ${field.name} to ${FIELD_TYPES[last.type].name}` }
            );

            renderCurrentView();
            showToast(` ${field.name} restored to ${FIELD_TYPES[last.type].name}`);
        }

        function updateFieldConfig(typeId) {
            document.getElementById('selectConfig').classList.remove('visible');
            document.getElementById('linkToRecordConfig').classList.remove('visible');
            document.getElementById('formulaConfig').classList.remove('visible');
            if (typeId === 'SELECT') {
                document.getElementById('selectConfig').classList.add('visible');
                renderSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('linkToRecordConfig').classList.add('visible');
            } else if (typeId === 'FORMULA') {
                document.getElementById('formulaConfig').classList.add('visible');
                initFormulaAutocomplete();
            }
        }

        function renderChangeFieldConfig(typeId) {
            document.getElementById('changeSelectConfig').classList.remove('visible');
            document.getElementById('changeLinkToRecordConfig').classList.remove('visible');
            document.getElementById('changeFormulaConfig').classList.remove('visible');

            // Handle subtype selector
            const subtypeContainer = document.getElementById('changeFieldSubtypeConfig');
            if (subtypeContainer) {
                const fieldType = FIELD_TYPES[typeId];
                if (fieldType?.subtypes) {
                    const subtypeOptions = Object.values(fieldType.subtypes)
                        .map(st => `<option value="${st.id}">${st.name}</option>`)
                        .join('');
                    subtypeContainer.innerHTML = `
                        <div class="mb-4">
                            <label class="form-label">Field Subtype</label>
                            <select id="changeFieldSubtypeSelect" class="w-full">${subtypeOptions}</select>
                        </div>
                    `;
                    subtypeContainer.classList.add('visible');
                } else {
                    subtypeContainer.innerHTML = '';
                    subtypeContainer.classList.remove('visible');
                }
            }

            if (typeId === 'SELECT') {
                document.getElementById('changeSelectConfig').classList.add('visible');
                renderChangeSelectOptions();
            } else if (typeId === 'LINK_RECORD') {
                document.getElementById('changeLinkToRecordConfig').classList.add('visible');
            } else if (typeId === 'LOOKUP') {
                document.getElementById('changeLinkToRecordConfig').classList.add('visible');
                renderChangeLookupSelect();
            } else if (typeId === 'FORMULA') {
                document.getElementById('changeFormulaConfig').classList.add('visible');
                initChangeFormulaAutocomplete();
            }
        }

        function renderChangeLookupSelect() {
            const linkSelect = document.getElementById('changeLinkToSet');
            if (!linkSelect) return;

            linkSelect.innerHTML = '';
            getSetsForWorld(state.currentWorldId).forEach(set => {
                const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
                linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
            });

            if (linkSelect.options.length === 0) {
                linkSelect.innerHTML = '<option value="">No sets available</option>';
                linkSelect.disabled = true;
                state.changeLinkedSetId = '';
            } else {
                linkSelect.disabled = false;
                const defaultValue = state.changeLinkedSetId || (state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value);
                linkSelect.value = defaultValue;
                state.changeLinkedSetId = defaultValue;
            }
        }

        function renderChangeSelectOptions() {
            const container = document.getElementById('changeSelectOptionsList');
            container.innerHTML = state.changeSelectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="changeUpdateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}"
                                 onclick="changeUpdateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.changeSelectOptions.length > 1 ? `<button onclick="changeRemoveSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function changeAddSelectOption() {
            state.changeSelectOptions.push({ value: `Option ${state.changeSelectOptions.length + 1}`, color: 'blue' });
            renderChangeSelectOptions();
        }

        function changeUpdateSelectOption(index, value, color) {
            state.changeSelectOptions[index] = { value, color };
            renderChangeSelectOptions();
        }

        function changeRemoveSelectOption(index) {
            state.changeSelectOptions.splice(index, 1);
            renderChangeSelectOptions();
        }

        function resetChangeFieldConfig(typeId, field = null) {
            if (typeId === 'SELECT') {
                if (field?.config?.options) {
                    state.changeSelectOptions = field.config.options.map(opt => ({
                        value: typeof opt === 'string' ? opt : opt.value,
                        color: field.config.colors?.[typeof opt === 'string' ? opt : opt.value] || opt.color || 'blue'
                    }));
                } else {
                    state.changeSelectOptions = [{ value: 'Option 1', color: 'blue' }];
                }
                // Set the accept new options checkbox
                const acceptNewOptionsCheckbox = document.getElementById('changeAcceptNewOptions');
                if (acceptNewOptionsCheckbox) {
                    acceptNewOptionsCheckbox.checked = field?.config?.acceptNewOptions ?? true;
                }
            } else if (typeId === 'LINK_RECORD') {
                state.changeLinkedSetId = field?.config?.linkedSetId || state.currentSetId;
            } else if (typeId === 'FORMULA') {
                // Populate formula configuration from existing field
                const formulaInput = document.getElementById('changeFormulaInput');
                const formatSelect = document.getElementById('changeFormulaFormat');
                const decimalsInput = document.getElementById('changeFormulaDecimals');

                if (formulaInput) formulaInput.value = field?.config?.formula || '';
                if (formatSelect) formatSelect.value = field?.config?.format || 'number';
                if (decimalsInput) decimalsInput.value = field?.config?.decimals || 2;
            }
        }

        function renderChangeLinkSelect() {
            const linkSelect = document.getElementById('changeLinkToSet');
            if (!linkSelect) return;

            linkSelect.innerHTML = '';
            getSetsForWorld(state.currentWorldId).forEach(set => {
                const label = set.id === state.currentSetId ? `${set.name} (this set)` : set.name;
                linkSelect.innerHTML += `<option value="${set.id}">${label}</option>`;
            });

            if (linkSelect.options.length === 0) {
                linkSelect.innerHTML = '<option value="">No sets available</option>';
                linkSelect.disabled = true;
                state.changeLinkedSetId = '';
            } else {
                linkSelect.disabled = false;
                const defaultValue = state.changeLinkedSetId || (state.sets.has(state.currentSetId) ? state.currentSetId : linkSelect.options[0].value);
                linkSelect.value = defaultValue;
                state.changeLinkedSetId = defaultValue;
            }
        }

        function renderSelectOptions() {
            const container = document.getElementById('selectOptionsList');
            container.innerHTML = state.selectOptions.map((opt, i) => `
                <div class="option-row">
                    <input type="text" value="${opt.value}" onchange="updateSelectOption(${i}, this.value, '${opt.color}')" placeholder="Option ${i + 1}">
                    <div class="color-picker">
                        ${['blue', 'green', 'yellow', 'red', 'purple', 'gray'].map(c => `
                            <div class="color-option badge-${c} ${opt.color === c ? 'selected' : ''}" 
                                 onclick="updateSelectOption(${i}, '${opt.value}', '${c}')"></div>
                        `).join('')}
                    </div>
                    ${state.selectOptions.length > 1 ? `<button onclick="removeSelectOption(${i})" class="btn btn-secondary btn-sm"></button>` : ''}
                </div>
            `).join('');
        }

        function addSelectOption() {
            state.selectOptions.push({ value: `Option ${state.selectOptions.length + 1}`, color: 'blue' });
            renderSelectOptions();
        }

        function updateSelectOption(index, value, color) {
            state.selectOptions[index] = { value, color };
            renderSelectOptions();
        }

        function removeSelectOption(index) {
            state.selectOptions.splice(index, 1);
            renderSelectOptions();
        }

      function saveField() {
          const nameInput = document.getElementById('newFieldName');
          const nameError = document.getElementById('fieldNameError');
          const name = nameInput.value.trim();
          const type = document.getElementById('newFieldType').value;

          if (!name) {
              if (nameError) {
                  nameError.textContent = 'Please add a field name to continue.';
                  nameError.classList.remove('hidden');
              }
              nameInput.classList.add('input-error');
              nameInput.setAttribute('aria-invalid', 'true');
              nameInput.focus();
              return;
          }

          resetFieldNameValidation();

          const set = getCurrentSet();
          const fieldId = name.toLowerCase().replace(/[^a-z0-9]/g, '_');
            
            if (set.schema.find(f => f.id === fieldId)) {
                showConfirm('A field with this name already exists', () => {});
                return;
            }
            
            const subtype = document.getElementById('fieldManagerNewSubtype')?.value || null;
            const newField = { id: fieldId, name: name, type: type, subtype: subtype, width: '150px', config: {} };

            if (type === 'SELECT') {
                const acceptNewOptions = document.getElementById('acceptNewOptions')?.checked ?? true;
                newField.config = {
                    options: state.selectOptions.map(o => o.value),
                    colors: Object.fromEntries(state.selectOptions.map(o => [o.value, o.color])),
                    acceptNewOptions: acceptNewOptions
                };
            } else if (type === 'LINK_RECORD') {
                const linkedSetId = document.getElementById('linkToSet').value;
                if (!linkedSetId) { showConfirm('Select a set to link to', () => {}); return; }
                newField.config = { linkedSetId };
            } else if (type === 'FORMULA') {
                const formula = document.getElementById('formulaInput').value.trim();
                const format = document.getElementById('formulaFormat').value;
                const decimals = parseInt(document.getElementById('formulaDecimals').value) || 2;

                if (!formula) {
                    showConfirm('Please enter a formula', () => {});
                    return;
                }

                const validation = FormulaEngine.validateFormula(formula, set.schema);
                if (!validation.valid) {
                    showConfirm(`Formula error: ${validation.error}`, () => {});
                    return;
                }

                newField.config = { formula, format, decimals };
            }

            set.schema.push(newField);
            set.records.forEach(r => r[fieldId] = FIELD_TYPES[type].defaultValue);

            closeModal('addFieldModal');
            renderCurrentView();
            
            // Scroll to new field
            setTimeout(() => {
                const header = document.querySelector(`[data-field-id="${fieldId}"]`);
                if (header) {
                    header.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
                    header.style.animation = 'flash-yellow 0.5s ease-out';
                }
            }, 100);
            
            showToast(' Field added');
        }

        // FILTERING (simplified for space)
        function openFilterModal() {
            renderFilterBuilder();
            openModal('filterModal');
        }

        function renderFilterBuilder() {
            const view = getCurrentView();
            const container = document.getElementById('filterGroupsContainer');
            if (!view.filters || view.filters.length === 0) view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            container.innerHTML = view.filters.map((group, groupIndex) => `
                <div class="filter-group">
                    <div class="filter-group-header">
                        <div class="filter-operator-toggle">
                            <button class="${group.operator !== 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'AND')">AND</button>
                            <button class="${group.operator === 'OR' ? 'active' : ''}" onclick="setGroupOperator(${groupIndex}, 'OR')">OR</button>
                        </div>
                        <button onclick="removeFilterGroup(${groupIndex})" class="text-red-600 text-sm">Remove Group</button>
                    </div>
                    ${group.map((rule, ruleIndex) => renderFilterRule(groupIndex, ruleIndex, rule)).join('')}
                    <button onclick="addFilterRule(${groupIndex})" class="btn btn-secondary btn-sm mt-2">+ Add Rule</button>
                </div>
            `).join('');
        }

        function renderFilterRule(groupIndex, ruleIndex, rule) {
            const schema = getCurrentSet().schema;
            return `
                <div class="filter-rule">
                    <select onchange="updateFilterField(${groupIndex}, ${ruleIndex}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === rule.field ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select><option>equals</option></select>
                    <input type="text" value="${rule.value || ''}" onchange="updateFilterValue(${groupIndex}, ${ruleIndex}, this.value)">
                    <button onclick="removeFilterRule(${groupIndex}, ${ruleIndex})" class="text-red-600"></button>
                </div>
            `;
        }

        function applyFilterGroups(records, filterGroups, schema) {
            return records.filter(record => {
                return filterGroups.some(group => {
                    const operator = group.operator || 'AND';
                    const rules = group.filter(r => r.field);
                    if (operator === 'AND') return rules.every(rule => record[rule.field] === rule.value);
                    else return rules.some(rule => record[rule.field] === rule.value);
                });
            });
        }

        function getSortableValue(value, field) {
            if (value === undefined || value === null) return '';
            switch(field?.type) {
                case 'NUMBER':
                case 'CURRENCY':
                    return Number(value) || 0;
                case 'DATE':
                    return new Date(value).getTime() || 0;
                case 'CHECKBOX':
                    return value ? 1 : 0;
                default:
                    return String(value).toLowerCase();
            }
        }

        function applySorts(records, sorts, schema) {
            if (!sorts || sorts.length === 0) return records;
            const schemaMap = new Map(schema.map(f => [f.id, f]));
            const activeSorts = sorts.filter(sort => schemaMap.has(sort.fieldId));
            if (activeSorts.length === 0) return records;

            return [...records].sort((a, b) => {
                for (const sort of activeSorts) {
                    const field = schemaMap.get(sort.fieldId);
                    const aVal = getSortableValue(a[sort.fieldId], field);
                    const bVal = getSortableValue(b[sort.fieldId], field);

                    if (aVal < bVal) return sort.direction === 'desc' ? 1 : -1;
                    if (aVal > bVal) return sort.direction === 'desc' ? -1 : 1;
                }
                return 0;
            });
        }

        function toggleColumnSort(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            const existingIndex = view.sorts.findIndex(s => s.fieldId === fieldId);
            if (existingIndex === -1) {
                view.sorts.unshift({ fieldId, direction: 'asc' });
            } else if (view.sorts[existingIndex].direction === 'asc') {
                view.sorts[existingIndex].direction = 'desc';
            } else {
                view.sorts.splice(existingIndex, 1);
            }

            renderCurrentView();
        }

        function openSortModal() {
            const view = getCurrentView();
            if (!view) return;

            ensureViewDefaults(view);
            renderSortBuilder();
            openModal('sortModal');
        }

        function renderSortBuilder() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const container = document.getElementById('sortRulesContainer');
            const schema = set.schema;

            if (!view.sorts || view.sorts.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500">No sorts configured. Add a field to start sorting.</p>';
                return;
            }

            container.innerHTML = view.sorts.map((sort, index) => `
                <div class="flex items-center gap-3 p-3 rounded-lg border border-gray-200 bg-gray-50">
                    <div class="text-xs font-semibold text-gray-500">#${index + 1}</div>
                    <select class="flex-1" onchange="updateSortField(${index}, this.value)">
                        <option value="">Select field...</option>
                        ${schema.map(f => `<option value="${f.id}" ${f.id === sort.fieldId ? 'selected' : ''}>${f.name}</option>`).join('')}
                    </select>
                    <select onchange="updateSortDirection(${index}, this.value)">
                        <option value="asc" ${sort.direction === 'asc' ? 'selected' : ''}>Ascending</option>
                        <option value="desc" ${sort.direction === 'desc' ? 'selected' : ''}>Descending</option>
                    </select>
                    <div class="flex items-center gap-1">
                        <button class="btn btn-secondary btn-sm" onclick="moveSort(${index}, -1)" ${index === 0 ? 'disabled' : ''}></button>
                        <button class="btn btn-secondary btn-sm" onclick="moveSort(${index}, 1)" ${index === view.sorts.length - 1 ? 'disabled' : ''}></button>
                        <button class="btn btn-danger btn-sm" onclick="removeSortRule(${index})"></button>
                    </div>
                </div>
            `).join('');
        }

        function addSortRule() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const defaultField = set.schema[0]?.id || '';
            view.sorts.push({ fieldId: defaultField, direction: 'asc' });
            renderSortBuilder();
        }

        function updateSortField(index, fieldId) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].fieldId = fieldId;
            renderSortBuilder();
        }

        function updateSortDirection(index, direction) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts[index].direction = direction;
            renderSortBuilder();
        }

        function moveSort(index, delta) {
            const view = getCurrentView();
            if (!view) return;
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= view.sorts.length) return;
            const [item] = view.sorts.splice(index, 1);
            view.sorts.splice(newIndex, 0, item);
            renderSortBuilder();
        }

        function removeSortRule(index) {
            const view = getCurrentView();
            if (!view) return;
            view.sorts.splice(index, 1);
            renderSortBuilder();
        }

        function clearSorts() {
            const view = getCurrentView();
            if (!view) return;
            view.sorts = [];
            renderSortBuilder();
            renderCurrentView();
        }

        function applySortsFromModal() {
            closeModal('sortModal');
            renderCurrentView();
        }

        function setGroupOperator(groupIndex, operator) {
            const view = getCurrentView();
            view.filters[groupIndex].operator = operator;
            renderFilterBuilder();
        }

        function addFilterRule(groupIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].push({ field: '', operator: 'equals', value: '' });
            renderFilterBuilder();
        }

        function removeFilterRule(groupIndex, ruleIndex) {
            const view = getCurrentView();
            view.filters[groupIndex].splice(ruleIndex, 1);
            if (view.filters[groupIndex].length === 0) view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function addFilterGroup() {
            const view = getCurrentView();
            view.filters.push([{ field: '', operator: 'equals', value: '' }]);
            renderFilterBuilder();
        }

        function removeFilterGroup(groupIndex) {
            const view = getCurrentView();
            view.filters.splice(groupIndex, 1);
            renderFilterBuilder();
        }

        function updateFilterField(groupIndex, ruleIndex, fieldId) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].field = fieldId;
            renderFilterBuilder();
        }

        function updateFilterValue(groupIndex, ruleIndex, value) {
            const view = getCurrentView();
            view.filters[groupIndex][ruleIndex].value = value;
        }

        function applyFilters() {
            closeModal('filterModal');
            renderCurrentView();
            showToast(' Filters applied');
        }

        function clearFilters() {
            const view = getCurrentView();
            view.filters = [[{ field: '', operator: 'equals', value: '' }]];
            renderFilterBuilder();
        }

        // VISUALIZATION
        function openVisualizationModal() {
            openModal('visualizationModal');
            setupVisualizationModal();
        }

        function setupVisualizationModal() {
            const closeBtn = document.getElementById('closeVisualizationBtn');
            const closeModalBtn = document.getElementById('closeVisualizationModalBtn');

            if (closeBtn) {
                closeBtn.onclick = () => closeModal('visualizationModal');
            }
            if (closeModalBtn) {
                closeModalBtn.onclick = () => closeModal('visualizationModal');
            }

            // Setup chart type buttons
            document.querySelectorAll('.viz-chart-type-btn').forEach(btn => {
                btn.onclick = () => {
                    const chartType = btn.dataset.chartType;
                    renderCurrentViewChart(chartType);
                };
            });
        }

        function renderCurrentViewChart(chartType) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            // Get and filter records using the same logic as the current view
            let records = Array.from(set.records.values());
            const schema = Array.from(set.fields.values());

            if (view && view.filters && view.filters.length > 0) {
                records = applyFilterGroups(records, view.filters, schema);
            }
            if (view?.sorts?.length) {
                records = applySorts(records, view.sorts, schema);
            }

            if (records.length === 0) {
                document.getElementById('visualizationChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">No data available to visualize</div>';
                return;
            }

            // Prepare data for charts
            const fields = Array.from(set.fields.values());
            const numericFields = fields.filter(f =>
                f.type === 'number' || f.type === 'currency' || f.type === 'percent'
            );

            // Use first text field as label, first numeric field as value
            const labelField = fields.find(f => f.type === 'text' || f.type === 'singleSelect');
            const valueField = numericFields[0];

            if (!labelField || !valueField) {
                document.getElementById('visualizationChartContainer').innerHTML =
                    '<div class="text-center text-gray-500 py-12">View needs at least one text field and one numeric field for visualization</div>';
                return;
            }

            const chartData = records.slice(0, 20).map(record => ({
                name: String(record.data[labelField.id] || 'Untitled'),
                value: Number(record.data[valueField.id] || 0)
            }));

            const chartContainer = document.getElementById('visualizationChartContainer');
            chartContainer.innerHTML = '<div style="position: relative; height: 400px; width: 100%;"><canvas id="vizModalChartCanvas"></canvas></div>';

            renderChartJsVisualizationInModal(chartType, chartData);
        }

        // Store the current chart instance so we can destroy it before creating a new one
        let currentModalChart = null;

        function renderChartJsVisualizationInModal(chartType, data) {
            if (!window.Chart) {
                console.error('Chart.js library not loaded');
                document.getElementById('visualizationChartContainer').innerHTML =
                    '<div class="text-center text-red-500 py-12">Chart library failed to load. Please refresh the page.</div>';
                return;
            }

            // Destroy previous chart if it exists
            if (currentModalChart) {
                currentModalChart.destroy();
                currentModalChart = null;
            }

            const canvas = document.getElementById('vizModalChartCanvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }

            const COLORS = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4', '#6366f1', '#f97316'];

            const labels = data.map(item => item.name);
            const values = data.map(item => item.value);
            const backgroundColors = data.map((_, index) => COLORS[index % COLORS.length]);

            let chartConfig;

            switch(chartType) {
                case 'bar':
                    chartConfig = {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: values,
                                backgroundColor: '#3b82f6',
                                borderColor: '#2563eb',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    };
                    break;
                case 'line':
                    chartConfig = {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: values,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    };
                    break;
                case 'pie':
                    chartConfig = {
                        type: 'pie',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: values,
                                backgroundColor: backgroundColors,
                                borderColor: '#ffffff',
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'right'
                                }
                            }
                        }
                    };
                    break;
                case 'area':
                    chartConfig = {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Value',
                                data: values,
                                borderColor: '#1e40af',
                                backgroundColor: 'rgba(59, 130, 246, 0.5)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    };
                    break;
                default:
                    document.getElementById('visualizationChartContainer').innerHTML =
                        '<div class="text-center text-gray-500 py-12">Unknown chart type</div>';
                    return;
            }

            currentModalChart = new Chart(canvas, chartConfig);
        }

        // EXPANDED RECORD
        function openExpandedRecord(recordId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            state.currentRecordTab = 'provenance';
            state.recordHistoryVisible = true;
            document.getElementById('expandedRecordTitle').textContent = getRecordDisplayName(record.id) || set.name || 'Record';
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
            openModal('expandedRecordModal');
        }

        function openCellHistory(recordId, fieldId) {
            openObservationModal({ recordId, fieldId, setId: getCurrentSet()?.id });
        }

        function openObservationModal({ recordId = null, fieldId = null, setId = null, keyValue = null, field = null, items = [] }) {
            const modal = document.getElementById('cellHistoryModal');
            const targetSet = setId ? state.sets.get(setId) : getCurrentSet();
            const record = recordId ? targetSet?.records.get(recordId) : null;
            const schemaField = field || targetSet?.schema?.find(f => f.id === fieldId) || { id: fieldId, name: fieldId, type: 'TEXT' };

            const entries = state.eventStream
                .filter(e => e.op === 'SEG' && e.data?.fieldId === schemaField.id && (!recordId || e.data?.recordId === recordId))
                .sort((a, b) => new Date(a.published) - new Date(b.published));

            const supValues = [];
            const latestValue = record ? record[schemaField.id] : null;
            if (latestValue && latestValue._sup && Array.isArray(latestValue.value)) supValues.push(...latestValue.value);
            if (items.length > 0 && schemaField) {
                items.forEach(item => {
                    const candidate = item.record[schemaField.sourceFieldId || schemaField.id];
                    if (candidate && candidate._sup && Array.isArray(candidate.value)) supValues.push(...candidate.value);
                });
            }

            state.cellHistoryContext = {
                recordId,
                fieldId: schemaField.id,
                fieldName: schemaField.name || schemaField.id,
                recordName: record?.name || keyValue || recordId || 'Item',
                entries,
                index: entries.length > 0 ? entries.length - 1 : 0,
                selectedValueSource: 'new',
                supValues,
                latestValue,
                fieldType: schemaField.type,
                sourceSetName: targetSet?.name
            };

            renderCellHistoryModal();
            if (modal?.classList.contains('hidden')) openModal('cellHistoryModal');
        }

        function renderCellHistoryModal() {
            const container = document.getElementById('cellHistoryContent');
            const title = document.getElementById('cellHistoryTitle');
            const subtitle = document.getElementById('cellHistorySubtitle');
            const ctx = state.cellHistoryContext;

            if (!ctx) return;
            ctx.activePanel = ctx.activePanel || 'latest';

            title.textContent = `${ctx.fieldName} observations`;
            subtitle.textContent = ctx.recordName ? `Item: ${ctx.recordName}` : 'Multiple items';

            const supList = (ctx.supValues || []).map((entry, index) => `
                <div class="sup-modal-card">
                    <div class="flex items-start justify-between">
                        <div class="flex items-start gap-3">
                            <div class="sup-modal-card-index">${index + 1}</div>
                            <div class="flex-1">
                                <div class="sup-modal-card-value">${entry.val ?? ''}</div>
                                <div class="sup-modal-card-source">
                                    <svg class="w-3 h-3 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    ${entry.context?.source || 'observation'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
            const timeline = ctx.entries.map((entry, i) => `
                <div class="border rounded-lg p-3 ${i === ctx.index ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'}" onclick="selectCellHistoryEntry(${i})">
                    <div class="flex items-center justify-between">
                        <div class="font-medium">${entry.data?.fieldName || ctx.fieldName}</div>
                        <div class="text-xs text-gray-500">${new Date(entry.published).toLocaleString()}</div>
                    </div>
                    <div class="text-sm text-gray-600 mt-1">${entry.data?.summary || 'Updated value'}</div>
                    <div class="text-sm mt-2 flex items-center gap-2">
                        <span class="text-red-600">${entry.data?.oldValue ?? ''}</span>
                        <span></span>
                        <span class="text-green-600">${entry.data?.newValue ?? ''}</span>
                    </div>
                </div>
            `).join('');

            const activeEntry = ctx.entries[ctx.index] || {};
            const selectedValue = ctx.selectedValueSource === 'old'
                ? activeEntry.data?.oldValue
                : activeEntry.data?.newValue;
            const latestValue = ctx.latestValue ?? selectedValue;

            container.innerHTML = `
                <div class="flex items-center gap-2 mb-4">
                    ${['latest','observations','timeline','connections'].map(tab => `<button class="btn btn-secondary btn-sm ${ctx.activePanel === tab ? 'bg-gray-200' : ''}" onclick="setObservationPanel('${tab}')">${tab === 'latest' ? ' Latest Value' : tab === 'observations' ? ' Observations' : tab === 'timeline' ? ' Timeline' : ' Relations'}</button>`).join('')}
                </div>
                <div class="space-y-4">
                    ${ctx.activePanel === 'latest' ? `<div class="text-lg font-semibold">${renderCellValue(latestValue, { type: ctx.fieldType || 'TEXT' }, {}) || ''}</div>` : ''}
                    ${ctx.activePanel === 'observations' ? `
                        <div>
                            ${supList ? `
                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
                                    <div class="flex items-center gap-2">
                                        <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                                        </svg>
                                        <div class="flex-1">
                                            <div class="font-semibold text-blue-900 text-sm">Multiple Records in This Cell</div>
                                            <div class="text-xs text-blue-700">This cell contains ${ctx.supValues?.length || 0} aggregated record${(ctx.supValues?.length || 0) === 1 ? '' : 's'} from rollup</div>
                                        </div>
                                    </div>
                                </div>
                                ${supList}
                            ` : '<p class="text-gray-500">No multiple observations yet.</p>'}
                        </div>
                    ` : ''}
                    ${ctx.activePanel === 'timeline' ? `<div class="flex items-center justify-between mb-2"><div class="text-sm text-gray-600">${ctx.entries.length} change${ctx.entries.length === 1 ? '' : 's'} found</div><div class="flex items-center gap-2"><button class="btn btn-secondary btn-sm" ${ctx.index === 0 ? 'disabled' : ''} onclick="stepCellHistory(-1)"> Prev</button><button class="btn btn-secondary btn-sm" ${ctx.index >= ctx.entries.length - 1 ? 'disabled' : ''} onclick="stepCellHistory(1)">Next </button></div></div><div class="space-y-3">${timeline}</div>` : ''}
                    ${ctx.activePanel === 'connections' ? `<div class="text-sm text-gray-600">Source Set: ${ctx.sourceSetName || 'Unknown'}</div>` : ''}
                </div>
            `;
        }

        function setObservationPanel(panel) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.activePanel = panel;
            renderCellHistoryModal();
        }

        function selectCellHistoryEntry(index) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.index = index;
            renderCellHistoryModal();
        }

        function stepCellHistory(direction) {
            if (!state.cellHistoryContext || state.cellHistoryContext.entries.length === 0) return;
            const newIndex = Math.min(Math.max(state.cellHistoryContext.index + direction, 0), state.cellHistoryContext.entries.length - 1);
            state.cellHistoryContext.index = newIndex;
            renderCellHistoryModal();
        }

        function chooseHistoryValue(source) {
            if (!state.cellHistoryContext) return;
            state.cellHistoryContext.selectedValueSource = source;
            renderCellHistoryModal();
        }

        function applySelectedHistoricalValue() {
            const ctx = state.cellHistoryContext;
            if (!ctx || ctx.entries.length === 0) return;

            const entry = ctx.entries[ctx.index];
            const selectedValue = ctx.selectedValueSource === 'old'
                ? entry.data?.oldValue
                : entry.data?.newValue;

            const set = getCurrentSet();
            const record = set.records.get(ctx.recordId);
            const currentValue = record ? record[ctx.fieldId] : undefined;

            updateRecord(ctx.recordId, ctx.fieldId, selectedValue, currentValue);

            if (!document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(ctx.recordId);
                renderRecordSidebar(ctx.recordId);
            }

            openCellHistory(ctx.recordId, ctx.fieldId);
        }

        function ensurePopupRule(fieldId) {
            const view = getCurrentView();
            if (!view) return null;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            let rule = view.popupVisibilityRules.find(r => r.fieldId === fieldId);
            if (!rule) {
                rule = { fieldId, visibility: 'show', criteria: { type: 'always', value: '' } };
                view.popupVisibilityRules.push(rule);
            }
            return rule;
        }

        function evaluatePopupCriteria(criteria, value) {
            if (!criteria || criteria.type === 'always') return true;

            switch (criteria.type) {
                case 'equals':
                    return String(value ?? '').toLowerCase() === String(criteria.value ?? '').toLowerCase();
                case 'notEquals':
                    return String(value ?? '').toLowerCase() !== String(criteria.value ?? '').toLowerCase();
                case 'contains':
                    return String(value ?? '').toLowerCase().includes(String(criteria.value ?? '').toLowerCase());
                case 'empty':
                    return value === undefined || value === null || value === '';
                case 'notEmpty':
                    return !(value === undefined || value === null || value === '');
                default:
                    return true;
            }
        }

        function refreshOpenRecordModal() {
            const container = document.getElementById('expandedRecordMain');
            const recordId = container?.dataset?.recordId;
            if (recordId && !document.getElementById('expandedRecordModal').classList.contains('hidden')) {
                renderExpandedRecordMain(recordId);
            }
        }

        function shouldDisplayFieldInPopup(field, record) {
            const view = getCurrentView();
            if (!view) return true;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
            if (!rule) return true;

            const criteriaMet = evaluatePopupCriteria(rule.criteria, record[field.id]);
            if (!rule.criteria || criteriaMet) {
                return rule.visibility !== 'hide';
            }

            return true;
        }

        function renderExpandedRecordMain(recordId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            const record = set.records.get(recordId);
            const container = document.getElementById('expandedRecordMain');
            container.dataset.recordId = recordId;

            const orderedFields = view ? getPopupOrderedFields(set, view) : set.schema;
            const visibleFields = orderedFields.filter(field => shouldDisplayFieldInPopup(field, record));

            container.innerHTML = visibleFields.length === 0
                ? '<p class="text-gray-500">No fields are visible in this modal based on the current view settings.</p>'
                : `
                <div class="space-y-4">
                    ${visibleFields.map(field => `
                        <div class="field-editor">
                            <label class="form-label cursor-pointer hover:text-blue-600 transition flex items-center gap-2" onclick="openCellHistory('${recordId}', '${field.id}')" title="Click to view field provenance">
                                ${field.name}
                                <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </label>
                            ${renderFieldEditor(recordId, field, record[field.id])}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderFieldEditor(recordId, field, value) {
            // Get effective type and subtype (handle legacy fields)
            let effectiveType = field.type;
            let effectiveSubtype = field.subtype;

            // Map legacy types to new structure
            if (field.type === 'LONG_TEXT') {
                effectiveType = 'TEXT';
                effectiveSubtype = 'LONG';
            } else if (field.type === 'EMAIL' || field.type === 'URL' || field.type === 'PHONE') {
                effectiveType = 'CONTACT';
                effectiveSubtype = field.type;
            } else if (field.type === 'CURRENCY') {
                effectiveType = 'NUMBER';
                effectiveSubtype = 'CURRENCY';
            }

            // Handle TEXT with subtypes
            if (effectiveType === 'TEXT') {
                const subtype = effectiveSubtype || 'SHORT';
                if (subtype === 'RICH') {
                    return `<textarea rows="6" class="w-full" onchange="updateRecordField('${recordId}', '${field.id}', this.value)" placeholder="Use markdown: **bold**, *italic*, [link](url), # headers">${value || ''}</textarea>`;
                } else if (subtype === 'LONG') {
                    return `<textarea rows="4" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">${value || ''}</textarea>`;
                } else {
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                }
            }

            // Handle NUMBER with subtypes
            if (effectiveType === 'NUMBER') {
                return `<input type="number" value="${value || 0}" onchange="updateRecordField('${recordId}', '${field.id}', parseFloat(this.value))">`;
            }

            // Handle CONTACT with subtypes
            if (effectiveType === 'CONTACT') {
                const subtype = effectiveSubtype || 'EMAIL';
                const inputType = subtype === 'EMAIL' ? 'email' : subtype === 'URL' ? 'url' : 'tel';
                const placeholder = subtype === 'EMAIL' ? 'email@example.com' : subtype === 'URL' ? 'https://example.com' : '+1234567890';
                return `<input type="${inputType}" value="${value || ''}" placeholder="${placeholder}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
            }

            switch(effectiveType) {
                case 'DATE':
                    return `<input type="date" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
                case 'CHECKBOX':
                    return `<input type="checkbox" ${value ? 'checked' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.checked)">`;
                case 'LINK_RECORD': {
                    const linkedSet = getLinkedSet(field);
                    const options = createLinkedRecordOptionList(field);
                    const disableSelect = !linkedSet || options.length === 0;
                    const selectId = `linked-record-select-${recordId}-${field.id}`;
                    const optionsDataAttr = encodeURIComponent(JSON.stringify(options));
                    const hint = !linkedSet
                        ? '<p class="text-xs text-gray-500 mt-1">Configure a linked set to enable selection.</p>'
                        : options.length === 0
                            ? '<p class="text-xs text-gray-500 mt-1">Add records to the linked set to select one.</p>'
                            : '';

                    return `
                        <div class="space-y-1">
                            <input type="text" class="border rounded px-3 py-2 text-sm w-full" placeholder="Search linked records..." ${!linkedSet ? 'disabled' : ''} oninput="filterLinkedRecordSelect('${selectId}', this.value)">
                            <select id="${selectId}" class="border rounded px-3 py-2 text-sm w-full" data-options="${optionsDataAttr}" ${disableSelect ? 'disabled' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                                <option value="">Select a record</option>
                                ${options.map(opt => `<option value="${opt.id}" ${opt.id === value ? 'selected' : ''}>${opt.label}</option>`).join('')}
                            </select>
                            ${hint}
                        </div>
                    `;
                }
                case 'LOOKUP': {
                    const lookupSet = field.config?.lookupSetId ? state.sets.get(field.config.lookupSetId) : null;
                    const options = lookupSet ? Array.from(lookupSet.records.values()).map(rec => ({
                        id: rec.id,
                        label: getRecordDisplayName(rec.id) || lookupSet.name || 'Record'
                    })) : [];
                    const disableSelect = !lookupSet || options.length === 0;
                    const selectId = `lookup-select-${recordId}-${field.id}`;
                    const optionsDataAttr = encodeURIComponent(JSON.stringify(options));
                    const hint = !lookupSet
                        ? '<p class="text-xs text-gray-500 mt-1">Configure a lookup set to enable selection.</p>'
                        : options.length === 0
                            ? '<p class="text-xs text-gray-500 mt-1">Add records to the lookup set to select one.</p>'
                            : '';

                    return `
                        <div class="space-y-1">
                            <input type="text" class="border rounded px-3 py-2 text-sm w-full" placeholder="Search records..." ${!lookupSet ? 'disabled' : ''} oninput="filterLinkedRecordSelect('${selectId}', this.value)">
                            <select id="${selectId}" class="border rounded px-3 py-2 text-sm w-full" data-options="${optionsDataAttr}" ${disableSelect ? 'disabled' : ''} onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                                <option value="">Select a record</option>
                                ${options.map(opt => `<option value="${opt.id}" ${opt.id === value ? 'selected' : ''}>${opt.label}</option>`).join('')}
                            </select>
                            ${hint}
                        </div>
                    `;
                }
                case 'SELECT':
                    return `<select onchange="updateRecordField('${recordId}', '${field.id}', this.value)">
                        <option value="">Select...</option>
                        ${field.config.options.map(opt => `<option value="${opt}" ${opt === value ? 'selected' : ''}>${opt}</option>`).join('')}
                    </select>`;
                default:
                    return `<input type="text" value="${value || ''}" onchange="updateRecordField('${recordId}', '${field.id}', this.value)">`;
            }
        }

        function updateRecordField(recordId, fieldId, value) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);
            const oldValue = record[fieldId];
            updateRecord(recordId, fieldId, value, oldValue);
            renderExpandedRecordMain(recordId);
        }

        function switchRecordTab(tab) {
            state.currentRecordTab = tab;
            const recordId = document.getElementById('expandedRecordMain').dataset.recordId;
            renderExpandedRecordMain(recordId);
            renderRecordSidebar(recordId);
            updateRecordHistoryVisibility();
        }

        function renderRecordSidebar(recordId) {
            const container = document.getElementById('expandedRecordSidebar');
            document.querySelectorAll('.record-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === state.currentRecordTab);
            });

            if (!container) return;

            switch (state.currentRecordTab) {
                case 'connections':
                    renderConnectionsSidebar(container, recordId);
                    break;
                case 'provenance':
                    renderProvenanceSidebar(container, recordId);
                    break;
                case 'history':
                default:
                    renderHistorySidebar(container, recordId);
                    break;
            }
        }

        function renderHistorySidebar(container, recordId) {
            const history = state.eventStream.filter(e => e.object?.id === recordId && e.op === 'SEG');
            container.innerHTML = `
                <h3 class="font-semibold mb-4">Change History</h3>
                ${history.length === 0 ? '<p class="text-gray-500">No changes yet</p>' : ''}
                ${history.map(e => `
                    <div class="history-entry">
                        <div class="font-medium">${e.data?.fieldName || 'Field change'}</div>
                        <div class="text-sm text-gray-500">${getTimeAgo(e.published)}</div>
                        <div class="text-sm mt-1">
                            <span class="text-red-600">${e.data?.oldValue}</span> 
                            <span class="text-green-600">${e.data?.newValue}</span>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function renderProvenanceSidebar(container, recordId) {
            const set = getCurrentSet();
            const record = set.records.get(recordId);

            // Get creation event from event stream
            const creationEvent = state.eventStream.find(e =>
                e.op === 'INS' && e.object?.id === recordId
            );

            // Get import/source metadata from set
            const importMetadata = set.importMetadata || {};
            const recordMetadata = record._metadata || {};

            // Get all events related to this record
            const recordEvents = state.eventStream.filter(e =>
                e.object?.id === recordId || e.data?.recordId === recordId
            );

            // Determine source information
            const sourceSystem = recordMetadata.source?.system || importMetadata.sourceSystem || 'Unknown';
            const sourceFile = recordMetadata.source?.file || importMetadata.filename || 'Unknown';
            const importDate = creationEvent?.published || record.created_at || 'Unknown';

            // Get field-level provenance information
            const fieldsWithProvenance = set.schema.filter(field => {
                const value = record[field.id];
                return value && (value._sup || recordEvents.some(e => e.data?.fieldId === field.id));
            });

            container.innerHTML = `
                <h3 class="font-semibold mb-4">Record Provenance</h3>

                <div class="space-y-4">
                    <div class="provenance-section">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2">Origin</h4>
                        <div class="space-y-2 text-sm">
                            <div>
                                <span class="text-gray-600">Source:</span>
                                <span class="ml-2 font-medium">${sourceSystem}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">File:</span>
                                <span class="ml-2 font-medium">${sourceFile}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">Created:</span>
                                <span class="ml-2 font-medium">${formatTimestamp(importDate)}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">Record ID:</span>
                                <span class="ml-2 font-mono text-xs">${recordId}</span>
                            </div>
                        </div>
                    </div>

                    ${importMetadata.jurisdiction || importMetadata.frame ? `
                        <div class="provenance-section">
                            <h4 class="text-sm font-semibold text-gray-700 mb-2">Context</h4>
                            <div class="space-y-2 text-sm">
                                ${importMetadata.jurisdiction ? `
                                    <div>
                                        <span class="text-gray-600">Jurisdiction:</span>
                                        <span class="ml-2 font-medium">${importMetadata.jurisdiction}</span>
                                    </div>
                                ` : ''}
                                ${importMetadata.frame ? `
                                    <div>
                                        <span class="text-gray-600">Frame:</span>
                                        <span class="ml-2 font-medium">${importMetadata.frame}</span>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    ` : ''}

                    <div class="provenance-section">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2">Field Provenance</h4>
                        <p class="text-xs text-gray-500 mb-3">Click on any field in the record to view its detailed provenance</p>
                        ${fieldsWithProvenance.length > 0 ? `
                            <div class="space-y-2">
                                ${fieldsWithProvenance.map(field => {
                                    const value = record[field.id];
                                    const hasSUP = value && value._sup;
                                    const eventCount = recordEvents.filter(e => e.data?.fieldId === field.id).length;
                                    return `
                                        <div class="flex items-center justify-between text-sm p-2 bg-white rounded border border-gray-200 hover:border-blue-300 cursor-pointer transition" onclick="openCellHistory('${recordId}', '${field.id}')">
                                            <span class="font-medium">${field.name}</span>
                                            <div class="flex items-center gap-2">
                                                ${hasSUP ? '<span class="text-xs px-2 py-0.5 bg-purple-100 text-purple-700 rounded">SUP</span>' : ''}
                                                ${eventCount > 0 ? `<span class="text-xs text-gray-500">${eventCount} ${eventCount === 1 ? 'event' : 'events'}</span>` : ''}
                                                <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                                </svg>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<p class="text-sm text-gray-500">No field provenance available</p>'}
                    </div>

                    <div class="provenance-section">
                        <h4 class="text-sm font-semibold text-gray-700 mb-2">Activity Summary</h4>
                        <div class="space-y-2 text-sm">
                            <div>
                                <span class="text-gray-600">Total Events:</span>
                                <span class="ml-2 font-medium">${recordEvents.length}</span>
                            </div>
                            <div>
                                <span class="text-gray-600">Last Modified:</span>
                                <span class="ml-2 font-medium">${record.updated_at ? formatTimestamp(record.updated_at) : 'Never'}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function formatTimestamp(timestamp) {
            if (!timestamp || timestamp === 'Unknown') return 'Unknown';
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return timestamp;
            }
        }

        function getConnectionBuilder() {
            if (!state.connectionBuilder) {
                state.connectionBuilder = { targetSetId: null, targetRecordId: '', searchQuery: '', relationId: null, params: {} };
            }
            return state.connectionBuilder;
        }

        function renderConnectionsSidebar(container, recordId) {
            const builder = getConnectionBuilder();
            const setEntries = getSetsForWorld().map(set => [set.id, set]);
            const selectedSetId = builder.targetSetId && state.sets.has(builder.targetSetId)
                ? builder.targetSetId
                : (setEntries[0]?.[0] || null);
            if (builder.targetSetId !== selectedSetId) builder.targetSetId = selectedSetId;

            const formatOptions = getConnectionRelationView();
            const sidebarRelationId = builder.relationId && state.connectionRelations.has(builder.relationId)
                ? builder.relationId
                : (formatOptions[0]?.id || null);
            if (builder.relationId !== sidebarRelationId) builder.relationId = sidebarRelationId;
            const selectedRelation = findConnectionRelation(sidebarRelationId);

            const selectedSet = selectedSetId ? state.sets.get(selectedSetId) : null;
            const allAvailableRecords = selectedSet ? Array.from(selectedSet.records.values()).filter(r => r.id !== recordId) : [];
            const search = builder.searchQuery?.trim().toLowerCase() || '';
            const availableRecords = search
                ? allAvailableRecords.filter(rec => {
                    const displayName = getRecordDisplayName(rec.id) || '';
                    return displayName.toLowerCase().includes(search);
                })
                : allAvailableRecords;
            const selectedRecordId = availableRecords.some(rec => rec.id === builder.targetRecordId) ? builder.targetRecordId : '';
            if (builder.targetRecordId !== selectedRecordId) builder.targetRecordId = selectedRecordId;

            const connections = getConnectionView(edge =>
                (edge.subject?.type === 'Record' && edge.subject?.id === recordId) ||
                (edge.operand?.type === 'Record' && edge.operand?.id === recordId)
            );

            container.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold">Relationships</h3>
                        <p class="text-sm text-gray-600">Link this record to other records.</p>
                    </div>
                    <div class="border border-gray-200 bg-white rounded-lg p-4 space-y-3">
                        <label class="form-label">Select set</label>
                        <select id="newConnectionSet" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionSetChange('${recordId}', this.value)">
                            ${setEntries.length === 0 ? '<option value="">No sets available</option>' : ''}
                            ${setEntries.map(([id, set]) => `<option value="${id}" ${id === selectedSetId ? 'selected' : ''}>${set.name || id}</option>`).join('')}
                        </select>
                        <label class="form-label">Search records</label>
                        <input
                            type="text"
                            class="border rounded px-3 py-2 text-sm w-full"
                            placeholder="Search by name or ID"
                            value="${builder.searchQuery || ''}"
                            oninput="handleConnectionSearchChange('${recordId}', this.value)"
                            ${!selectedSetId ? 'disabled' : ''}
                        />
                        <label class="form-label">Connect to</label>
                        <select id="newConnectionTarget" class="border rounded px-3 py-2 text-sm w-full" onchange="handleConnectionRecordChange('${recordId}', this.value)" ${!selectedSetId ? 'disabled' : ''}>
                            <option value="">${selectedSetId ? 'Select a record' : 'Select a set first'}</option>
                            ${availableRecords.length === 0 && selectedSetId ? `<option value="" disabled>${allAvailableRecords.length === 0 ? 'No records available' : 'No matches found'}</option>` : ''}
                            ${availableRecords.map(rec => `<option value="${rec.id}" ${rec.id === selectedRecordId ? 'selected' : ''}>${getRecordDisplayName(rec.id) || selectedSet?.name || 'Record'}</option>`).join('')}
                        </select>
                        <label class="form-label">Relation</label>
                        <select id="sidebarConnectionRelation" class="border rounded px-3 py-2 text-sm w-full" ${formatOptions.length === 0 ? 'disabled' : ''}>
                            <option value="">${formatOptions.length === 0 ? 'Add a connection relation first' : 'Select a relation'}</option>
                            ${formatOptions.map(rel => `<option value="${rel.id}" ${rel.id === sidebarRelationId ? 'selected' : ''}>${rel.operator}  ${rel.mode}</option>`).join('')}
                        </select>
                        <div class="text-xs text-gray-600">${selectedRelation ? `${selectedRelation.operator} / ${selectedRelation.mode}` : 'No relation selected'}</div>
                        <div id="sidebarConnectionParams" class="grid grid-cols-1 gap-2"></div>
                        <button class="btn btn-primary btn-sm" onclick="createConnectionFromSidebar('${recordId}')" ${(availableRecords.length === 0 || !selectedRecordId || !sidebarRelationId) ? 'disabled' : ''}>Add Connection</button>
                        ${availableRecords.length === 0
                            ? `<p class="text-xs text-gray-500">${allAvailableRecords.length === 0 ? 'Add records to the selected set to create connections.' : 'No records match your search.'}</p>`
                            : ''}
                    </div>
                    <div class="space-y-3">
                        ${connections.length === 0 ? '<p class="text-gray-500">No connections yet.</p>' : connections.map(edge => renderConnectionCard(edge, recordId)).join('')}
                    </div>
                </div>
            `;

            renderConnectionParamFields('sidebarConnectionParams', sidebarRelationId, builder.params || {});
            const sidebarRelationSelect = document.getElementById('sidebarConnectionRelation');
            if (sidebarRelationSelect) {
                sidebarRelationSelect.onchange = (event) => {
                    builder.relationId = event.target.value || null;
                    builder.params = {};
                    renderConnectionsSidebar(container, recordId);
                };
            }

            const paramInputs = document.getElementById('sidebarConnectionParams')?.querySelectorAll('[data-param-name]') || [];
            paramInputs.forEach(input => {
                input.oninput = () => {
                    const name = input.dataset.paramName;
                    const raw = (input.value || '').trim();
                    if (!raw) {
                        delete builder.params[name];
                        return;
                    }
                    try {
                        builder.params[name] = JSON.parse(raw);
                    } catch (err) {
                        builder.params[name] = raw;
                    }
                };
            });
        }

        function handleConnectionSetChange(recordId, setId) {
            const builder = getConnectionBuilder();
            builder.targetSetId = setId || null;
            builder.targetRecordId = '';
            builder.searchQuery = '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionRecordChange(recordId, targetId) {
            const builder = getConnectionBuilder();
            builder.targetRecordId = targetId || '';
            renderRecordSidebar(recordId);
        }

        function handleConnectionSearchChange(recordId, query) {
            const builder = getConnectionBuilder();
            builder.searchQuery = query;
            builder.targetRecordId = '';
            renderRecordSidebar(recordId);
        }

        function renderConnectionCard(edge, recordId) {
            const isSubject = edge.subject?.type === 'Record' && edge.subject?.id === recordId;
            const isOperand = edge.operand?.type === 'Record' && edge.operand?.id === recordId;
            const otherRef = isSubject ? edge.operand : edge.subject;
            const direction = isSubject ? '' : (isOperand ? '' : '');
            const timestamp = edge.updatedAt || edge.createdAt;

            return `
                <div class="border border-gray-200 rounded-lg p-3 bg-white">
                    <div class="flex items-center justify-between gap-3">
                        <div>
                            <div class="font-semibold">${direction} ${renderEntityLabel(otherRef)}</div>
                            <div class="text-xs text-gray-500">${edge.operator || 'CON'}  ${edge.mode || 'related to'}  ${timestamp ? getTimeAgo(timestamp) : ''}</div>
                        </div>
                        <div class="flex items-center gap-3">
                            <button class="text-sm text-blue-600" onclick="editConnectionParameters('${edge.id}', '${recordId}')">Edit parameters</button>
                            <button class="text-sm text-red-500" onclick="deleteConnectionFromSidebar('${edge.id}', '${recordId}')">Remove</button>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="text-xs font-semibold text-gray-600 mb-1">Parameters</div>
                        ${renderConnectionParams(edge.params)}
                    </div>
                </div>
            `;
        }

        function renderConnectionParams(params) {
            if (!params || !Object.keys(params).length) {
                return '<p class="text-xs text-gray-500">No parameters</p>';
            }

            return `<dl class="text-xs text-gray-700 space-y-1">
                ${Object.entries(params).map(([key, value]) => `
                    <div class="flex justify-between gap-2">
                        <dt class="font-medium text-gray-600">${key}</dt>
                        <dd class="text-right break-all text-gray-800">${typeof value === 'object' ? JSON.stringify(value) : value}</dd>
                    </div>
                `).join('')}
            </dl>`;
        }

        function parseConnectionParams(raw) {
            if (!raw || !raw.trim()) return {};

            let parsed;
            try {
                parsed = JSON.parse(raw);
            } catch (err) {
                throw new Error('Connection parameters must be valid JSON');
            }

            if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
                throw new Error('Connection parameters must be a JSON object');
            }

            return parsed;
        }

        function editConnectionParameters(connectionId, recordId) {
            const existing = state.connections.get(connectionId);
            if (!existing) {
                showToast('Relationship not found');
                return;
            }

            const currentJson = JSON.stringify(existing.params || {}, null, 2);
            const input = prompt('Edit relationship parameters (JSON object)', currentJson);
            if (input === null) return;

            let parsed;
            try {
                parsed = parseConnectionParams(input);
            } catch (err) {
                showToast(err.message);
                return;
            }

            try {
                updateConnection(connectionId, { params: parsed });
                renderRecordSidebar(recordId);
                showToast(' Parameters updated');
            } catch (error) {
                showToast(error.message);
            }
        }

        function getRecordDisplayName(recordId) {
            const ref = getRecordById(recordId);
            if (!ref) return null;

            const identifierFieldId = getIdentifierFieldForSet(ref.set, ref.setId === state.currentSetId ? state.currentViewId : null);
            const identifierValue = identifierFieldId ? ref.record?.[identifierFieldId] : null;
            if (identifierValue) return identifierValue;

            // Check common name properties
            if (ref.record?.name) return ref.record.name;
            if (ref.record?.title) return ref.record.title;
            if (ref.record?.label) return ref.record.label;

            // Look for any text-like field value in the schema order
            if (ref.set?.schema) {
                for (const field of ref.set.schema) {
                    if (['TEXT', 'LONG_TEXT'].includes(field.type)) {
                        const val = ref.record?.[field.id];
                        if (val && typeof val === 'string' && val.trim()) return val;
                    }
                }
            }

            // Last resort: look for any non-empty string value
            for (const [key, val] of Object.entries(ref.record || {})) {
                if (key !== 'id' && typeof val === 'string' && val.trim() && !val.startsWith('rec_')) {
                    return val;
                }
            }

            return null;
        }

        function getIdentifierFieldForSet(set, preferredViewId = null) {
            if (!set) return null;

            if (preferredViewId && set.views.has(preferredViewId)) {
                const preferredView = set.views.get(preferredViewId);
                if (preferredView?.identifierField) return preferredView.identifierField;
            }

            for (const view of set.views.values()) {
                if (view?.identifierField) return view.identifierField;
            }

            return inferIdentifierFieldId(set);
        }

        function openLinkedRecord(recordId) {
            if (!recordId) return;
            const ref = getRecordById(recordId);
            if (!ref) {
                showToast('Linked record not found');
                return;
            }

            const firstViewId = ref.set.views.size ? Array.from(ref.set.views.keys())[0] : null;
            if (ref.setId !== state.currentSetId) {
                switchSet(ref.setId, firstViewId);
            }
            openExpandedRecord(recordId);
        }

        function createConnectionFromSidebar(recordId) {
            const builder = getConnectionBuilder();
            const target = builder.targetRecordId || document.getElementById('newConnectionTarget')?.value;
            if (!target) {
                showToast('Select a record to connect');
                return;
            }

            const relationId = builder.relationId || document.getElementById('sidebarConnectionRelation')?.value;
            if (!relationId) {
                showToast('Select a connection relation');
                return;
            }

            const relation = findConnectionRelation(relationId);
            if (!relation) {
                showToast('Selected connection relation not found');
                return;
            }

            let params = {};
            try {
                params = collectParamsFromInputs('sidebarConnectionParams', relation);
            } catch (error) {
                showToast(error.message);
                return;
            }

            builder.targetRecordId = '';
            builder.params = {};
            addConnection({
                subject: { type: 'Record', id: recordId },
                operand: { type: 'Record', id: target },
                relationId,
                params
            });
            renderRecordSidebar(recordId);
            showToast('Relationship created');
        }

        function deleteConnectionFromSidebar(connectionId, recordId) {
            deleteConnection(connectionId);
            renderRecordSidebar(recordId);
            showToast('Relationship removed');
        }

        function updateRecordHistoryVisibility() {
            const historyColumn = document.getElementById('expandedRecordHistoryColumn');
            const mainWrapper = document.getElementById('expandedRecordMainWrapper');
            const toggleBtn = document.getElementById('toggleHistorySidebarBtn');
            const isVisible = state.recordHistoryVisible;

            if (historyColumn) historyColumn.classList.toggle('hidden', !isVisible);
            if (mainWrapper) {
                mainWrapper.classList.toggle('md:col-span-3', !isVisible);
                mainWrapper.classList.toggle('md:col-span-2', isVisible);
                mainWrapper.classList.toggle('border-r', isVisible);
            }
            if (toggleBtn) {
                toggleBtn.disabled = false;
                toggleBtn.textContent = state.recordHistoryVisible ? 'Hide History' : 'Show History';
            }
        }

        function toggleRecordHistoryVisibility() {
            state.recordHistoryVisible = !state.recordHistoryVisible;
            updateRecordHistoryVisibility();
        }

        function getPopupLayout(view) {
            const defaults = { size: 'medium', columns: 4, rows: 4 };
            view.popupLayout = { ...defaults, ...(view.popupLayout || {}) };
            return view.popupLayout;
        }

        function getPopupOrderedFields(set, view) {
            const defaultOrder = set.schema.map(f => f.id);
            view.popupFieldOrder = Array.isArray(view.popupFieldOrder) && view.popupFieldOrder.length
                ? view.popupFieldOrder
                : defaultOrder;
            const orderMap = new Map(view.popupFieldOrder.map((id, idx) => [id, idx]));
            return [...set.schema].sort((a, b) => {
                const aIndex = orderMap.has(a.id) ? orderMap.get(a.id) : Number.MAX_SAFE_INTEGER;
                const bIndex = orderMap.has(b.id) ? orderMap.get(b.id) : Number.MAX_SAFE_INTEGER;
                return aIndex - bIndex;
            });
        }

        function renderPopupSettings(targetIds = ['popupSettingsFields', 'popupSettingsSidebar']) {
            const popupModal = document.getElementById('popupSettingsModal');
            const modalOpen = popupModal && !popupModal.classList.contains('hidden');
            if (modalOpen) {
                renderPopupConfigurator();
            }
            renderInlinePopupSettings(targetIds);
        }

        function renderInlinePopupSettings(targetIds = ['popupSettingsFields']) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const popupSettingsHtml = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const criteriaValue = rule.criteria?.value || '';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);

                return `
                    <div class="border border-gray-200 rounded-lg p-4">
                        <div class="flex items-center justify-between gap-4 flex-wrap">
                            <div>
                                <div class="font-semibold text-gray-900">${field.name}</div>
                                <div class="text-sm text-gray-500">${field.type}</div>
                            </div>
                            <div class="flex items-center gap-3 flex-wrap">
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Visibility
                                    <select class="border rounded px-2 py-1" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                        <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                        <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                    </select>
                                </label>
                                <label class="text-sm text-gray-600 flex items-center gap-2">
                                    Criteria
                                    <select class="border rounded px-2 py-1" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                        <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                        <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                        <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                        <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                        <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                        <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                    </select>
                                </label>
                                <input
                                    type="text"
                                    class="border rounded px-3 py-1 text-sm ${needsValue ? '' : 'opacity-50'}"
                                    placeholder="Criteria value"
                                    value="${criteriaValue}"
                                    ${needsValue ? '' : 'disabled'}
                                    oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            const targets = Array.isArray(targetIds) ? targetIds : [targetIds];
            targets.forEach(id => {
                const container = document.getElementById(id);
                if (container) container.innerHTML = popupSettingsHtml;
            });
        }

        function openPopupSettingsModal() {
            state.popupUi = state.popupUi || { filter: 'all', activeTab: 'popupFields' };
            state.popupUi.filter = state.popupUi.filter || 'all';
            state.popupUi.activeTab = 'popupFields';
            renderPopupConfigurator();
            openModal('popupSettingsModal');
        }

        function updatePopupVisibilityRule(fieldId, visibility) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.visibility = visibility;
            logPopupEvent('visibility', { fieldId, visibility });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaType(fieldId, type) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.type = type;
            if (!['equals', 'notEquals', 'contains'].includes(type)) {
                rule.criteria.value = '';
            }
            renderPopupSettings();
            logPopupEvent('criteriaType', { fieldId, type });
            refreshOpenRecordModal();
        }

        function updatePopupCriteriaValue(fieldId, value) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            rule.criteria = rule.criteria || { type: 'always', value: '' };
            rule.criteria.value = value;
            logPopupEvent('criteriaValue', { fieldId, value });
            renderPopupSettings();
            refreshOpenRecordModal();
        }

        function setPopupTab(tab) {
            state.popupUi.activeTab = tab;
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === tab);
            });
            renderPopupConfigurator();
        }

        function setPopupFilter(filter) {
            state.popupUi.filter = filter;
            renderPopupConfigurator();
        }

        function renderPopupFilters() {
            const filters = [
                { id: 'all', label: 'All Fields' },
                { id: 'visible', label: ' Visible' },
                { id: 'hidden', label: ' Hidden' },
                { id: 'conditional', label: ' Conditional' }
            ];
            const container = document.getElementById('popupFilters');
            if (!container) return;
            container.innerHTML = filters.map(f => `
                <button class="popup-filter ${state.popupUi.filter === f.id ? 'active' : ''}" onclick="setPopupFilter('${f.id}')">${f.label}</button>
            `).join('');
        }

        function togglePopupFieldVisibility(fieldId) {
            const rule = ensurePopupRule(fieldId);
            if (!rule) return;
            const newVisibility = rule.visibility === 'hide' ? 'show' : 'hide';
            updatePopupVisibilityRule(fieldId, newVisibility);
        }

        function renderPopupFieldList() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];

            const fields = getPopupOrderedFields(set, view).filter(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                if (state.popupUi.filter === 'visible') return isVisible;
                if (state.popupUi.filter === 'hidden') return !isVisible;
                if (state.popupUi.filter === 'conditional') return hasCondition;
                return true;
            });

            const container = document.getElementById('popupFieldList');
            if (!container) return;

            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                const isVisible = !rule || rule.visibility !== 'hide';
                const hasCondition = rule?.criteria?.type && rule.criteria.type !== 'always';
                const typeMeta = FIELD_TYPES[field.type] || {};
                const typeLabel = typeMeta.name || field.type;
                return `
                    <div class="popup-field-card" draggable="true" data-field-id="${field.id}">
                        <div class="drag-handle"></div>
                        <div class="popup-field-icon">${renderIcon(typeMeta.icon || 'ph-app-window')}</div>
                        <div class="popup-field-meta">
                            <div class="popup-field-name">
                                ${field.name}
                                ${hasCondition ? '<span class="popup-badge warn">Conditional</span>' : ''}
                                ${!isVisible ? '<span class="popup-badge warn">Hidden</span>' : ''}
                            </div>
                            <div class="popup-field-type field-type">${typeLabel}</div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="popup-toggle ${isVisible ? 'active' : ''}" onclick="togglePopupFieldVisibility('${field.id}')"></div>
                            <button class="btn btn-secondary btn-sm" onclick="focusPopupCondition('${field.id}')"><i class="ph ph-sliders-horizontal"></i></button>
                        </div>
                    </div>
                `;
            }).join('');

            const popupFieldCountBadge = document.getElementById('popupFieldCountBadge');
            if (popupFieldCountBadge) popupFieldCountBadge.textContent = fields.length;
            attachPopupFieldDragHandlers();
        }

        function attachPopupFieldDragHandlers() {
            document.querySelectorAll('.popup-field-card').forEach(card => {
                card.addEventListener('dragstart', handlePopupFieldDragStart);
                card.addEventListener('dragover', handlePopupFieldDragOver);
                card.addEventListener('drop', handlePopupFieldDrop);
                card.addEventListener('dragend', handlePopupFieldDragEnd);
            });
        }

        function handlePopupFieldDragStart(e) {
            state.popupDraggedField = e.currentTarget.dataset.fieldId;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handlePopupFieldDragOver(e) {
            e.preventDefault();
            const target = e.currentTarget;
            if (state.popupDraggedField && target.dataset.fieldId !== state.popupDraggedField) {
                target.classList.add('drag-over');
            }
        }

        function handlePopupFieldDrop(e) {
            e.preventDefault();
            const targetId = e.currentTarget.dataset.fieldId;
            if (state.popupDraggedField && targetId && targetId !== state.popupDraggedField) {
                updatePopupFieldOrder(state.popupDraggedField, targetId);
                logPopupEvent('reorder', { from: state.popupDraggedField, to: targetId });
            }
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function handlePopupFieldDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.popup-field-card').forEach(el => el.classList.remove('drag-over'));
            state.popupDraggedField = null;
        }

        function updatePopupFieldOrder(draggedId, targetId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            const order = getPopupOrderedFields(set, view).map(f => f.id);
            const fromIndex = order.indexOf(draggedId);
            const toIndex = order.indexOf(targetId);
            if (fromIndex === -1 || toIndex === -1) return;

            order.splice(fromIndex, 1);
            order.splice(toIndex, 0, draggedId);
            view.popupFieldOrder = order;
            renderPopupConfigurator();
        }

        function renderPopupStats() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const fields = getPopupOrderedFields(set, view);
            const visibleCount = fields.reduce((count, field) => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id);
                return count + ((rule && rule.visibility === 'hide') ? 0 : 1);
            }, 0);
            const conditionalCount = view.popupVisibilityRules.filter(r => r.criteria?.type && r.criteria.type !== 'always').length;
            const popupVisibleCount = document.getElementById('popupVisibleCount');
            const popupConditionalCount = document.getElementById('popupConditionalCount');
            if (popupVisibleCount) popupVisibleCount.textContent = visibleCount;
            if (popupConditionalCount) popupConditionalCount.textContent = conditionalCount;
        }

        function renderPopupPreview() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const layout = getPopupLayout(view);
            const preview = document.getElementById('popupPreview');
            if (!preview) return;

            const record = Array.from(set.records.values())[0] || {};
            const fields = getPopupOrderedFields(set, view)
                .filter(field => shouldDisplayFieldInPopup(field, record))
                .slice(0, (layout.rows || 1) * (layout.columns || 1));

            preview.innerHTML = `
                <div class="popup-preview-header">
                    <span>Record Preview</span>
                    <span class="popup-pill">${layout.size}  ${layout.columns} cols  ${layout.rows} rows</span>
                </div>
                <div class="popup-preview-fields cols-${layout.columns}">
                    ${fields.map(field => `
                        <div class="popup-preview-field">
                            <div class="label">${field.name}</div>
                            <div class="value">${record[field.id] ?? ''}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderPopupLayoutOptions() {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);

            const sizeOptions = [
                { id: 'small', label: 'Small', desc: 'Compact width' },
                { id: 'medium', label: 'Medium', desc: 'Balanced width' },
                { id: 'large', label: 'Large', desc: 'Full dialog' }
            ];
            const sizeContainer = document.getElementById('popupSizeOptions');
            if (sizeContainer) {
                sizeContainer.innerHTML = sizeOptions.map(opt => `
                    <div class="popup-layout-option ${layout.size === opt.id ? 'active' : ''}" onclick="updatePopupSize('${opt.id}')">
                        <div class="font-semibold">${opt.label}</div>
                        <div class="text-sm text-gray-600">${opt.desc}</div>
                    </div>
                `).join('');
            }

            const columnContainer = document.getElementById('popupColumnOptions');
            if (columnContainer) {
                columnContainer.innerHTML = [1, 2, 3, 4].map(cols => `
                    <div class="popup-layout-option ${layout.columns === cols ? 'active' : ''}" onclick="updatePopupColumns(${cols})">
                        <div class="font-semibold">${cols} Column${cols > 1 ? 's' : ''}</div>
                        <div class="text-sm text-gray-600">${cols === 1 ? 'Single stack' : cols === 2 ? 'Split view' : cols === 3 ? 'Dense grid' : 'Quartered grid'}</div>
                    </div>
                `).join('');
            }
        }

        function updatePopupSize(size) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.size = size;
            logPopupEvent('size', { size });
            renderPopupConfigurator();
        }

        function updatePopupColumns(columns) {
            const view = getCurrentView();
            if (!view) return;
            const layout = getPopupLayout(view);
            layout.columns = columns;
            logPopupEvent('columns', { columns });
            renderPopupConfigurator();
        }

        function renderPopupConditions() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupVisibilityRules = view.popupVisibilityRules || [];
            const container = document.getElementById('popupConditionsList');
            if (!container) return;

            const fields = getPopupOrderedFields(set, view);
            container.innerHTML = fields.map(field => {
                const rule = view.popupVisibilityRules.find(r => r.fieldId === field.id) || { visibility: 'show', criteria: { type: 'always', value: '' } };
                const criteriaType = rule.criteria?.type || 'always';
                const needsValue = ['equals', 'notEquals', 'contains'].includes(criteriaType);
                return `
                    <div class="popup-condition-card" data-condition-field="${field.id}">
                        <div class="popup-condition-title">${field.name} <span class="popup-pill">${rule.visibility === 'hide' ? 'Hidden' : 'Shown'}</span></div>
                        <div class="popup-condition-row">
                            <label class="text-sm text-gray-600 flex items-center gap-2">Visibility
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupVisibilityRule('${field.id}', this.value)">
                                    <option value="show" ${rule.visibility !== 'hide' ? 'selected' : ''}>Show</option>
                                    <option value="hide" ${rule.visibility === 'hide' ? 'selected' : ''}>Hide</option>
                                </select>
                            </label>
                            <label class="text-sm text-gray-600 flex items-center gap-2">Criteria
                                <select class="border rounded px-2 py-2 text-sm" onchange="updatePopupCriteriaType('${field.id}', this.value)">
                                    <option value="always" ${criteriaType === 'always' ? 'selected' : ''}>Always</option>
                                    <option value="equals" ${criteriaType === 'equals' ? 'selected' : ''}>Value equals</option>
                                    <option value="notEquals" ${criteriaType === 'notEquals' ? 'selected' : ''}>Value not equal</option>
                                    <option value="contains" ${criteriaType === 'contains' ? 'selected' : ''}>Value contains</option>
                                    <option value="empty" ${criteriaType === 'empty' ? 'selected' : ''}>When empty</option>
                                    <option value="notEmpty" ${criteriaType === 'notEmpty' ? 'selected' : ''}>When not empty</option>
                                </select>
                            </label>
                            <input class="border rounded px-3 py-2 text-sm ${needsValue ? '' : 'opacity-50'}" placeholder="Criteria value" value="${rule.criteria?.value || ''}" ${needsValue ? '' : 'disabled'} oninput="updatePopupCriteriaValue('${field.id}', this.value)">
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPopupEvents() {
            const container = document.getElementById('popupEventStream');
            if (!container) return;
            if (state.popupEventStream.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-600">No recent configuration changes yet.</p>';
                return;
            }
            container.innerHTML = state.popupEventStream.map(evt => `
                <div class="popup-event">
                    <div class="popup-event-header">
                        <span>${evt.type}</span>
                        <span class="popup-event-time">${new Date(evt.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="text-sm text-gray-600">${describePopupEvent(evt)}</div>
                </div>
            `).join('');
        }

        function describePopupEvent(event) {
            const name = event.data?.fieldId ? getFieldNameById(event.data.fieldId) : '';
            switch (event.action) {
                case 'visibility':
                    return `${name || 'Field'} set to ${event.data.visibility}`;
                case 'criteriaType':
                    return `${name || 'Field'} criteria: ${event.data.type}`;
                case 'criteriaValue':
                    return `${name || 'Field'} criteria value updated`;
                case 'reorder':
                    return `Reordered fields (${event.data.from}  ${event.data.to})`;
                case 'size':
                    return `Modal size changed to ${event.data.size}`;
                case 'columns':
                    return `Layout updated to ${event.data.columns} columns`;
                case 'template':
                    return `Applied ${event.data.template} template`;
                default:
                    return event.type;
            }
        }

        function renderPopupRecentChanges() {
            const container = document.getElementById('popupRecentChanges');
            if (!container) return;
            const items = state.popupEventStream.slice(0, 4);
            container.innerHTML = items.length === 0
                ? '<p class="text-sm text-gray-500">No changes yet.</p>'
                : items.map(evt => `<div> ${describePopupEvent(evt)}</div>`).join('');
        }

        function logPopupEvent(action, data = {}) {
            const entry = { id: Date.now(), action, data, type: action, timestamp: new Date().toISOString() };
            state.popupEventStream.unshift(entry);
            state.popupEventStream = state.popupEventStream.slice(0, 25);
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        function resetPopupLayout() {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            view.popupLayout = { size: 'medium', columns: 4, rows: 4 };
            view.popupFieldOrder = set.schema.map(f => f.id);
            view.popupVisibilityRules = [];
            logPopupEvent('reset', {});
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function applyPopupTemplate(template) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;
            const ordered = getPopupOrderedFields(set, view);
            const layout = getPopupLayout(view);

            if (template === 'minimal') {
                layout.size = 'small';
                layout.columns = 1;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 4 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            } else if (template === 'detailed') {
                layout.size = 'large';
                layout.columns = 3;
                view.popupVisibilityRules = ordered.map(field => ({ fieldId: field.id, visibility: 'show', criteria: { type: 'always', value: '' } }));
            } else if (template === 'compact') {
                layout.size = 'medium';
                layout.columns = 2;
                view.popupVisibilityRules = ordered.map((field, idx) => ({ fieldId: field.id, visibility: idx < 6 ? 'show' : 'hide', criteria: { type: 'always', value: '' } }));
            }
            logPopupEvent('template', { template });
            renderPopupConfigurator();
            refreshOpenRecordModal();
        }

        function focusPopupCondition(fieldId) {
            setPopupTab('popupConditions');
            requestAnimationFrame(() => {
                const el = document.querySelector(`[data-condition-field="${fieldId}"]`);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }

        function getFieldNameById(fieldId) {
            const set = getCurrentSet();
            return set?.schema.find(f => f.id === fieldId)?.name || fieldId;
        }

        function renderPopupConfigurator() {
            const activeTab = state.popupUi?.activeTab || 'popupFields';
            document.querySelectorAll('.popup-config-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === activeTab);
            });
            document.querySelectorAll('.popup-tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === activeTab);
            });
            renderPopupFilters();
            renderPopupFieldList();
            renderPopupStats();
            renderPopupLayoutOptions();
            renderPopupPreview();
            renderPopupConditions();
            renderPopupEvents();
            renderPopupRecentChanges();
        }

        // CONTEXT MENUS
        function showColumnMenu(e, field) {
            const currentView = getCurrentView();
            const isIdentifier = currentView?.identifierField === field.id;
            const isRecordIdField = field.id === '__recordId';

            showContextMenu(e, [
                { label: 'Create View from Column', action: () => createViewFromColumn(field) },
                // Don't allow setting Record ID as the identifier field - it's static
                !isRecordIdField ? { label: isIdentifier ? 'Clear Identifier' : 'Use as Identifier', action: () => setIdentifierField(isIdentifier ? null : field.id) } : null,
                { label: 'Change Field Type', action: () => openChangeFieldTypeModal(field) },
                hasFieldHistory(getCurrentSet()?.id, field.id) ? { label: 'Revert Last Type Change', action: () => revertFieldType(field.id) } : null,
                { label: 'Hide Field', action: () => hideField(field.id) },
                { label: 'Delete Field', action: () => confirmDelete('field', field.id), danger: true }
            ].filter(Boolean));
        }

        function setIdentifierField(fieldId) {
            const set = getCurrentSet();
            const view = getCurrentView();
            if (!set || !view) return;

            view.identifierField = fieldId || null;

            createEvent(
                'View Identifier Update',
                'UPD',
                { type: 'View', id: view.id, setId: set.id },
                { identifierField: view.identifierField, summary: fieldId ? `Set ${fieldId} as identifier for ${view.name}` : `Cleared identifier for ${view.name}` },
                { scale: 'collection' }
            );

            renderCurrentView();
            showToast(fieldId ? ' Identifier updated' : 'Identifier cleared');
        }

        function openChangeFieldTypeModal(field) {
            state.changeFieldContext = field;
            state.changeFieldOriginalType = field?.type || null;
            const nameTarget = document.getElementById('changeFieldName');
            const input = document.getElementById('changeFieldTypeInput');
            if (nameTarget) nameTarget.textContent = field.name;
            if (input) input.value = field.type;
            renderChangeFieldTypeGrid(field.type);
            resetChangeFieldConfig(field.type, field);
            renderChangeFieldConfig(field.type);

            // Set initial subtype if field has one
            setTimeout(() => {
                const subtypeSelect = document.getElementById('changeFieldSubtypeSelect');
                if (subtypeSelect && field.subtype) {
                    subtypeSelect.value = field.subtype;
                }
            }, 0);

            renderChangeLinkSelect();
            updateChangeFieldTypeSummary(field.type);
            closeChangeFieldTypeDropdown();
            openModal('changeFieldTypeModal');
        }

        function showCellMenu(e, recordId, field) {
            showContextMenu(e, [
                { label: 'Create View from This Value', action: () => createViewFromValue(recordId, field) },
                { label: 'Open Cell History', action: () => openCellHistory(recordId, field.id) }
            ]);
        }

        function showContextMenu(e, items) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.top = `${e.clientY}px`;
            menu.style.left = `${e.clientX}px`;
            menu.innerHTML = items.map(item => `<div class="context-menu-item ${item.danger ? 'danger' : ''}">${item.label}</div>`).join('');
            menu.querySelectorAll('.context-menu-item').forEach((el, i) => {
                el.onclick = () => { items[i].action(); menu.remove(); };
            });
            document.body.appendChild(menu);
            setTimeout(() => {
                document.addEventListener('click', function close() { menu.remove(); document.removeEventListener('click', close); });
            }, 0);
        }

        function confirmDelete(type, id) {
            const messages = {
                field: 'Delete this field? This will remove data from all records.',
                record: 'Delete this record? This cannot be undone.'
            };
            showConfirm(messages[type], () => {
                if (type === 'field') deleteField(id);
                if (type === 'record') deleteRecord(id);
            });
        }

        function showConfirm(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            state.confirmCallback = callback;
            openModal('confirmModal');
        }

        function createViewFromColumn(field) {
            const set = getCurrentSet();
            if (!set) return;

            const keyRef = { setId: set.id, fieldId: field.id };
            const detection = autoDetectSchemaFromKey(keyRef);
            const viewName = `${field.name} Pivot`;
            const viewId = createView(set.id, viewName, {
                type: 'KEY_DERIVED',
                icon: 'ph-chart-pie',
                key: keyRef,
                schema: detection.schema,
                relationships: detection.relationships,
                rollups: detection.rollups
            });
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(' View created from column');
        }

        /**
         * Enhanced pivot view creation from a cell value
         * - Makes pivoted field first column
         * - Auto-hides redundant columns (same value across all matching records)
         * - Auto-applies smart merge rules based on field types
         * - Auto-sorts by date fields (newest first)
         * - Groups by categorical fields when useful
         */
        function createViewFromValue(recordId, field) {
            const set = getCurrentSet();
            const record = set?.records.get(recordId);
            if (!set || !record) return;

            const value = record[field.id];
            const filters = [[{ field: field.id, operator: 'equals', value }]];

            // Find all matching records to analyze for intelligent defaults
            const matchingRecords = Array.from(set.records.values()).filter(r => {
                const recordValue = r[field.id];
                if (value === null || value === undefined) {
                    return recordValue === null || recordValue === undefined;
                }
                if (typeof value === 'object') {
                    return JSON.stringify(recordValue) === JSON.stringify(value);
                }
                return recordValue === value;
            });

            const pivotAnalysis = analyzePivotData(set, matchingRecords, field.id);

            // Build column order: pivoted field first, then identifier, then rest
            const currentView = getCurrentView();
            const identifierFieldId = currentView?.identifierField || inferIdentifierFieldId(set);
            const baseOrder = (currentView?.columnOrder || set.schema.map(f => f.id))
                .filter(id => id !== field.id && id !== identifierFieldId);

            const columnOrder = [
                field.id,  // Pivoted field always first
                ...(identifierFieldId && identifierFieldId !== field.id ? [identifierFieldId] : []),
                ...baseOrder
            ];

            // Generate view name with count
            const displayValue = typeof value === 'object' ? JSON.stringify(value) : (value ?? 'Empty');
            const viewName = `${field.name}: ${String(displayValue).slice(0, 32)} (${matchingRecords.length})`;

            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-funnel-simple',
                filters,
                columnOrder,
                hiddenFields: pivotAnalysis.redundantFields,  // Hide fields with uniform values
                sorts: pivotAnalysis.suggestedSorts,
                groups: pivotAnalysis.suggestedGroups,
                columnRules: pivotAnalysis.suggestedColumnRules,
                pivotMetadata: {
                    pivotFieldId: field.id,
                    pivotValue: value,
                    matchCount: matchingRecords.length,
                    redundantFields: pivotAnalysis.redundantFields,
                    analysisTimestamp: Date.now()
                }
            });

            renderSidebar();
            switchSet(set.id, viewId);

            const hiddenCount = pivotAnalysis.redundantFields.length;
            const toastMsg = hiddenCount > 0
                ? ` Pivot view created (${hiddenCount} uniform column${hiddenCount > 1 ? 's' : ''} hidden)`
                : ' Pivot view created';
            showToast(toastMsg);
        }

        /**
         * Analyze matching records to determine:
         * - Which fields have uniform values (redundant for this pivot)
         * - Best sort order (date fields)
         * - Potential grouping fields
         * - Smart column merge rules
         */
        function analyzePivotData(set, matchingRecords, pivotFieldId) {
            const schema = set.schema || [];
            const redundantFields = [];
            const suggestedSorts = [];
            const suggestedGroups = [];
            const suggestedColumnRules = {};

            if (matchingRecords.length === 0) {
                return { redundantFields, suggestedSorts, suggestedGroups, suggestedColumnRules };
            }

            // Always hide the pivot field itself since all values are identical
            redundantFields.push(pivotFieldId);

            // Analyze each field
            let bestDateField = null;
            let bestGroupField = null;
            let groupFieldCardinality = 0;

            for (const field of schema) {
                if (field.id === pivotFieldId) continue;

                // Collect all values for this field
                const values = matchingRecords.map(r => r[field.id]);
                const nonNullValues = values.filter(v => v !== null && v !== undefined && v !== '');
                const uniqueValues = new Set(nonNullValues.map(v =>
                    typeof v === 'object' ? JSON.stringify(v) : String(v)
                ));

                // Check if field is uniform (all same value) - candidate for hiding
                if (uniqueValues.size <= 1 && nonNullValues.length > 0) {
                    // Only hide if we have more than 1 record (otherwise nothing is "uniform")
                    if (matchingRecords.length > 1) {
                        redundantFields.push(field.id);
                    }
                }

                // Identify best date field for sorting
                if (field.type === 'DATE' || field.type === 'DATETIME' ||
                    field.name.toLowerCase().includes('date') ||
                    field.name.toLowerCase().includes('created') ||
                    field.name.toLowerCase().includes('updated')) {
                    if (!bestDateField) {
                        bestDateField = field;
                    }
                }

                // Identify good grouping candidates (categorical with reasonable cardinality)
                const isCategorial = field.type === 'SELECT' || field.type === 'TEXT' ||
                    field.type === 'SINGLE_SELECT' || field.type === 'STATUS';
                const cardinality = uniqueValues.size;

                // Good grouping: 2-10 unique values, and less than half of total records
                if (isCategorial && cardinality >= 2 && cardinality <= 10 &&
                    cardinality < matchingRecords.length * 0.5) {
                    if (cardinality > groupFieldCardinality) {
                        bestGroupField = field;
                        groupFieldCardinality = cardinality;
                    }
                }

                // Suggest column rules based on field type
                if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                    // Numeric fields: could aggregate
                    if (uniqueValues.size > 1) {
                        suggestedColumnRules[field.id] = { rule: 'sup_all' };
                    }
                } else if (field.type === 'DATE' || field.type === 'DATETIME') {
                    // Date fields: prefer newest
                    suggestedColumnRules[field.id] = { rule: 'prefer_newest' };
                } else if (field.type === 'LONG_TEXT' || field.type === 'RICH_TEXT') {
                    // Long text: show all
                    suggestedColumnRules[field.id] = { rule: 'sup_all' };
                }
            }

            // Add date sort if found
            if (bestDateField) {
                suggestedSorts.push({ fieldId: bestDateField.id, direction: 'desc' });
            }

            // Add grouping if found a good candidate (but only if we have enough records)
            if (bestGroupField && matchingRecords.length >= 4) {
                suggestedGroups.push({ fieldId: bestGroupField.id });
            }

            return { redundantFields, suggestedSorts, suggestedGroups, suggestedColumnRules };
        }

        // SEARCH DATA FUNCTIONALITY
        function getRecordDisplayLabel(record, set) {
            if (!record || !set) return '';

            const identifierFieldId = getIdentifierFieldForSet(set);
            const identifierValue = identifierFieldId ? record[identifierFieldId] : null;

            return identifierValue || record.name || '';
        }

        // Global search state
        let currentFocusedItem = null;

        function openSearchDataModal() {
            openModal('searchDataModal');
            document.getElementById('searchDataInput').value = '';

            // Clear focus
            clearFocus();

            // Show zero-input search surface
            renderZeroInputSearch();

            // Set up event listeners
            const searchInput = document.getElementById('searchDataInput');
            const scopeRadios = document.querySelectorAll('input[name="searchScope"]');

            searchInput.oninput = () => performSearch();
            scopeRadios.forEach(radio => {
                radio.onchange = () => {
                    updateSearchScope();
                    performSearch();
                };
            });

            // Focus search input
            setTimeout(() => searchInput.focus(), 100);
        }

        function updateSearchScope() {
            const scope = document.querySelector('input[name="searchScope"]:checked').value;
            const scopeNames = {
                'everything': 'Everything',
                'fields': 'Fields',
                'records': 'Records',
                'values': 'Values'
            };
            document.getElementById('searchScopePill').textContent = `Scope: ${scopeNames[scope]}`;
        }

        // ZERO-INPUT SEARCH DATA HELPERS
        function getRecentItems(limit = 10) {
            const recent = [];
            const seen = new Set();

            // Get recent events from eventStream
            for (const event of state.eventStream) {
                if (recent.length >= limit) break;

                // Extract meaningful items from events
                if (event.object?.type === 'Set' && event.object?.id) {
                    const set = state.sets.get(event.object.id);
                    if (set && !seen.has(event.object.id)) {
                        recent.push({
                            label: set.name,
                            type: 'set',
                            setId: set.id,
                            action: () => {
                                navigateToSet(set.id);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(event.object.id);
                    }
                } else if (event.object?.type === 'Field' && event.data?.setId && event.data?.fieldId) {
                    const set = state.sets.get(event.data.setId);
                    const field = set?.schema.find(f => f.id === event.data.fieldId);
                    if (field && !seen.has(`${event.data.setId}-${event.data.fieldId}`)) {
                        recent.push({
                            label: `${field.name} (${set.name})`,
                            type: 'field',
                            setId: event.data.setId,
                            fieldId: event.data.fieldId,
                            action: () => {
                                navigateToSet(set.id);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(`${event.data.setId}-${event.data.fieldId}`);
                    }
                } else if (event.object?.type === 'Record' && event.data?.setId) {
                    const set = state.sets.get(event.data.setId);
                    const recordId = event.object.id.split('/')[1] || event.object.id;
                    const record = set?.records.get(recordId);
                    if (record && !seen.has(event.object.id)) {
                        const label = getRecordDisplayLabel(record, set);
                        recent.push({
                            label: `${label} (${set.name})`,
                            type: 'record',
                            setId: set.id,
                            recordId: recordId,
                            action: () => {
                                navigateToSet(set.id);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(event.object.id);
                    }
                } else if (event.object?.type === 'View' && event.data?.setId && event.data?.viewId) {
                    const set = state.sets.get(event.data.setId);
                    const view = set?.views.get(event.data.viewId);
                    if (view && !seen.has(event.object.id)) {
                        const viewIcon = view.icon || '';
                        recent.push({
                            label: `${viewIcon} ${view.name} (${set.name})`,
                            type: 'view',
                            setId: set.id,
                            viewId: event.data.viewId,
                            action: () => {
                                switchSet(set.id, event.data.viewId);
                                closeModal('searchDataModal');
                            }
                        });
                        seen.add(event.object.id);
                    }
                }
            }

            return recent;
        }

        function getFrequentFields(limit = 8) {
            // Track field access frequency from eventStream
            const fieldFrequency = new Map();

            state.eventStream.forEach(event => {
                if (event.data?.fieldId && event.data?.setId) {
                    const key = `${event.data.setId}/${event.data.fieldId}`;
                    fieldFrequency.set(key, (fieldFrequency.get(key) || 0) + 1);
                }
            });

            // Sort by frequency and take top N
            const sorted = Array.from(fieldFrequency.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit);

            return sorted.map(([key]) => {
                const [setId, fieldId] = key.split('/');
                const set = state.sets.get(setId);
                const field = set?.schema.find(f => f.id === fieldId);
                return field ? {
                    label: `${field.name} (${set.name})`,
                    type: 'field',
                    setId,
                    fieldId,
                    action: () => {
                        navigateToSet(setId);
                        closeModal('searchDataModal');
                    }
                } : null;
            }).filter(Boolean);
        }

        function getRecentChanges(limit = 5) {
            const changes = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Count events by type for today
            const todayEvents = state.eventStream.filter(event => {
                const eventDate = new Date(event.published || event.t);
                eventDate.setHours(0, 0, 0, 0);
                return eventDate.getTime() === today.getTime();
            });

            const recordCreateEvents = todayEvents.filter(e => e.verb === 'Create Record' || e.op === 'INS' && e.object?.type === 'Record');
            const fieldUpdateEvents = todayEvents.filter(e => e.verb === 'Update Field' || e.op === 'UPD' && e.object?.type === 'Field');
            const setCreateEvents = todayEvents.filter(e => e.verb === 'Create Set' || e.op === 'INS' && e.object?.type === 'Set');

            if (recordCreateEvents.length > 0) {
                changes.push({
                    label: `${recordCreateEvents.length} new record${recordCreateEvents.length > 1 ? 's' : ''} today`,
                    type: null,
                    action: () => {
                        // Show records created today
                        const results = { fields: [], records: [], values: [] };
                        const worldSets = getSetsForWorld();

                        recordCreateEvents.forEach(event => {
                            const setId = event.object?.setId || event.actor?.setId;
                            const recordId = event.object?.id;
                            if (setId && recordId) {
                                const set = worldSets.find(s => s.id === setId);
                                if (set && set.records && set.records.has(recordId)) {
                                    const record = set.records.get(recordId);
                                    const recordLabel = getRecordDisplayLabel(record, set);
                                    results.records.push({
                                        record,
                                        recordId,
                                        setId: set.id,
                                        setName: set.name,
                                        label: recordLabel
                                    });
                                }
                            }
                        });

                        renderSearchResults(results, 'new records today', 'records');
                    }
                });
            }

            if (fieldUpdateEvents.length > 0) {
                changes.push({
                    label: `${fieldUpdateEvents.length} field update${fieldUpdateEvents.length > 1 ? 's' : ''} today`,
                    type: null,
                    action: () => {
                        // Show fields updated today
                        const results = { fields: [], records: [], values: [] };
                        const worldSets = getSetsForWorld();
                        const processedFields = new Set();

                        fieldUpdateEvents.forEach(event => {
                            const setId = event.object?.setId || event.actor?.setId;
                            const fieldId = event.object?.id || event.object?.fieldId;
                            const fieldKey = `${setId}:${fieldId}`;

                            if (setId && fieldId && !processedFields.has(fieldKey)) {
                                processedFields.add(fieldKey);
                                const set = worldSets.find(s => s.id === setId);
                                if (set && set.schema) {
                                    const field = set.schema.find(f => f.id === fieldId);
                                    if (field) {
                                        results.fields.push({
                                            field,
                                            setId: set.id,
                                            setName: set.name
                                        });
                                    }
                                }
                            }
                        });

                        renderSearchResults(results, 'field updates today', 'fields');
                    }
                });
            }

            if (setCreateEvents.length > 0) {
                changes.push({
                    label: `${setCreateEvents.length} new set${setCreateEvents.length > 1 ? 's' : ''} today`,
                    type: null,
                    action: () => {
                        // Navigate to Sets view (main sidebar)
                        renderSidebar();
                        closeModal('searchDataModal');
                    }
                });
            }

            // If no changes today, show recent from this week
            if (changes.length === 0) {
                const weekAgo = new Date(today);
                weekAgo.setDate(weekAgo.getDate() - 7);
                const recentEvents = state.eventStream.filter(e => {
                    const eventDate = new Date(e.published || e.t);
                    return eventDate >= weekAgo;
                });

                if (recentEvents.length > 0) {
                    changes.push({
                        label: `${recentEvents.length} change${recentEvents.length > 1 ? 's' : ''} this week`,
                        type: null,
                        action: () => {
                            // Could show activity log or recent changes view
                            alert('Activity log view coming soon');
                        }
                    });
                }
            }

            return changes.slice(0, limit);
        }

        function getStructuralHighlights() {
            const highlights = [];
            const worldSets = getSetsForWorld();

            // Fields with definitions
            const fieldsWithDefinitions = [];
            worldSets.forEach(set => {
                set.schema?.forEach(field => {
                    if (field.definitionId) {
                        fieldsWithDefinitions.push({
                            field,
                            setId: set.id,
                            setName: set.name
                        });
                    }
                });
            });
            if (fieldsWithDefinitions.length > 0) {
                highlights.push({
                    label: `${fieldsWithDefinitions.length} field${fieldsWithDefinitions.length > 1 ? 's' : ''} with definitions`,
                    type: null,
                    action: () => {
                        const results = { fields: fieldsWithDefinitions, records: [], values: [] };
                        renderSearchResults(results, 'fields with definitions', 'fields');
                    }
                });
            }

            // Fields with connections
            const connections = getConnectionView();
            if (connections.length > 0) {
                highlights.push({
                    label: `${connections.length} connection${connections.length > 1 ? 's' : ''} defined`,
                    type: null,
                    action: () => {
                        openConnectionsPage();
                        closeModal('searchDataModal');
                    }
                });
            }

            // Large sets
            const largeSets = worldSets.filter(set => set.records?.size > 50);
            if (largeSets.length > 0) {
                highlights.push({
                    label: `${largeSets.length} set${largeSets.length > 1 ? 's' : ''} with 50+ records`,
                    type: null,
                    action: () => {
                        // Show large sets in the main view
                        renderSidebar();
                        closeModal('searchDataModal');
                    }
                });
            }

            // Shared fields (fields with same name across sets)
            const fieldNames = new Map();
            worldSets.forEach(set => {
                set.schema?.forEach(field => {
                    if (!fieldNames.has(field.name)) {
                        fieldNames.set(field.name, []);
                    }
                    fieldNames.get(field.name).push({ setId: set.id, setName: set.name, field });
                });
            });

            const sharedFieldsArray = Array.from(fieldNames.entries())
                .filter(([name, occurrences]) => occurrences.length > 1);

            if (sharedFieldsArray.length > 0) {
                highlights.push({
                    label: `${sharedFieldsArray.length} shared field${sharedFieldsArray.length > 1 ? 's' : ''} across sets`,
                    type: null,
                    action: () => {
                        // Show shared fields
                        const results = { fields: [], records: [], values: [] };
                        sharedFieldsArray.forEach(([name, occurrences]) => {
                            // Just show the first occurrence of each shared field
                            const first = occurrences[0];
                            results.fields.push({
                                field: first.field,
                                setId: first.setId,
                                setName: first.setName
                            });
                        });
                        renderSearchResults(results, 'shared fields across sets', 'fields');
                    }
                });
            }

            return highlights.slice(0, 4);
        }

        function getExploreSlices() {
            return [
                { label: 'All Definitions ', type: null, action: () => { openDefinitionsPage(); closeModal('searchDataModal'); } },
                { label: 'All Relations ', type: null, action: () => { openRelationsPage(); closeModal('searchDataModal'); } }
            ];
        }

        function renderZeroInputSearch() {
            const container = document.getElementById('searchDataResults');

            let html = '<div class="zero-input-section">';

            // Recent Items
            const recentItems = getRecentItems(8);
            if (recentItems.length > 0) {
                html += '<h3 class="zero-input-section-title">Recent</h3>';
                recentItems.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                            ${item.type ? `<span class="zero-input-type-label">${item.type}</span>` : ''}
                        </div>
                    `;
                });
                // Store actions
                window.zeroInputActions = recentItems.map(item => item.action || (() => {}));
            }

            // Frequently Used Fields
            const frequentFields = getFrequentFields(6);
            if (frequentFields.length > 0) {
                html += '<h3 class="zero-input-section-title">Frequently Used Fields</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                frequentFields.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                            ${item.type ? `<span class="zero-input-type-label">${item.type}</span>` : ''}
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...frequentFields.map(item => item.action || (() => {}))];
            }

            // Recent Changes
            const recentChanges = getRecentChanges(4);
            if (recentChanges.length > 0) {
                html += '<h3 class="zero-input-section-title">New & Updated</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                recentChanges.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...recentChanges.map(item => item.action || (() => {}))];
            }

            // Structural Highlights
            const structuralHighlights = getStructuralHighlights();
            if (structuralHighlights.length > 0) {
                html += '<h3 class="zero-input-section-title">Structural Highlights</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                structuralHighlights.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...structuralHighlights.map(item => item.action || (() => {}))];
            }

            // Explore
            const exploreSlices = getExploreSlices();
            if (exploreSlices.length > 0) {
                html += '<h3 class="zero-input-section-title">Explore</h3>';
                const startIdx = window.zeroInputActions?.length || 0;
                exploreSlices.forEach((item, idx) => {
                    html += `
                        <div class="zero-input-item" onclick="zeroInputActions[${startIdx + idx}]()">
                            <span class="zero-input-item-label">${item.label}</span>
                        </div>
                    `;
                });
                window.zeroInputActions = [...(window.zeroInputActions || []), ...exploreSlices.map(item => item.action || (() => {}))];
            }

            // Browse
            html += '<h3 class="zero-input-section-title">Browse</h3>';
            html += '<div class="browse-grid">';

            const worldSets = getSetsForWorld();
            const totalFields = worldSets.reduce((sum, set) => sum + (set.schema?.length || 0), 0);
            const totalRecords = worldSets.reduce((sum, set) => sum + (set.records?.size || 0), 0);
            const definitions = getDefinitionView();
            const connections = getConnectionView();

            html += `
                <div class="browse-item" onclick="renderSidebar(); closeModal('searchDataModal');">
                    Sets (${worldSets.length})
                </div>
                <div class="browse-item" onclick="alert('Fields browse coming soon');">
                    Fields (${totalFields})
                </div>
                <div class="browse-item" onclick="alert('Records browse coming soon');">
                    Records (${totalRecords})
                </div>
                <div class="browse-item" onclick="openDefinitionsPage(); closeModal('searchDataModal');">
                    Definitions (${definitions.length})
                </div>
                <div class="browse-item" onclick="openRelationsPage(); closeModal('searchDataModal');">
                    Relations (${connections.length})
                </div>
                <div class="browse-item" onclick="alert('Values browse coming soon');">
                    Values
                </div>
            `;

            html += '</div></div>';

            container.innerHTML = html;
        }

        function clearFocus() {
            currentFocusedItem = null;
            document.getElementById('focusPanel').classList.add('hidden');
            // Remove focused class from all items
            document.querySelectorAll('.result-item.focused').forEach(el => {
                el.classList.remove('focused');
            });
        }

        function performSearch() {
            const query = document.getElementById('searchDataInput').value;
            const scope = document.querySelector('input[name="searchScope"]:checked').value;

            if (!query || query.trim().length === 0) {
                renderZeroInputSearch();
                return;
            }

            const results = searchData(query, scope);
            renderSearchResults(results, query, scope);
        }

        function searchData(query, scope = 'everything') {
            const q = query.trim().toLowerCase();
            if (!q) return { fields: [], records: [], values: [], views: [] };

            const results = {
                fields: [],
                records: [],
                values: [],
                views: []
            };

            // Get all sets in current world
            const worldSets = getSetsForWorld();

            worldSets.forEach(set => {
                if (!set || !set.schema) return;

                // Search views - simple substring match
                if (scope === 'everything') {
                    if (set.views && set.views.size > 0) {
                        set.views.forEach((view, viewId) => {
                            if (view && view.name && view.name.toLowerCase().includes(q)) {
                                results.views.push({
                                    view,
                                    viewId,
                                    setId: set.id,
                                    setName: set.name
                                });
                            }
                        });
                    }
                }

                // Search fields - simple substring match
                if (scope === 'everything' || scope === 'fields') {
                    set.schema.forEach(field => {
                        if (field && field.name && field.name.toLowerCase().includes(q)) {
                            results.fields.push({
                                field,
                                setId: set.id,
                                setName: set.name
                            });
                        }
                    });
                }

                // Search records and values
                if (scope === 'everything' || scope === 'records' || scope === 'values') {
                    if (!set.records) return;

                    set.records.forEach((record, recordId) => {
                        if (!record) return;

                        // Get record label for searching
                        const recordLabel = getRecordDisplayLabel(record, set);

                        // Search record labels - simple substring match
                        if ((scope === 'everything' || scope === 'records') && recordLabel && recordLabel.toLowerCase().includes(q)) {
                            results.records.push({
                                record,
                                recordId,
                                setId: set.id,
                                setName: set.name,
                                label: recordLabel
                            });
                        }

                        // Search cell values - simple substring match
                        if (scope === 'everything' || scope === 'values') {
                            set.schema.forEach(field => {
                                if (!field) return;

                                const value = record[field.id];
                                if (value != null && value !== '') {
                                    const valueStr = String(value).toLowerCase();
                                    if (valueStr.includes(q)) {
                                        results.values.push({
                                            recordId,
                                            fieldId: field.id,
                                            fieldName: field.name,
                                            value,
                                            setId: set.id,
                                            setName: set.name,
                                            recordLabel
                                        });
                                    }
                                }
                            });
                        }
                    });
                }
            });

            return results;
        }

        function renderSearchResults(results, query, scope) {
            const container = document.getElementById('searchDataResults');
            const totalResults = results.fields.length + results.records.length + results.values.length + (results.views?.length || 0);

            if (totalResults === 0) {
                container.innerHTML = `<p class="text-sm text-gray-400 px-5 pt-2">No results found for "${query}"</p>`;
                return;
            }

            let html = '';

            // Render Views
            if (results.views && results.views.length > 0) {
                html += `<div class="results-section">
                    <div class="results-section-title">Views</div>`;
                results.views.forEach((item, index) => {
                    if (index < 20) { // Limit display
                        const itemId = `view-${item.setId}-${item.viewId}`;
                        const viewIcon = item.view.icon || '';
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">${viewIcon} ${escapeHtml(item.view.name)}</div>
                                    <div class="result-meta">View  ${escapeHtml(item.setName)}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnView(${JSON.stringify(item)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (results.views.length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${results.views.length - 20} more</p>`;
                }
                html += `</div>`;
            }

            // Render Fields
            if (results.fields.length > 0) {
                html += `<div class="results-section">
                    <div class="results-section-title">Fields</div>`;
                results.fields.forEach((item, index) => {
                    if (index < 20) { // Limit display
                        const itemId = `field-${item.setId}-${item.field.id}`;
                        const usageCount = getFieldUsageCount(item.setId, item.field.id);
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">${escapeHtml(item.field.name)}</div>
                                    <div class="result-meta">Field  ${item.field.type}  ${usageCount} record${usageCount !== 1 ? 's' : ''}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnField(${JSON.stringify(item)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (results.fields.length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${results.fields.length - 20} more</p>`;
                }
                html += `</div>`;
            }

            // Render Records
            if (results.records.length > 0) {
                html += `<div class="results-section">
                    <div class="results-section-title">Records</div>`;
                results.records.forEach((item, index) => {
                    if (index < 20) {
                        const itemId = `record-${item.setId}-${item.recordId}`;
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">${escapeHtml(item.label)}</div>
                                    <div class="result-meta">Record  ${escapeHtml(item.setName)}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnRecord(${JSON.stringify(item)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (results.records.length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${results.records.length - 20} more</p>`;
                }
                html += `</div>`;
            }

            // Render Values
            if (results.values.length > 0) {
                // Group values by field
                const valuesByField = {};
                results.values.forEach(item => {
                    const key = `${item.setId}:${item.fieldId}`;
                    if (!valuesByField[key]) {
                        valuesByField[key] = {
                            fieldName: item.fieldName,
                            setName: item.setName,
                            setId: item.setId,
                            fieldId: item.fieldId,
                            values: []
                        };
                    }
                    valuesByField[key].values.push(item);
                });

                html += `<div class="results-section">
                    <div class="results-section-title">Values</div>`;

                Object.values(valuesByField).forEach((group, index) => {
                    if (index < 20) {
                        const itemId = `value-${group.setId}-${group.fieldId}`;
                        const displayValue = String(group.values[0].value).slice(0, 50);
                        html += `
                            <div class="result-item" id="${itemId}">
                                <div class="result-main">
                                    <div class="result-label">"${escapeHtml(displayValue)}"</div>
                                    <div class="result-meta">Value  appears in ${group.values.length} record${group.values.length !== 1 ? 's' : ''}</div>
                                </div>
                                <button class="focus-btn" onclick='focusOnValue(${JSON.stringify(group)}, "${itemId}")'>Focus</button>
                            </div>
                        `;
                    }
                });
                if (Object.keys(valuesByField).length > 20) {
                    html += `<p class="text-xs text-gray-500 px-3">...and ${Object.keys(valuesByField).length - 20} more</p>`;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function getFieldUsageCount(setId, fieldId) {
            const set = state.sets.get(setId);
            if (!set || !set.records) return 0;
            let count = 0;
            set.records.forEach(record => {
                if (record && record[fieldId] != null && record[fieldId] !== '') {
                    count++;
                }
            });
            return count;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function focusOnField(item, itemId) {
            currentFocusedItem = { type: 'field', data: item, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            // Update header
            document.getElementById('focusTitle').textContent = item.field.name;
            document.getElementById('focusSubtitle').textContent = `Field  ${item.field.type}  from ${item.setName}`;
            document.getElementById('focusTag').textContent = 'Field';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Provenance</h4>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(item.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Type:</span> <span class="focus-kv-value">${item.field.type}</span></div>`;

            if (item.field.description) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Description:</span> <span class="focus-kv-value">${escapeHtml(item.field.description)}</span></div>`;
            }

            const usageCount = getFieldUsageCount(item.setId, item.field.id);
            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Usage:</span> <span class="focus-kv-value">${usageCount} record${usageCount !== 1 ? 's' : ''}</span></div>`;

            // Check for metadata from provenance
            const set = state.sets.get(item.setId);
            if (set && set.metadata) {
                if (set.metadata.sourceSystem) {
                    bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Source System:</span> <span class="focus-kv-value">${escapeHtml(set.metadata.sourceSystem)}</span></div>`;
                }
                if (set.metadata.frame) {
                    bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Frame:</span> <span class="focus-kv-value">${escapeHtml(set.metadata.frame)}</span></div>`;
                }
            }

            bodyHtml += `</div>`;

            // Context Frame section
            bodyHtml += `<div class="focus-section">
                <h4>Context</h4>`;

            if (item.field.options) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Options:</span> <span class="focus-kv-value">${item.field.options.length} defined option${item.field.options.length !== 1 ? 's' : ''}</span></div>`;
            }

            if (item.field.format) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Format:</span> <span class="focus-kv-value">${escapeHtml(item.field.format)}</span></div>`;
            }

            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="createViewFromSearchField('${item.setId}', '${item.field.id}'); clearFocus();">Create View with this Field</button>
                <button class="focus-action-btn" onclick="navigateToSet('${item.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function focusOnRecord(item, itemId) {
            currentFocusedItem = { type: 'record', data: item, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            // Update header
            document.getElementById('focusTitle').textContent = item.label;
            document.getElementById('focusSubtitle').textContent = `Record  from ${item.setName}`;
            document.getElementById('focusTag').textContent = 'Record';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Provenance</h4>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(item.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Record ID:</span> <span class="focus-kv-value">${escapeHtml(item.recordId)}</span></div>`;

            // Get record details
            const set = state.sets.get(item.setId);
            const record = set ? set.records.get(item.recordId) : null;

            if (record) {
                // Show a few key fields
                let fieldCount = 0;
                if (set.schema) {
                    set.schema.forEach(field => {
                        if (fieldCount < 5 && record[field.id] != null && record[field.id] !== '') {
                            const value = String(record[field.id]).slice(0, 100);
                            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">${escapeHtml(field.name)}:</span> <span class="focus-kv-value">${escapeHtml(value)}</span></div>`;
                            fieldCount++;
                        }
                    });
                }
            }

            bodyHtml += `</div>`;

            // Context section
            bodyHtml += `<div class="focus-section">
                <h4>Context</h4>`;

            // Count connections
            const fullRecordId = `${item.setId}/${item.recordId}`;
            let connectionCount = 0;
            state.connections.forEach(conn => {
                if ((conn.subject.type === 'Record' && conn.subject.id === fullRecordId) ||
                    (conn.operand && conn.operand.type === 'Record' && conn.operand.id === fullRecordId)) {
                    connectionCount++;
                }
            });

            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Relationships:</span> <span class="focus-kv-value">${connectionCount} relationship${connectionCount !== 1 ? 's' : ''}</span></div>`;
            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="createViewFromSearchRecord('${item.setId}', '${item.recordId}'); clearFocus();">Create View from this Record</button>
                <button class="focus-action-btn" onclick="navigateToSet('${item.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            if (connectionCount > 0) {
                actionsHtml += `<button class="focus-action-btn" onclick="showRecordConnections('${item.setId}', '${item.recordId}');">View Relationships</button>`;
            }
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function focusOnValue(group, itemId) {
            currentFocusedItem = { type: 'value', data: group, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            const displayValue = String(group.values[0].value).slice(0, 50);

            // Update header
            document.getElementById('focusTitle').textContent = `"${displayValue}"`;
            document.getElementById('focusSubtitle').textContent = `Value  appears in ${group.values.length} record${group.values.length !== 1 ? 's' : ''}`;
            document.getElementById('focusTag').textContent = 'Value';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Provenance</h4>
                <div class="focus-kv"><span class="focus-kv-label">Field:</span> <span class="focus-kv-value">${escapeHtml(group.fieldName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(group.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Occurrences:</span> <span class="focus-kv-value">${group.values.length} record${group.values.length !== 1 ? 's' : ''}</span></div>`;

            // Show full value if it was truncated
            const fullValue = String(group.values[0].value);
            if (fullValue.length > 50) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Full Value:</span> <span class="focus-kv-value">${escapeHtml(fullValue)}</span></div>`;
            }

            bodyHtml += `</div>`;

            // Context section - show which records contain this value
            bodyHtml += `<div class="focus-section">
                <h4>Found In</h4>`;

            const recordCount = Math.min(5, group.values.length);
            for (let i = 0; i < recordCount; i++) {
                const val = group.values[i];
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-value">${escapeHtml(val.recordLabel || val.recordId)}</span></div>`;
            }

            if (group.values.length > 5) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">...and ${group.values.length - 5} more</span></div>`;
            }

            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="createViewFromSearchValue('${group.setId}', '${group.fieldId}', '${encodeURIComponent(JSON.stringify(group.values[0].value))}'); clearFocus();">Create View with this Value</button>
                <button class="focus-action-btn" onclick="navigateToSet('${group.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function focusOnView(item, itemId) {
            currentFocusedItem = { type: 'view', data: item, itemId };

            // Remove previous focused class
            document.querySelectorAll('.result-item.focused').forEach(el => el.classList.remove('focused'));
            // Add focused class to clicked item
            const itemEl = document.getElementById(itemId);
            if (itemEl) itemEl.classList.add('focused');

            // Show focus panel
            document.getElementById('focusPanel').classList.remove('hidden');

            const viewIcon = item.view.icon || '';

            // Update header
            document.getElementById('focusTitle').textContent = `${viewIcon} ${item.view.name}`;
            document.getElementById('focusSubtitle').textContent = `View  from ${item.setName}`;
            document.getElementById('focusTag').textContent = 'View';

            // Build provenance section
            let bodyHtml = '';

            // Provenance section
            bodyHtml += `<div class="focus-section">
                <h4>Details</h4>
                <div class="focus-kv"><span class="focus-kv-label">Set:</span> <span class="focus-kv-value">${escapeHtml(item.setName)}</span></div>
                <div class="focus-kv"><span class="focus-kv-label">Type:</span> <span class="focus-kv-value">${item.view.type || 'table'}</span></div>`;

            if (item.view.description) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Description:</span> <span class="focus-kv-value">${escapeHtml(item.view.description)}</span></div>`;
            }

            // Count included fields
            const fieldCount = item.view.fields?.length || 0;
            bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Fields:</span> <span class="focus-kv-value">${fieldCount} field${fieldCount !== 1 ? 's' : ''}</span></div>`;

            // Check for filters
            if (item.view.filters && item.view.filters.length > 0) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Filters:</span> <span class="focus-kv-value">${item.view.filters.length} filter${item.view.filters.length !== 1 ? 's' : ''} applied</span></div>`;
            }

            // Check for sorting
            if (item.view.sorts && item.view.sorts.length > 0) {
                bodyHtml += `<div class="focus-kv"><span class="focus-kv-label">Sorting:</span> <span class="focus-kv-value">${item.view.sorts.length} sort${item.view.sorts.length !== 1 ? 's' : ''} applied</span></div>`;
            }

            bodyHtml += `</div>`;

            document.getElementById('focusBody').innerHTML = bodyHtml;

            // Action buttons
            let actionsHtml = `
                <button class="focus-action-btn" onclick="switchSet('${item.setId}', '${item.viewId}'); closeModal('searchDataModal');">Open View</button>
                <button class="focus-action-btn" onclick="navigateToSet('${item.setId}'); closeModal('searchDataModal');">Open Set</button>
            `;
            document.getElementById('focusActions').innerHTML = actionsHtml;
        }

        function navigateToSet(setId) {
            state.currentSetId = setId;
            navigateTo('data');
            renderCurrentView();
        }

        function expandOneLevel(setId, recordIds) {
            const linkedRecordIds = new Set();
            const recordIdArray = Array.isArray(recordIds) ? recordIds : [recordIds];

            // Find all connections involving these records
            state.connections.forEach(conn => {
                recordIdArray.forEach(recordId => {
                    const fullRecordId = `${setId}/${recordId}`;

                    // Check if this record is the subject
                    if (conn.subject.type === 'Record' && conn.subject.id === fullRecordId) {
                        if (conn.operand.type === 'Record') {
                            // Extract setId and recordId from operand
                            const parts = conn.operand.id.split('/');
                            if (parts.length === 2) {
                                linkedRecordIds.add({ setId: parts[0], recordId: parts[1] });
                            }
                        }
                    }

                    // Check if this record is the operand
                    if (conn.operand.type === 'Record' && conn.operand.id === fullRecordId) {
                        if (conn.subject.type === 'Record') {
                            // Extract setId and recordId from subject
                            const parts = conn.subject.id.split('/');
                            if (parts.length === 2) {
                                linkedRecordIds.add({ setId: parts[0], recordId: parts[1] });
                            }
                        }
                    }
                });
            });

            return Array.from(linkedRecordIds);
        }

        function createViewFromSearchField(setId, fieldId) {
            const set = state.sets.get(setId);
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            // Create a pivot/grouped view by this field
            const keyRef = { setId, fieldId };
            const detection = autoDetectSchemaFromKey(keyRef);
            const viewName = `${field.name} Pivot`;
            const viewId = createView(set.id, viewName, {
                type: 'KEY_DERIVED',
                icon: 'ph-chart-pie',
                key: keyRef,
                schema: detection.schema,
                relationships: detection.relationships,
                showRecordId: false,
                hiddenFields: ['__recordId']
            });

            closeModal('searchDataModal');
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(' View created from field');
        }

        function createViewFromSearchRecord(setId, recordId) {
            const set = state.sets.get(setId);
            const record = set?.records.get(recordId);
            if (!set || !record) return;

            // Get linked records (1 level deep)
            const linkedRecords = expandOneLevel(setId, recordId);
            const recordLabel = getRecordDisplayLabel(record, set);

            // Create a filtered view showing this record and linked records
            const filters = [[{ field: 'id', operator: 'equals', value: recordId }]];

            // Add linked records to filter if any
            if (linkedRecords.length > 0) {
                linkedRecords.forEach(linked => {
                    if (linked.setId === setId) {
                        filters.push([{ field: 'id', operator: 'equals', value: linked.recordId }]);
                    }
                });
            }

            const viewName = `Record: ${recordLabel}`;
            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-file-text',
                filters,
                showRecordId: false,
                hiddenFields: ['__recordId']
            });

            closeModal('searchDataModal');
            renderSidebar();
            switchSet(set.id, viewId);
            showToast(` View created with record and ${linkedRecords.length} linked record${linkedRecords.length !== 1 ? 's' : ''}`);
        }

        function createViewFromSearchValue(setId, fieldId, encodedValue) {
            const set = state.sets.get(setId);
            if (!set) return;

            const field = set.schema.find(f => f.id === fieldId);
            if (!field) return;

            const value = JSON.parse(decodeURIComponent(encodedValue));
            const filters = [[{ field: fieldId, operator: 'equals', value }]];

            // Find all matching records to analyze for intelligent defaults
            const matchingRecords = Array.from(set.records.values()).filter(r => {
                const recordValue = r[fieldId];
                if (value === null || value === undefined) {
                    return recordValue === null || recordValue === undefined;
                }
                if (typeof value === 'object') {
                    return JSON.stringify(recordValue) === JSON.stringify(value);
                }
                return recordValue === value;
            });

            const pivotAnalysis = analyzePivotData(set, matchingRecords, fieldId);

            // Build column order: pivoted field first, then identifier, then rest
            const identifierFieldId = inferIdentifierFieldId(set);
            const baseOrder = set.schema.map(f => f.id)
                .filter(id => id !== fieldId && id !== identifierFieldId);

            const columnOrder = [
                fieldId,  // Pivoted field always first
                ...(identifierFieldId && identifierFieldId !== fieldId ? [identifierFieldId] : []),
                ...baseOrder
            ];

            // Merge hidden fields (include __recordId plus analyzed redundant fields)
            const hiddenFields = [...new Set(['__recordId', ...pivotAnalysis.redundantFields])];

            const displayValue = typeof value === 'object' ? JSON.stringify(value) : (value ?? 'Empty');
            const viewName = `${field.name}: ${String(displayValue).slice(0, 32)} (${matchingRecords.length})`;

            const viewId = createView(set.id, viewName, {
                type: 'grid',
                icon: 'ph-funnel-simple',
                filters,
                columnOrder,
                showRecordId: false,
                hiddenFields,
                sorts: pivotAnalysis.suggestedSorts,
                groups: pivotAnalysis.suggestedGroups,
                columnRules: pivotAnalysis.suggestedColumnRules,
                pivotMetadata: {
                    pivotFieldId: fieldId,
                    pivotValue: value,
                    matchCount: matchingRecords.length,
                    redundantFields: pivotAnalysis.redundantFields,
                    analysisTimestamp: Date.now()
                }
            });

            closeModal('searchDataModal');
            renderSidebar();
            switchSet(set.id, viewId);

            const hiddenCount = pivotAnalysis.redundantFields.length;
            const toastMsg = hiddenCount > 0
                ? ` Pivot view created (${hiddenCount} uniform column${hiddenCount > 1 ? 's' : ''} hidden)`
                : ' Pivot view created';
            showToast(toastMsg);
        }

        function registerInterpretationRule(rule, options = {}) {
            const normalizedRule = {
                rule_id: rule.rule_id || `rule_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                applies_to_op: rule.applies_to_op || null,
                description: rule.description || '',
                effect: rule.effect || 'none',
                frame: rule.frame || 'system',
                scale: rule.scale || 'system'
            };

            state.interpretationRules.push(normalizedRule);

            if (!options.skipEvent) {
                createEvent(
                    'Define Rule',
                    'REC',
                    { type: 'InterpretationRule', id: normalizedRule.rule_id },
                    { rule: normalizedRule, summary: normalizedRule.description },
                    { frame: normalizedRule.frame, scale: normalizedRule.scale }
                );
            }

            return normalizedRule;
        }

        function hideField(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            view.hiddenFields = view.hiddenFields || [];
            if (!view.hiddenFields.includes(fieldId)) view.hiddenFields.push(fieldId);
            if (fieldId === '__recordId') view.showRecordId = false;
            renderCurrentView();
            showToast(' Field hidden');
        }

        function showField(fieldId) {
            const view = getCurrentView();
            if (!view) return;

            view.hiddenFields = view.hiddenFields || [];
            const index = view.hiddenFields.indexOf(fieldId);
            if (index > -1) {
                view.hiddenFields.splice(index, 1);
            }
            if (fieldId === '__recordId') view.showRecordId = true;
            renderCurrentView();
            showToast(' Field shown');
        }

        function deleteField(fieldId) {
            const set = getCurrentSet();
            const fieldIndex = set.schema.findIndex(f => f.id === fieldId);
            if (fieldIndex === -1) return;
            const [field] = set.schema.splice(fieldIndex, 1);
            set.records.forEach(record => delete record[fieldId]);
            createEvent(
                'Delete Field',
                'NUL',
                { type: 'Field', id: fieldId, setId: set.id },
                { setId: set.id, fieldId, fieldName: field?.name, summary: `Deleted field ${field?.name || fieldId}` },
                { frame: 'schema', scale: 'collection' }
            );
            renderCurrentView();
            showToast(' Field deleted');
        }

        function deleteRecord(recordId) {
            const set = getCurrentSet();
            set.records.delete(recordId);
            if (state.selectedRecordIds) state.selectedRecordIds.delete(recordId);
            if (!state.selectedRecordIds || state.selectedRecordIds.size === 0) state.lastSelectedRecordId = null;
            createEvent(
                'Delete Record',
                'NUL',
                { type: 'Record', id: recordId, setId: set.id },
                { setId: set.id, recordId, summary: 'Record deleted' }
            );
            renderCurrentView();
            showToast(' Record deleted');
        }

        // UTILITIES
        function applyInterpretationRules(event) {
            const appliedRules = [];

            state.interpretationRules.forEach(rule => {
                if (rule.applies_to_op && rule.applies_to_op !== event.op) return;

                switch (rule.effect) {
                    case 'require_actor':
                        if (!event.actor || !event.actor.id) throw new Error('Events require an actor');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_object_id':
                        if (!event.object || !event.object.id) throw new Error('Operations require an object reference with an id');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'require_connection_endpoints':
                        if (!event.data?.edge?.subject || !event.data?.edge?.operand) throw new Error('Connections require both subject and operand');
                        appliedRules.push(rule.rule_id);
                        break;
                    case 'mark_deleted':
                        event.data = { ...event.data, deleted: true };
                        appliedRules.push(rule.rule_id);
                        break;
                    default:
                        break;
                }
            });

            return { ...event, appliedRules };
        }

        function createEvent(verb, op, object, data = {}, options = {}) {
            if (!state.operatorSet[op]) {
                throw new Error(`Invalid operator ${op}. Expected one of ${Object.keys(state.operatorSet).join(', ')}`);
            }

            const eventData = { ...data };

            if (options.summary && !eventData.summary) {
                eventData.summary = options.summary;
            }

            // Use lean context for compact event creation if available
            if (state.leanContext && options.useLeanContext !== false) {
                const compactEvent = state.leanContext.createCompactEvent(verb, op, object, eventData, options);
                // Add standard fields for backward compatibility
                compactEvent.frame = options.frame || 'ui';
                compactEvent.scale = options.scale || 'object';
                compactEvent.published = new Date(compactEvent.t).toISOString();
                compactEvent.actor = { type: state.currentUser.type, id: state.currentUser.id };
                compactEvent.verb = verb; // Keep full verb for compatibility
                compactEvent.data = eventData; // Keep full data for compatibility

                const interpretedEvent = applyInterpretationRules(compactEvent);
                state.eventStream.unshift(interpretedEvent);

                // Limit event history to prevent unbounded growth
                if (state.eventStream.length > 10000) {
                    state.eventStream = state.eventStream.slice(0, 5000);
                }

                return interpretedEvent;
            }

            // Fallback to standard event creation
            const event = {
                id: `event-${state.eventIdCounter++}`,
                verb: verb,
                op: op,
                frame: options.frame || 'ui',
                scale: options.scale || 'object',
                published: new Date().toISOString(),
                actor: { type: state.currentUser.type, id: state.currentUser.id },
                object: object,
                data: eventData
            };

            const interpretedEvent = applyInterpretationRules(event);
            state.eventStream.unshift(interpretedEvent);
            return interpretedEvent;
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span class="font-medium">${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function closeAllContextMenus() {
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
        }

        function closeAllModals(exceptId = null) {
            const remaining = [];
            state.modalStack.forEach(id => {
                if (id === exceptId) {
                    remaining.push(id);
                    return;
                }

                const modalEl = document.getElementById(id);
                if (modalEl) modalEl.classList.add('hidden');
            });
            state.modalStack = remaining;
        }

        function openModal(modalId) {
            closeAllContextMenus();
            closeAllModals(modalId);

            const modal = document.getElementById(modalId);
            if (!modal) return;

            modal.classList.remove('hidden');
            if (!state.modalStack.includes(modalId)) {
                state.modalStack.push(modalId);
            }
        }

        function closeModal(modalId) {
            closeAllContextMenus();
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('hidden');
            state.modalStack = state.modalStack.filter(id => id !== modalId);
        }

        function exportJSON() {
            const world = getWorld();
            const worldSets = getSetsForWorld(world?.id);
            const connections = getConnectionView();
            const definitions = getDefinitionView();
            const data = {
                world: world ? { ...world, setIds: Array.from(world.setIds || []) } : null,
                sets: worldSets.map(s => ({
                    ...s,
                    setIds: undefined,
                    records: Array.from(s.records.values()),
                    views: Array.from(s.views.values()),
                    profiles: Array.from(s.profiles.values())
                })),
                definitions,
                connectionRelations: getConnectionRelationView(),
                connections,
                eventStream: state.eventStream
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const nameToken = world?.name ? world.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : 'workbase';
            a.download = `${nameToken || 'workbase'}-export.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(' Exported data');
        }

        function importWorldFromJson(payload) {
            if (!payload) return;

            try {
                const data = typeof payload === 'string' ? JSON.parse(payload) : payload;
                const world = data.world || null;
                if (!world) throw new Error('No world data found in file');

                state.worlds = new Map();
                state.sets = new Map();
                state.definitions = new Map();
                state.connectionRelations = new Map();
                state.connections = new Map();
                state.expandedSets = new Set();
                state.openTabs = [];
                state.currentSpecialView = null;
                state.selectedRecordIds.clear();
                state.lastSelectedRecordId = null;
                state.selectedCell = null;
                state.lastSelectedCell = null;
                state.editingCell = null;
                state.csvImportState = { headers: [], rows: [], mappings: {}, previewRows: [], matches: [], targetMode: 'existing', targetSetId: null, newSetName: '' };
                state.fuzzyPanelState = { threshold: 0.65, matches: [] };

                const worldId = world.id || `world_${Date.now()}`;
                const normalizedWorld = { ...world, id: worldId, setIds: new Set(world.setIds || []) };
                state.worlds.set(worldId, normalizedWorld);

                (data.sets || []).forEach(rawSet => {
                    const setId = rawSet.id || `set_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    const records = new Map();
                    (rawSet.records || []).forEach(rec => {
                        const recId = rec.id || `rec_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                        records.set(recId, { ...rec, id: recId });
                    });

                    const views = new Map();
                    (rawSet.views || []).forEach(view => {
                        const viewId = view.id || `view_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                        views.set(viewId, { ...view, id: viewId });
                    });

                    const profiles = new Map();
                    (rawSet.profiles || []).forEach(profile => {
                        const profileId = profile.id || 'default';
                        profiles.set(profileId, { ...profile, id: profileId });
                    });

                    const normalizedSet = {
                        ...rawSet,
                        id: setId,
                        worldId: rawSet.worldId || worldId,
                        records,
                        views,
                        profiles
                    };

                    state.sets.set(setId, normalizedSet);
                    normalizedWorld.setIds.add(setId);
                    state.expandedSets.add(setId);
                });

                (data.definitions || []).forEach(def => {
                    const id = def.id || `def_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    state.definitions.set(id, { ...def, id });
                });

                (data.connectionRelations || []).forEach(rel => {
                    const id = rel.id || `REL_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    try {
                        const normalized = validateConnectionRelationPayload({ ...rel, id });
                        state.connectionRelations.set(id, normalized);
                    } catch (error) {
                        console.warn('Skipping invalid connection relation during import', error);
                    }
                });

                (data.connections || []).forEach(conn => {
                    const id = conn.id || `conn_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
                    try {
                        const normalized = validateConnectionPayload({ ...conn, id });
                        state.connections.set(id, normalized);
                    } catch (error) {
                        console.warn('Skipping invalid connection during import', error);
                    }
                });

                state.eventStream = Array.isArray(data.eventStream) ? data.eventStream : [];
                const numericIds = state.eventStream
                    .map(e => typeof e.id === 'string' && e.id.startsWith('event-') ? parseInt(e.id.replace('event-', '')) : null)
                    .filter(n => Number.isFinite(n));
                const maxId = numericIds.length ? Math.max(...numericIds) : state.eventStream.length;
                state.eventIdCounter = (maxId || 0) + 1;

                state.currentWorldId = worldId;
                state.currentSetId = Array.from(normalizedWorld.setIds)[0] || null;
                state.currentViewId = state.currentSetId ? Array.from(state.sets.get(state.currentSetId).views.keys())[0] || null : null;

                renderWorldSelector();
                renderSidebar();
                if (state.currentSetId) switchSet(state.currentSetId, state.currentViewId);
                renderHistory();
                showToast(' World imported');
            } catch (error) {
                console.error('Failed to import world JSON', error);
                showToast(' Could not import world JSON');
            }
        }

        function triggerWorldImport() {
            const input = document.getElementById('worldJsonInput');
            if (input) {
                input.value = '';
                input.click();
            }
        }

        function handleWorldFileSelected(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => importWorldFromJson(e.target?.result || '');
            reader.readAsText(file);
        }

        function convertSetToCsv(set) {
            const headers = ['id', ...set.schema.map(f => f.id)];
            const escapeValue = (value) => {
                if (value === null || value === undefined) return '';
                const str = typeof value === 'object' ? JSON.stringify(value) : String(value);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };
            const rows = Array.from(set.records.values()).map(record => headers.map(h => escapeValue(record[h])).join(','));
            return [headers.join(','), ...rows].join('\n');
        }

        function exportWorldCSVs() {
            const world = getWorld();
            const sets = getSetsForWorld();
            if (!sets.length) {
                showToast(' No sets to export in this world');
                return;
            }
            sets.forEach(set => {
                const csv = convertSetToCsv(set);
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const prefix = world?.name ? world.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : 'world';
                const setToken = set.name ? set.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') : set.id;
                a.href = url;
                a.download = `${prefix || 'world'}-${setToken || set.id}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            });
            showToast(' Exported CSV files for this world');
        }

        function renderHistory() {
            const container = document.getElementById('historyContent');
            container.innerHTML = state.eventStream.map(e => `
                <div class="history-entry">
                    <div class="font-medium">${e.verb} <span class="text-xs text-gray-500">(${e.op})</span></div>
                    <div class="text-sm text-gray-500">${getTimeAgo(e.published)}  Frame: ${e.frame}  Scale: ${e.scale}</div>
                    <div class="text-sm">${e.data?.summary || e.verb}</div>
                    ${e.appliedRules?.length ? `<div class="text-xs text-gray-400">Rules: ${e.appliedRules.join(', ')}</div>` : ''}
                </div>
            `).join('');
        }

        // EVENT LISTENERS
        function setupEventListeners() {
            setupToolbarMenu();

            const fieldTypeTrigger = document.getElementById('fieldTypeTrigger');
            if (fieldTypeTrigger) fieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleFieldTypeDropdown(); };

            const changeFieldTypeTrigger = document.getElementById('changeFieldTypeTrigger');
            if (changeFieldTypeTrigger) changeFieldTypeTrigger.onclick = (event) => { event.preventDefault(); toggleChangeFieldTypeDropdown(); };

            document.getElementById('saveChangeFieldTypeBtn').onclick = saveChangeFieldType;
            document.getElementById('cancelChangeFieldTypeBtn').onclick = closeChangeFieldTypeModal;
            document.getElementById('closeChangeFieldTypeBtn').onclick = closeChangeFieldTypeModal;
            const changeLinkToSet = document.getElementById('changeLinkToSet');
            if (changeLinkToSet) changeLinkToSet.onchange = (event) => { state.changeLinkedSetId = event.target.value; };

            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) filterBtn.onclick = openFilterModal;
            const sortBtn = document.getElementById('sortBtn');
            if (sortBtn) sortBtn.onclick = openSortModal;
            const visualizeBtn = document.getElementById('visualizeBtn');
            if (visualizeBtn) visualizeBtn.onclick = openVisualizationModal;
            document.getElementById('parseCsvTextBtn').onclick = previewCsvFromText;
            document.getElementById('csvFileInput').onchange = handleCsvFileSelected;
            document.getElementById('refreshCsvPreviewBtn').onclick = renderCsvPreview;
            document.getElementById('runCsvImportBtn').onclick = importCsvRecords;
            document.getElementById('cancelCsvImportBtn').onclick = () => closeModal('csvImportModal');
            document.getElementById('closeCsvImportBtn').onclick = () => closeModal('csvImportModal');

            // Provenance review modal event listeners
            document.getElementById('closeProvenanceReviewBtn').onclick = closeProvenanceReviewModal;
            document.getElementById('continueToMappingBtn').onclick = continueToColumnMapping;
            document.getElementById('skipProvenanceBtn').onclick = skipProvenanceReview;
            document.getElementById('provenanceFrame').onchange = (event) => {
                const customInput = document.getElementById('provenanceFrameCustom');
                if (event.target.value === 'custom') {
                    customInput.classList.remove('hidden');
                } else {
                    customInput.classList.add('hidden');
                }
            };
            document.getElementById('provenanceEnableExternalLink').onchange = (event) => {
                const urlInput = document.getElementById('provenanceExternalLinkUrl');
                if (event.target.checked) {
                    urlInput.classList.remove('hidden');
                } else {
                    urlInput.classList.add('hidden');
                }
            };

            document.querySelectorAll('input[name="csvImportTargetMode"]').forEach(input => {
                input.onchange = (event) => {
                    state.csvImportState.targetMode = event.target.value;
                    handleCsvTargetChange();
                };
            });
            document.getElementById('csvTargetSetSelect').onchange = (event) => {
                state.csvImportState.targetSetId = event.target.value || null;
                handleCsvTargetChange();
            };
            document.getElementById('csvNewSetName').oninput = (event) => {
                state.csvImportState.newSetName = event.target.value;
            };
            document.getElementById('closeFuzzyPanelBtn').onclick = closeFuzzyPanel;
            document.getElementById('refreshFuzzyMatchesBtn').onclick = renderFuzzyPanel;
            document.getElementById('fuzzyThresholdInput').oninput = renderFuzzyPanel;
            document.getElementById('closeHistoryBtn').onclick = () => document.getElementById('historyPanel').classList.remove('open');
            document.getElementById('toggleHistorySidebarBtn').onclick = toggleRecordHistoryVisibility;
            document.getElementById('closeExpandedRecordBtn').onclick = () => closeModal('expandedRecordModal');
            bindIconSelector('newSetIcon');
            bindIconSelector('newViewIcon');
            document.getElementById('closeIconPickerBtn').onclick = () => closeModal('iconPickerModal');
            document.getElementById('iconPickerSearch').oninput = (event) => {
                state.iconPickerQuery = event.target.value;
                state.iconPickerPage = 1;
                renderIconPickerOptions();
            };
            document.getElementById('closeFilterBtn').onclick = () => closeModal('filterModal');
            document.getElementById('closePopupSettingsBtn').onclick = () => closeModal('popupSettingsModal');
            document.getElementById('applyFiltersBtn').onclick = applyFilters;
            document.getElementById('clearFiltersBtn').onclick = clearFilters;
            document.getElementById('addFilterGroupBtn').onclick = addFilterGroup;
            document.getElementById('confirmCancelBtn').onclick = () => {
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            document.getElementById('confirmOkBtn').onclick = () => {
                if (state.confirmCallback) state.confirmCallback();
                state.confirmCallback = null;
                closeModal('confirmModal');
            };
            wireViewStageActions();
            document.getElementById('addSortRuleBtn').onclick = addSortRule;
            document.getElementById('clearSortsBtn').onclick = clearSorts;
            document.getElementById('applySortsBtn').onclick = applySortsFromModal;
            document.getElementById('closeSortBtn').onclick = () => closeModal('sortModal');
            const fieldNameInput = document.getElementById('newFieldName');
            if (fieldNameInput) fieldNameInput.addEventListener('input', resetFieldNameValidation);
          document.getElementById('saveAddFieldBtn').onclick = saveField;
          document.getElementById('cancelAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeAddFieldBtn').onclick = () => closeModal('addFieldModal');
          document.getElementById('closeColumnRulesBtn').onclick = () => closeModal('columnRulesModal');
          document.getElementById('columnRulesRuleSelect').onchange = (e) => {
                document.getElementById('columnRulesSetPicker').classList.toggle('hidden', e.target.value !== 'prefer_set');
                updateColumnRulesSummary();
            };
            document.getElementById('columnRulesFieldSelect').onchange = updateColumnRulesSummary;
            document.getElementById('columnRulesPreferredSet').onchange = updateColumnRulesSummary;

          // Record ID toggle switch
          const recordIdToggle = document.getElementById('recordIdToggle');
          const recordIdCheckbox = document.getElementById('recordIdVisibilityToggle');
          if (recordIdToggle && recordIdCheckbox) {
            recordIdToggle.onclick = () => {
              recordIdCheckbox.checked = !recordIdCheckbox.checked;
              recordIdToggle.classList.toggle('active', recordIdCheckbox.checked);
              toggleRecordIdVisibility(recordIdCheckbox.checked);
            };
          }

          // Row Numbers toggle switch
          const rowNumbersToggle = document.getElementById('rowNumbersToggle');
          const rowNumbersCheckbox = document.getElementById('rowNumbersVisibilityToggle');
          if (rowNumbersToggle && rowNumbersCheckbox) {
            rowNumbersToggle.onclick = () => {
              rowNumbersCheckbox.checked = !rowNumbersCheckbox.checked;
              rowNumbersToggle.classList.toggle('active', rowNumbersCheckbox.checked);
              toggleRowNumbers(rowNumbersCheckbox.checked);
            };
          }

          document.getElementById('saveColumnRuleBtn').onclick = saveColumnRule;
          document.getElementById('deleteColumnRuleBtn').onclick = deleteColumnRule;
          const addWorldBtn = document.getElementById('addWorldBtn');
          if (addWorldBtn) addWorldBtn.onclick = openAddWorldModal;
          document.getElementById('saveAddWorldBtn').onclick = saveWorldFromModal;
          document.getElementById('cancelAddWorldBtn').onclick = () => closeModal('addWorldModal');
          const worldSelect = document.getElementById('worldSelect');
          if (worldSelect) worldSelect.onchange = (e) => switchWorld(e.target.value);
          document.getElementById('exportWorldBtn').onclick = exportJSON;
          document.getElementById('viewWorldJsonBtn').onclick = openJsonViewer;
          document.getElementById('importWorldBtn').onclick = triggerWorldImport;
          document.getElementById('worldJsonInput').onchange = handleWorldFileSelected;
          document.getElementById('globalHistoryBtn').onclick = () => {
                document.getElementById('historyPanel').classList.add('open');
                renderHistory();
          };
          document.getElementById('saveAddSetBtn').onclick = () => {
                const nameInput = document.getElementById('newSetName');
                const name = nameInput.value.trim();
                const icon = extractIconToken(document.getElementById('newSetIcon').value.trim() || 'ph-squares-four');
                const worldId = document.getElementById('newSetWorld').value || state.currentWorldId;
                if (!name) { showToast(' Please enter a set name'); nameInput?.focus(); return; }
                if (state.setEditorContext?.setId) {
                    const set = state.sets.get(state.setEditorContext.setId);
                    const previousWorldId = set.worldId;
                    set.name = name;
                    set.icon = icon;
                    set.worldId = worldId;
                    if (previousWorldId && previousWorldId !== worldId) {
                        getWorld(previousWorldId)?.setIds?.delete(set.id);
                    }
                    getWorld(worldId)?.setIds?.add(set.id);
                    closeModal('addSetModal');
                    state.setEditorContext = null;
                    state.currentWorldId = worldId;
                    renderSidebar();
                    renderCurrentView();
                    showToast(' Set updated');
                } else {
                    const setId = createSet(name, icon, worldId);
                    closeModal('addSetModal');
                    document.getElementById('newSetName').value = '';
                    document.getElementById('newSetIcon').value = 'ph-squares-four';
                    syncIconSelector('newSetIcon');
                    createView(setId, 'All ' + name, { type: 'grid' });
                    state.expandedSets.add(setId);
                    state.currentWorldId = worldId;
                    renderSidebar();
                    switchSet(setId, null);
                    showToast(' Set created');
                    showConfirm('Import CSV into this set now?', () => {
                        openCsvImportModal(setId);
                    });
                }
            };
            document.getElementById('cancelAddSetBtn').onclick = () => { state.setEditorContext = null; closeModal('addSetModal'); };

            // Add Record modal handlers
            document.getElementById('cancelAddRecordBtn').onclick = () => { closeModal('addRecordModal'); };
            document.getElementById('saveAddRecordBtn').onclick = () => {
                const viewSelect = document.getElementById('addRecordViewSelect');
                if (!viewSelect || !viewSelect.value) {
                    showToast('Please select a view');
                    return;
                }

                try {
                    const { setId, viewId } = JSON.parse(viewSelect.value);
                    const set = state.sets.get(setId);
                    if (!set) {
                        showToast('Set not found');
                        return;
                    }

                    // Create a new record with default values based on schema
                    const record = { id: `rec_${Date.now()}` };
                    set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);

                    // If the selected view has filters, pre-populate the record with filter values
                    // so it's immediately visible after creation
                    const view = set.views.find(v => v.id === viewId);
                    if (view && view.filters && view.filters.length > 0) {
                        const firstGroup = view.filters[0];
                        const rules = firstGroup.filter(r => r.field);
                        rules.forEach(rule => {
                            if (rule.field && rule.value !== undefined) {
                                record[rule.field] = rule.value;
                            }
                        });
                    }

                    set.records.set(record.id, record);

                    // Switch to the selected view and show the new record
                    switchSet(setId, viewId);
                    closeModal('addRecordModal');
                    showToast(' Record added');
                } catch (e) {
                    console.error('Error adding record:', e);
                    showToast('Error adding record');
                }
            };

            document.getElementById('saveAddViewBtn').onclick = () => {
                const name = document.getElementById('newViewName').value.trim();
                const icon = extractIconToken(document.getElementById('newViewIcon').value.trim() || 'ph-table');
                const parentId = document.getElementById('newViewParent').value || null;
                const creationMode = document.querySelector('input[name="viewCreationMode"]:checked')?.value || 'blank';
                const viewType = document.querySelector('input[name="newViewType"]:checked')?.value || 'grid';
                const keyCandidate = document.getElementById('keyCandidateSelect')?.value || '';
                if (!name) { showConfirm('Please enter a view name', () => {}); return; }
                const set = state.sets.get(state.viewEditorContext?.setId || state.currentSetId);
                const setId = set?.id;
                if (!setId) return;
                if (state.viewEditorContext?.viewId && parentId && isViewDescendant(set, parentId, state.viewEditorContext.viewId)) {
                    showConfirm('You cannot nest a view under its own descendant.', () => {});
                    return;
                }

                if (state.viewEditorContext?.viewId) {
                    const view = set.views.get(state.viewEditorContext.viewId);
                    if (view) {
                        view.name = name;
                        view.icon = icon;
                        view.parentId = parentId;
                    }
                    closeModal('addViewModal');
                    state.viewEditorContext = null;
                    renderSidebar();
                    switchSet(setId, view?.id || state.currentViewId);
                    showToast(' View updated');
                } else {
                    if (creationMode === 'key' && keyCandidate.includes(':')) {
                        const [keySetId, fieldId] = keyCandidate.split(':');
                        const keyRef = { setId: keySetId, fieldId };
                        const detection = autoDetectSchemaFromKey(keyRef);
                        const viewId = createView(keySetId, name, {
                            type: 'KEY_DERIVED',
                            icon: 'ph-key',
                            parentId,
                            key: keyRef,
                            schema: detection.schema,
                            relationships: detection.relationships,
                            rollups: detection.rollups,
                            filters: [{ field: fieldId, operator: 'notEmpty' }]
                        });
                        createEvent(
                            'View Schema Update',
                            'SEG',
                            { type: 'View', id: viewId, setId: keySetId },
                            { viewId, changes: { schema: detection.schema, relationships: detection.relationships, rollups: detection.rollups }, summary: 'Auto-generated schema from key' },
                            { scale: 'collection' }
                        );
                        closeModal('addViewModal');
                        document.getElementById('newViewName').value = '';
                        document.getElementById('newViewIcon').value = 'ph-table';
                        syncIconSelector('newViewIcon');
                        state.viewEditorContext = null;
                        renderSidebar();
                        switchSet(keySetId, viewId);
                        showToast(' Generated view from key');
                    } else {
                        const viewId = createView(setId, name, { type: viewType, icon, parentId });
                        closeModal('addViewModal');
                        document.getElementById('newViewName').value = '';
                        document.getElementById('newViewIcon').value = 'ph-table';
                        syncIconSelector('newViewIcon');
                        state.viewEditorContext = null;
                        renderSidebar();
                        switchSet(setId, viewId);
                        showToast(' View created');
                    }
                }
            };
            document.getElementById('cancelAddViewBtn').onclick = () => { state.viewEditorContext = null; closeModal('addViewModal'); };
            const viewCreationModes = document.querySelectorAll('input[name="viewCreationMode"]');
            viewCreationModes.forEach(radio => {
                radio.onchange = (e) => {
                    const select = document.getElementById('keyCandidateSelect');
                    const enableKey = e.target.value === 'key';
                    if (select) select.disabled = !enableKey || select.options.length === 0;
                };
            });
            document.getElementById('saveKanbanConfigBtn').onclick = saveKanbanConfig;
            document.getElementById('cancelKanbanConfigBtn').onclick = () => closeModal('kanbanConfigModal');
            document.getElementById('closeJsonViewerBtn').onclick = () => closeModal('jsonViewerModal');
            document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;
            document.getElementById('closeSearchDataBtn').onclick = () => closeModal('searchDataModal');
        }

        document.addEventListener('click', (event) => {
            // Close Add Field Modal dropdown if clicking outside
            const addFieldSelector = document.querySelector('#addFieldModal .field-type-select');
            if (addFieldSelector && !addFieldSelector.contains(event.target)) {
                closeFieldTypeDropdown();
            }

            // Close Field Manager dropdown if clicking outside
            const fieldManagerSelector = document.querySelector('#fieldManagerModal .field-type-select');
            if (fieldManagerSelector && !fieldManagerSelector.contains(event.target)) {
                closeFieldManagerTypeDropdown();
            }

            // Close Change Field Type Modal dropdown if clicking outside
            const changeFieldSelector = document.querySelector('#changeFieldTypeModal .field-type-select');
            if (changeFieldSelector && !changeFieldSelector.contains(event.target)) {
                closeChangeFieldTypeDropdown();
            }
        });

        // Close modals when clicking outside (on overlay)
        document.addEventListener('click', (event) => {
            if (event.target.classList.contains('modal-overlay')) {
                const modalId = event.target.id;
                if (modalId) {
                    // Clear any editor context when closing modals
                    if (modalId === 'addViewModal') state.viewEditorContext = null;
                    if (modalId === 'addSetModal') state.setEditorContext = null;
                    closeModal(modalId);
                }
            }
        });

        // JSON VIEWER
        let currentJsonTab = 'all';
        
        function openJsonViewer() {
            currentJsonTab = 'all';
            renderJsonContent();
            openModal('jsonViewerModal');
        }
        
        function switchJsonTab(tab) {
            currentJsonTab = tab;
            document.querySelectorAll('.json-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.json-tab[data-tab="${tab}"]`).classList.add('active');
            renderJsonContent();
        }
        
        function renderJsonContent() {
            let data;

            switch(currentJsonTab) {
                case 'all': {
                    const world = getWorld();
                    const worldSets = getSetsForWorld();
                    const definitions = getDefinitionView();
                    const connections = getConnectionView();
                    data = {
                        world: world ? { ...world, setIds: Array.from(world.setIds || []) } : null,
                        worlds: Array.from(state.worlds.values()).map(w => ({ ...w, setIds: Array.from(w.setIds || []) })),
                        sets: worldSets.map(s => ({
                            ...s,
                            records: Array.from(s.records.values()),
                            views: Array.from(s.views.values()),
                            profiles: Array.from(s.profiles.values())
                        })),
                        definitions,
                        connections,
                        eventStream: state.eventStream,
                        operatorSet: state.operatorSet,
                        interpretationRules: state.interpretationRules,
                        currentSetId: state.currentSetId,
                        currentViewId: state.currentViewId
                    };
                    break;
                }
                case 'sets': {
                    data = getSetsForWorld().map(s => ({
                        id: s.id,
                        name: s.name,
                        icon: s.icon,
                        schema: s.schema,
                        recordCount: s.records.size,
                        viewCount: s.views.size,
                        records: Array.from(s.records.values()),
                        views: Array.from(s.views.values())
                    }));
                    break;
                }
                case 'current': {
                    const set = getCurrentSet();
                    const setRecordIds = set ? new Set(Array.from(set.records.keys())) : new Set();
                    data = set ? {
                        id: set.id,
                        name: set.name,
                        icon: set.icon,
                        schema: set.schema,
                        records: Array.from(set.records.values()),
                        views: Array.from(set.views.values()),
                        profiles: Array.from(set.profiles.values()),
                        definitions: getDefinitionView(def =>
                            (def.entity?.type === 'Record' && setRecordIds.has(def.entity?.id)) ||
                            (def.entity?.type === 'Field' && set.schema.some(f => f.id === def.entity?.id))
                        ),
                        connections: getConnectionView(conn => (
                            conn.subject?.type === 'Record' && setRecordIds.has(conn.subject?.id)
                        ) || (
                            conn.operand?.type === 'Record' && setRecordIds.has(conn.operand?.id)
                        ))
                    } : null;
                    break;
                }
                case 'events':
                    data = state.eventStream;
                    break;
            }
            
            const jsonString = JSON.stringify(data, null, 2);
            const highlighted = syntaxHighlight(jsonString);
            document.getElementById('jsonContent').innerHTML = highlighted;
        }
        
        function syntaxHighlight(json) {
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }
        
        function copyJsonToClipboard() {
            const content = document.getElementById('jsonContent').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const btn = document.getElementById('copyJsonBtn');
                const originalText = btn.textContent;
                btn.textContent = ' Copied!';
                btn.classList.add('btn-primary');
                btn.classList.remove('btn-secondary');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }, 2000);
            }).catch(err => {
                showToast(' Failed to copy');
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (state.editingCell) {
                        exitEditMode(false);
                        return;
                    }

                    if (state.selectedCell) {
                        state.selectedCell.td.classList.remove('cell-selected');
                        state.selectedCell = null;
                        state.lastSelectedCell = null;
                        return;
                    }

                    const openMenus = document.querySelectorAll('.context-menu');
                    if (openMenus.length) {
                        openMenus.forEach(menu => menu.remove());
                        return;
                    }

                    if (state.modalStack.length > 0) {
                        closeModal(state.modalStack[state.modalStack.length - 1]);
                    }
                }

                if (e.key === 'Enter' && state.selectedCell && !state.editingCell) {
                    e.preventDefault();
                    const { td, recordId, fieldId } = state.selectedCell;
                    const set = getCurrentSet();
                    const field = set?.schema.find(f => f.id === fieldId);
                    if (field) enterEditMode(td, recordId, field);
                }

                if (e.key === 'Tab' && state.selectedCell && !state.editingCell) {
                    e.preventDefault();
                    navigateToNextCell(e.shiftKey ? -1 : 1);
                }
            });

            // Add paste event handler for creating new records
            document.addEventListener('paste', (e) => {
                // Don't intercept paste if we're in edit mode or in a modal
                if (state.editingCell || state.modalStack.length > 0) return;

                // Don't intercept paste if the target is an input, textarea, or contentEditable
                const target = e.target;
                if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.contentEditable === 'true') {
                    return;
                }

                const set = getCurrentSet();
                if (!set) return;

                e.preventDefault();

                const clipboardData = e.clipboardData || window.clipboardData;
                const pastedData = clipboardData.getData('text');

                if (!pastedData || !pastedData.trim()) return;

                handlePasteData(pastedData);
            });
        }

        function handlePasteData(pastedData) {
            const set = getCurrentSet();
            if (!set) return;

            // Parse the pasted data - split by lines and tabs
            const lines = pastedData.split(/\r?\n/).filter(line => line.trim());
            if (lines.length === 0) return;

            // Get visible schema fields (excluding record ID)
            const view = getCurrentView();
            const profile = getCurrentProfile();
            const visibleFields = set.schema.filter(f =>
                f.type !== 'RECORD_ID' &&
                (!profile || profile.visibleFields.length === 0 || profile.visibleFields.includes(f.id))
            );

            if (visibleFields.length === 0) {
                showToast(' No editable fields available');
                return;
            }

            let recordsCreated = 0;

            lines.forEach((line, lineIndex) => {
                const values = line.split('\t');

                // Create a new record
                const recordId = `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const record = { id: recordId };

                // Set default values for all fields
                set.schema.forEach(f => record[f.id] = FIELD_TYPES[f.type].defaultValue);

                // Fill in values from pasted data
                values.forEach((value, colIndex) => {
                    if (colIndex < visibleFields.length) {
                        const field = visibleFields[colIndex];
                        const trimmedValue = value.trim();

                        // Convert value based on field type
                        if (field.type === 'NUMBER' || field.type === 'CURRENCY') {
                            record[field.id] = parseFloat(trimmedValue) || 0;
                        } else if (field.type === 'CHECKBOX') {
                            record[field.id] = trimmedValue.toLowerCase() === 'true' || trimmedValue === '1';
                        } else if (field.type === 'DATE') {
                            record[field.id] = trimmedValue;
                        } else {
                            record[field.id] = trimmedValue;
                        }
                    }
                });

                set.records.set(recordId, record);
                recordsCreated++;
            });

            renderCurrentView();

            const recordLabel = recordsCreated === 1 ? 'record' : 'records';
            showToast(` ${recordsCreated} ${recordLabel} added from paste`);
        }

        function navigateToNextCell(direction) {
            if (!state.selectedCell) return;

            const currentTd = state.selectedCell.td;
            const row = currentTd.parentElement;
            const cells = Array.from(row.querySelectorAll('.cell-editable'));
            const currentIndex = cells.indexOf(currentTd);

            const nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < cells.length) {
                const nextTd = cells[nextIndex];
                const recordId = nextTd.dataset.recordId;
                const fieldId = nextTd.dataset.fieldId;
                selectCell(nextTd, recordId, fieldId);
                return;
            }

            const tbody = row.parentElement;
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const rowIndex = rows.indexOf(row);
            const nextRowIndex = direction > 0 ? rowIndex + 1 : rowIndex - 1;

            if (nextRowIndex >= 0 && nextRowIndex < rows.length) {
                const nextRow = rows[nextRowIndex];
                const targetIndex = direction > 0 ? 0 : cells.length - 1;
                const nextTd = nextRow.querySelectorAll('.cell-editable')[targetIndex];
                if (nextTd) {
                    const recordId = nextTd.dataset.recordId;
                    const fieldId = nextTd.dataset.fieldId;
                    selectCell(nextTd, recordId, fieldId);
                }
            }
        }

        function openAddSetModal(setId = null) {
            const titleEl = document.getElementById('addSetModalTitle');
            const saveBtn = document.getElementById('saveAddSetBtn');
            const nameInput = document.getElementById('newSetName');
            const iconInput = document.getElementById('newSetIcon');
            const worldSelect = document.getElementById('newSetWorld');

            if (worldSelect) {
                worldSelect.innerHTML = '';
                state.worlds.forEach((world, id) => {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = world.name;
                    worldSelect.appendChild(opt);
                });
            }

            if (setId) {
                const set = state.sets.get(setId);
                state.setEditorContext = { setId };
                if (titleEl) titleEl.textContent = 'Edit Set';
                if (saveBtn) saveBtn.textContent = 'Save';
                if (nameInput) nameInput.value = set?.name || '';
                if (iconInput) iconInput.value = extractIconToken(set?.icon || 'ph-squares-four');
                if (worldSelect && set?.worldId) worldSelect.value = set.worldId;
            } else {
                state.setEditorContext = null;
                if (titleEl) titleEl.textContent = 'Create Set';
                if (saveBtn) saveBtn.textContent = 'Create';
                if (nameInput) nameInput.value = '';
                if (iconInput) iconInput.value = 'ph-squares-four';
                if (worldSelect) worldSelect.value = state.currentWorldId || worldSelect.options[0]?.value || '';
            }
            syncIconSelector('newSetIcon');
            openModal('addSetModal');
        }

        // LEAN CONTEXT TESTING
        function testLeanContextEfficiency() {
            if (!state.leanContext) {
                console.warn('Lean context not initialized');
                return;
            }

            console.log('=== LEAN CONTEXT EFFICIENCY TEST ===');

            // Get current state size
            const currentStateSize = JSON.stringify({
                sets: Array.from(state.sets.entries()),
                eventStream: state.eventStream
            }).length;

            // Get lean context overhead
            const leanContextSize = state.leanContext.estimateStorageSize();

            console.log('\n STORAGE METRICS:');
            console.log(`Current state size: ${(currentStateSize / 1024).toFixed(2)} KB`);
            console.log(`\nLean Context Overhead:`);
            console.log(`  - Templates: ${(leanContextSize.templates / 1024).toFixed(2)} KB (${leanContextSize.templateCount} templates)`);
            console.log(`  - String table: ${(leanContextSize.strings / 1024).toFixed(2)} KB (${leanContextSize.stringCount} strings)`);
            console.log(`  - Total overhead: ${(leanContextSize.total / 1024).toFixed(2)} KB`);

            // Calculate overhead percentage
            const overheadPercent = (leanContextSize.total / currentStateSize * 100).toFixed(2);
            console.log(`\n Context overhead: ${overheadPercent}% of state size`);

            // Count records with lean context
            let leanRecordCount = 0;
            let totalRecordCount = 0;

            state.sets.forEach(set => {
                set.records.forEach(record => {
                    totalRecordCount++;
                    if (record.__ctx) {
                        leanRecordCount++;
                    }
                });
            });

            console.log(`\n RECORD METRICS:`);
            console.log(`  - Total records: ${totalRecordCount}`);
            console.log(`  - Lean records: ${leanRecordCount}`);
            console.log(`  - Coverage: ${totalRecordCount > 0 ? ((leanRecordCount / totalRecordCount) * 100).toFixed(1) : 0}%`);

            // Event compression stats
            const compactEventCount = state.eventStream.filter(e => e.v && e.o && e.t && !e.id.startsWith('event-')).length;
            console.log(`\n EVENT METRICS:`);
            console.log(`  - Total events: ${state.eventStream.length}`);
            console.log(`  - Compact events: ${compactEventCount}`);
            console.log(`  - Compression rate: ${state.eventStream.length > 0 ? ((compactEventCount / state.eventStream.length) * 100).toFixed(1) : 0}%`);

            console.log('\n GOAL: Keep overhead < 15% for optimal performance');
            console.log(`${overheadPercent < 15 ? ' PASSED' : '  REVIEW NEEDED'}: Current overhead is ${overheadPercent}%`);

            return {
                stateSize: currentStateSize,
                overhead: leanContextSize.total,
                overheadPercent: parseFloat(overheadPercent),
                recordCoverage: totalRecordCount > 0 ? (leanRecordCount / totalRecordCount) * 100 : 0,
                eventCompression: state.eventStream.length > 0 ? (compactEventCount / state.eventStream.length) * 100 : 0
            };
        }

        // Export test function to global scope
        window.testLeanContextEfficiency = testLeanContextEfficiency;

        // INITIALIZE
        document.addEventListener('DOMContentLoaded', async () => {
            applyTimeBasedBranding();
            await initializeApp();
            setInterval(applyTimeBasedBranding, 30 * 60 * 1000);
        });
    </script>
</body>
</html>
